{
  "timestamp": "2025-09-22T02:29:49.998Z",
  "testType": "Repeatable Benchmark (Docker MCP Server)",
  "version": "1.0.0",
  "testResults": [
    {
      "testCase": "simple-math",
      "name": "Simple Math Question",
      "prompt": "What is 2+2?",
      "enhancedPrompt": "What is 2+2?\n\n## Detected Frameworks/Libraries:\n- **Frameworks**: typescript\n- **Detection Method**: keyword+project\n- **Confidence**: 80.0%\n- **Suggestions**: Default to typescript (no frameworks detected)\n\n\n## Framework Best Practices (from Context7):\n## /microsoft/typescript Documentation:\n# TypeScript Documentation\n\n## Error Handling Patterns\n\n### Try-Catch with Error Codes\n```typescript\ntry {\n  const result = await someAsyncOperation();\n  return result;\n} catch (error) {\n  if (error.code === 'ENOENT') {\n    this.logger.warn('File not found, using fallback');\n    return fallbackValue;\n  }\n  throw error;\n}\n```\n\n### Type-Safe Error Handling\n```typescript\nfunction handleError(error: unknown): never {\n  if (error instanceof Error) {\n    throw new Error(`Operation failed: ${error.message}`);\n  }\n  throw new Error('Unknown error occurred');\n}\n```\n\n## Async/Await Patterns\n\n### Promise Handling\n```typescript\nasync function processData(data: any[]): Promise<ProcessedData[]> {\n  try {\n    const results = await Promise.all(\n      data.map(async (item) => {\n        const processed = await processItem(item);\n        return processed;\n      })\n    );\n    return results;\n  } catch (error) {\n    this.logger.error('Data processing failed', { error });\n    throw error;\n  }\n}\n```\n\n## Type Definitions\n\n### Generic Types\n```typescript\ninterface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  error?: string;\n}\n\nfunction createApiResponse<T>(data: T, success: boolean = true): ApiResponse<T> {\n  return { data, success };\n}\n```\n\n## Best Practices\n\n### Proper Error Handling\n- Always use try-catch blocks for async operations\n- Check error codes for specific error types\n- Provide meaningful error messages\n- Use type guards for error narrowing\n\n### Type Safety\n- Use strict TypeScript configuration\n- Define proper interfaces and types\n- Use generic types for reusable code\n- Avoid `any` type when possible\n\n## Project Framework Documentation:\nTypeScript Best Practices:\n- Use strict mode configuration\n- Define proper interfaces and types\n- Avoid any type when possible\n- Use proper error handling patterns\n- Implement proper async/await patterns\n- Use generic types for reusable code\n- Follow naming conventions\nCommon Patterns:\n- Implement proper error handling\n- Use proper logging and debugging\n- Follow security best practices\n- Implement proper testing\n- Use proper documentation\n- Follow performance optimization guidelines\n\n## Project-specific Requirements:\nProject: PromptMCP\nArchitecture guidelines documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nMain project documentation available\nProject: Dynamic Framework Detection Guide\nArchitecture guidelines documented\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nProject: Context7 Integration Status\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nTesting requirements documented\n\n## Repository Context:\nProject name: promptmcp\nNode.js version: >=18.0.0\nUses TypeScript for type safety\nIncludes Node.js type definitions\nUses Vitest for testing\nUses ESLint for code linting\nTypeScript target: ES2022\nModule system: ESNext\nUses strict TypeScript mode\nEnforces explicit type annotations\n\n## Existing Code Patterns:\n```typescript\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      expect(analyzer).toBeDefined();\r\n    });\r\n\r\n    it('should analyze project structure', async () => {\r\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('{\"name\": \"test-project\"}'),\r\n        readdir: vi.fn().mockResolvedValue([\r\n          { name: 'src', isDirectory: () => true },\r\n          { name: 'package.json', isDirectory: () => false }\r\n        ]),\r\n        stat: vi.fn().mockResolvedValue({ isFile: () => true })\r\n      }));\r\n\r\n      const result = await analyzer.analyze('.');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.projectOverview).toBeDefined();\r\n      expect(result.dependencies).toBeDefined();\r\n      expect(result.configurations).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('CodeGenerator', () => {\r\n    it('should create generator instance', () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      expect(generator).toBeDefined();\r\n    });\r\n\r\n    it('should generate code based on description', async () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('{\"name\": \"test-project\"}'),\r\n        readdir: vi.fn().mockResolvedValue([\r\n          { name: 'src', isDirectory: () => true },\r\n          { name: 'package.json', isDirectory: () => false }\r\n        ]),\r\n        stat: vi.fn().mockResolvedValue({ isFile: () => true })\r\n      }));\r\n\r\n      const result = await analyzer.analyze('.');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.projectOverview).toBeDefined();\r\n      expect(result.dependencies).toBeDefined();\r\n      expect(result.configurations).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('CodeGenerator', () => {\r\n    it('should create generator instance', () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      expect(generator).toBeDefined();\r\n    });\r\n\r\n    it('should generate code based on description', async () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\nconst logger = new Logger('PromptMCP-HTTP');\r\n\r\nasync function startHttpServer() {\r\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\ntry {\nswitch (name) {\ncase 'promptmcp.enhance':\nif (!args || typeof args.prompt !== 'string') {\nthrow new Error('Invalid arguments: prompt is required and must be a string');\n}\n\nconst result = await this.enhanceTool.enhance({\nprompt: args.prompt,\ncontext: args.context || {},\noptions: {\nmaxTokens: 4000,\nincludeMetadata: true\n}\n});\nreturn {\ncontent: [\n{\ntype: 'text',\ntext: JSON.stringify(result, null, 2)\n}\n]\n};\n\ndefault:\nthrow new Error(`Unknown tool: ${name}`);\n}\n} catch (error) {\n        this.logger.error('Tool execution failed', { \r\n          tool: name, \r\n          error: (error as Error).message \r\n        });\r\n        throw error;\r\n      }\r\n```\n\n## Instructions:\nMake your response consistent with the project's existing patterns, best practices, and coding standards. Use the provided context to ensure your solution fits well with the existing codebase.",
      "originalTokens": 3,
      "enhancedTokens": 6141,
      "tokenRatio": 2047,
      "responseTime": 58,
      "context7Used": true,
      "context7LibrariesResolved": 1,
      "context7Libraries": [
        "/microsoft/typescript"
      ],
      "tokenEfficiencyScore": 20,
      "frameworkAccuracyScore": 20,
      "context7RelevanceScore": 20,
      "overEngineeringScore": 90,
      "overallScore": 18,
      "assessment": "POOR",
      "status": "COMPLETED"
    },
    {
      "testCase": "simple-html",
      "name": "Simple HTML Button",
      "prompt": "How do I create a button?",
      "enhancedPrompt": "How do I create a button?\n\n## Detected Frameworks/Libraries:\n- **Frameworks**: typescript\n- **Detection Method**: keyword+project\n- **Confidence**: 80.0%\n- **Suggestions**: Default to typescript (no frameworks detected)\n\n\n## Framework Best Practices (from Context7):\n## /microsoft/typescript Documentation:\n# TypeScript Documentation\n\n## Error Handling Patterns\n\n### Try-Catch with Error Codes\n```typescript\ntry {\n  const result = await someAsyncOperation();\n  return result;\n} catch (error) {\n  if (error.code === 'ENOENT') {\n    this.logger.warn('File not found, using fallback');\n    return fallbackValue;\n  }\n  throw error;\n}\n```\n\n### Type-Safe Error Handling\n```typescript\nfunction handleError(error: unknown): never {\n  if (error instanceof Error) {\n    throw new Error(`Operation failed: ${error.message}`);\n  }\n  throw new Error('Unknown error occurred');\n}\n```\n\n## Async/Await Patterns\n\n### Promise Handling\n```typescript\nasync function processData(data: any[]): Promise<ProcessedData[]> {\n  try {\n    const results = await Promise.all(\n      data.map(async (item) => {\n        const processed = await processItem(item);\n        return processed;\n      })\n    );\n    return results;\n  } catch (error) {\n    this.logger.error('Data processing failed', { error });\n    throw error;\n  }\n}\n```\n\n## Type Definitions\n\n### Generic Types\n```typescript\ninterface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  error?: string;\n}\n\nfunction createApiResponse<T>(data: T, success: boolean = true): ApiResponse<T> {\n  return { data, success };\n}\n```\n\n## Best Practices\n\n### Proper Error Handling\n- Always use try-catch blocks for async operations\n- Check error codes for specific error types\n- Provide meaningful error messages\n- Use type guards for error narrowing\n\n### Type Safety\n- Use strict TypeScript configuration\n- Define proper interfaces and types\n- Use generic types for reusable code\n- Avoid `any` type when possible\n\n## Project Framework Documentation:\nTypeScript Best Practices:\n- Use strict mode configuration\n- Define proper interfaces and types\n- Avoid any type when possible\n- Use proper error handling patterns\n- Implement proper async/await patterns\n- Use generic types for reusable code\n- Follow naming conventions\nCommon Patterns:\n- Implement proper error handling\n- Use proper logging and debugging\n- Follow security best practices\n- Implement proper testing\n- Use proper documentation\n- Follow performance optimization guidelines\n\n## Project-specific Requirements:\nProject: PromptMCP\nArchitecture guidelines documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nMain project documentation available\nProject: Dynamic Framework Detection Guide\nArchitecture guidelines documented\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nProject: Context7 Integration Status\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nTesting requirements documented\n\n## Repository Context:\nProject name: promptmcp\nNode.js version: >=18.0.0\nUses TypeScript for type safety\nIncludes Node.js type definitions\nUses Vitest for testing\nUses ESLint for code linting\nTypeScript target: ES2022\nModule system: ESNext\nUses strict TypeScript mode\nEnforces explicit type annotations\n\n## Existing Code Patterns:\n```typescript\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      expect(analyzer).toBeDefined();\r\n    });\r\n\r\n    it('should analyze project structure', async () => {\r\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('{\"name\": \"test-project\"}'),\r\n        readdir: vi.fn().mockResolvedValue([\r\n          { name: 'src', isDirectory: () => true },\r\n          { name: 'package.json', isDirectory: () => false }\r\n        ]),\r\n        stat: vi.fn().mockResolvedValue({ isFile: () => true })\r\n      }));\r\n\r\n      const result = await analyzer.analyze('.');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.projectOverview).toBeDefined();\r\n      expect(result.dependencies).toBeDefined();\r\n      expect(result.configurations).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('CodeGenerator', () => {\r\n    it('should create generator instance', () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      expect(generator).toBeDefined();\r\n    });\r\n\r\n    it('should generate code based on description', async () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('{\"name\": \"test-project\"}'),\r\n        readdir: vi.fn().mockResolvedValue([\r\n          { name: 'src', isDirectory: () => true },\r\n          { name: 'package.json', isDirectory: () => false }\r\n        ]),\r\n        stat: vi.fn().mockResolvedValue({ isFile: () => true })\r\n      }));\r\n\r\n      const result = await analyzer.analyze('.');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.projectOverview).toBeDefined();\r\n      expect(result.dependencies).toBeDefined();\r\n      expect(result.configurations).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('CodeGenerator', () => {\r\n    it('should create generator instance', () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      expect(generator).toBeDefined();\r\n    });\r\n\r\n    it('should generate code based on description', async () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\nconst logger = new Logger('PromptMCP-HTTP');\r\n\r\nasync function startHttpServer() {\r\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\ntry {\nswitch (name) {\ncase 'promptmcp.enhance':\nif (!args || typeof args.prompt !== 'string') {\nthrow new Error('Invalid arguments: prompt is required and must be a string');\n}\n\nconst result = await this.enhanceTool.enhance({\nprompt: args.prompt,\ncontext: args.context || {},\noptions: {\nmaxTokens: 4000,\nincludeMetadata: true\n}\n});\nreturn {\ncontent: [\n{\ntype: 'text',\ntext: JSON.stringify(result, null, 2)\n}\n]\n};\n\ndefault:\nthrow new Error(`Unknown tool: ${name}`);\n}\n} catch (error) {\n        this.logger.error('Tool execution failed', { \r\n          tool: name, \r\n          error: (error as Error).message \r\n        });\r\n        throw error;\r\n      }\r\n```\n\n## Instructions:\nMake your response consistent with the project's existing patterns, best practices, and coding standards. Use the provided context to ensure your solution fits well with the existing codebase.",
      "originalTokens": 6,
      "enhancedTokens": 6144,
      "tokenRatio": 1024,
      "responseTime": 56,
      "context7Used": true,
      "context7LibrariesResolved": 1,
      "context7Libraries": [
        "/microsoft/typescript"
      ],
      "tokenEfficiencyScore": 20,
      "frameworkAccuracyScore": 0,
      "context7RelevanceScore": 0,
      "overEngineeringScore": 90,
      "overallScore": 8,
      "assessment": "POOR",
      "status": "COMPLETED"
    },
    {
      "testCase": "medium-react",
      "name": "Medium React Component",
      "prompt": "Create a React component that displays a list of users with search functionality",
      "enhancedPrompt": "Create a React component that displays a list of users with search functionality\n\n## Detected Frameworks/Libraries:\n- **Frameworks**: react\n- **Detection Method**: keyword+project\n- **Confidence**: 80.0%\n- **Suggestions**: Detected react (keyword)\n\n\n## Framework Best Practices (from Context7):\n## /websites/react_dev Documentation:\n# React Documentation\n\n## Component Patterns\n\n### Functional Components with Hooks\n```typescript\nimport { useState, useEffect } from 'react';\n\ninterface ComponentProps {\n  initialValue: string;\n  onChange: (value: string) => void;\n}\n\nfunction MyComponent({ initialValue, onChange }: ComponentProps) {\n  const [value, setValue] = useState(initialValue);\n  \n  useEffect(() => {\n    onChange(value);\n  }, [value, onChange]);\n  \n  return (\n    <input\n      value={value}\n      onChange={(e) => setValue(e.target.value)}\n    />\n  );\n}\n```\n\n### Custom Hooks\n```typescript\nfunction useCustomHook(dependency: any) {\n  const [state, setState] = useState(initialValue);\n  \n  useEffect(() => {\n    // Side effect logic\n    return () => {\n      // Cleanup logic\n    };\n  }, [dependency]);\n  \n  return { state, setState };\n}\n```\n\n## Error Boundaries\n\n### Error Boundary Component\n```typescript\nclass ErrorBoundary extends React.Component {\n  constructor(props) {\n    super(props);\n    this.state = { hasError: false };\n  }\n  \n  static getDerivedStateFromError(error) {\n    return { hasError: true };\n  }\n  \n  componentDidCatch(error, errorInfo) {\n    console.error('Error caught by boundary:', error, errorInfo);\n  }\n  \n  render() {\n    if (this.state.hasError) {\n      return <h1>Something went wrong.</h1>;\n    }\n    \n    return this.props.children;\n  }\n}\n```\n\n## Best Practices\n\n### Hook Rules\n- Only call hooks at the top level\n- Don't call hooks inside loops, conditions, or nested functions\n- Use custom hooks to extract component logic\n\n### Performance\n- Use React.memo for expensive components\n- Use useMemo and useCallback for expensive calculations\n- Avoid creating objects in render methods\n\n## Project Framework Documentation:\nReact Best Practices:\n- Use functional components with hooks\n- Implement proper error boundaries\n- Use React.memo for performance optimization\n- Follow the rules of hooks\n- Use TypeScript for type safety\n- Implement proper state management\n- Use proper key props for lists\nCommon Patterns:\n- Implement proper error handling\n- Use proper logging and debugging\n- Follow security best practices\n- Implement proper testing\n- Use proper documentation\n- Follow performance optimization guidelines\n\n## Project-specific Requirements:\nProject: PromptMCP\nArchitecture guidelines documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nMain project documentation available\nProject: Dynamic Framework Detection Guide\nArchitecture guidelines documented\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nProject: Context7 Integration Status\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nTesting requirements documented\n\n## Repository Context:\nProject name: promptmcp\nNode.js version: >=18.0.0\nUses TypeScript for type safety\nIncludes Node.js type definitions\nUses Vitest for testing\nUses ESLint for code linting\nTypeScript target: ES2022\nModule system: ESNext\nUses strict TypeScript mode\nEnforces explicit type annotations\n\n## Existing Code Patterns:\n```typescript\nconst logger = new Logger('PromptMCP-HTTP');\r\n\r\nasync function startHttpServer() {\r\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      expect(analyzer).toBeDefined();\r\n    });\r\n\r\n    it('should analyze project structure', async () => {\r\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('{\"name\": \"test-project\"}'),\r\n        readdir: vi.fn().mockResolvedValue([\r\n          { name: 'src', isDirectory: () => true },\r\n          { name: 'package.json', isDirectory: () => false }\r\n        ]),\r\n        stat: vi.fn().mockResolvedValue({ isFile: () => true })\r\n      }));\r\n\r\n      const result = await analyzer.analyze('.');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.projectOverview).toBeDefined();\r\n      expect(result.dependencies).toBeDefined();\r\n      expect(result.configurations).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('CodeGenerator', () => {\r\n    it('should create generator instance', () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      expect(generator).toBeDefined();\r\n    });\r\n\r\n    it('should generate code based on description', async () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('{\"name\": \"test-project\"}'),\r\n        readdir: vi.fn().mockResolvedValue([\r\n          { name: 'src', isDirectory: () => true },\r\n          { name: 'package.json', isDirectory: () => false }\r\n        ]),\r\n        stat: vi.fn().mockResolvedValue({ isFile: () => true })\r\n      }));\r\n\r\n      const result = await analyzer.analyze('.');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.projectOverview).toBeDefined();\r\n      expect(result.dependencies).toBeDefined();\r\n      expect(result.configurations).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('CodeGenerator', () => {\r\n    it('should create generator instance', () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      expect(generator).toBeDefined();\r\n    });\r\n\r\n    it('should generate code based on description', async () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n```\n\n## Instructions:\nMake your response consistent with the project's existing patterns, best practices, and coding standards. Use the provided context to ensure your solution fits well with the existing codebase.",
      "originalTokens": 13,
      "enhancedTokens": 6594,
      "tokenRatio": 507.2307692307692,
      "responseTime": 64,
      "context7Used": true,
      "context7LibrariesResolved": 1,
      "context7Libraries": [
        "/websites/react_dev"
      ],
      "tokenEfficiencyScore": 40,
      "frameworkAccuracyScore": 100,
      "context7RelevanceScore": 50,
      "overEngineeringScore": 30,
      "overallScore": 65,
      "assessment": "NEEDS_IMPROVEMENT",
      "status": "COMPLETED"
    },
    {
      "testCase": "complex-fullstack",
      "name": "Complex Full-Stack Task",
      "prompt": "Build a full-stack application with user authentication, real-time chat, and file upload using Next.js, TypeScript, and PostgreSQL",
      "enhancedPrompt": "Build a full-stack application with user authentication, real-time chat, and file upload using Next.js, TypeScript, and PostgreSQL\n\n## Detected Frameworks/Libraries:\n- **Frameworks**: typescript\n- **Detection Method**: keyword+project\n- **Confidence**: 80.0%\n- **Suggestions**: Detected typescript (keyword)\n\n\n## CRITICAL Quality Requirements:\n\n### ðŸ”’ Security\nðŸ”¥ ** (Critical)**\n- Move inline <style> and <script> to external files\n- Generate Content Security Policy headers\n- Sanitize any dynamic content to prevent XSS\n- Validate all user inputs\n- Implement proper authentication and authorization\n- Use HTTPS for all communications\n\n## Framework Best Practices (from Context7):\n## /microsoft/typescript Documentation:\n# TypeScript Documentation\n\n## Error Handling Patterns\n\n### Try-Catch with Error Codes\n```typescript\ntry {\n  const result = await someAsyncOperation();\n  return result;\n} catch (error) {\n  if (error.code === 'ENOENT') {\n    this.logger.warn('File not found, using fallback');\n    return fallbackValue;\n  }\n  throw error;\n}\n```\n\n### Type-Safe Error Handling\n```typescript\nfunction handleError(error: unknown): never {\n  if (error instanceof Error) {\n    throw new Error(`Operation failed: ${error.message}`);\n  }\n  throw new Error('Unknown error occurred');\n}\n```\n\n## Async/Await Patterns\n\n### Promise Handling\n```typescript\nasync function processData(data: any[]): Promise<ProcessedData[]> {\n  try {\n    const results = await Promise.all(\n      data.map(async (item) => {\n        const processed = await processItem(item);\n        return processed;\n      })\n    );\n    return results;\n  } catch (error) {\n    this.logger.error('Data processing failed', { error });\n    throw error;\n  }\n}\n```\n\n## Type Definitions\n\n### Generic Types\n```typescript\ninterface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  error?: string;\n}\n\nfunction createApiResponse<T>(data: T, success: boolean = true): ApiResponse<T> {\n  return { data, success };\n}\n```\n\n## Best Practices\n\n### Proper Error Handling\n- Always use try-catch blocks for async operations\n- Check error codes for specific error types\n- Provide meaningful error messages\n- Use type guards for error narrowing\n\n### Type Safety\n- Use strict TypeScript configuration\n- Define proper interfaces and types\n- Use generic types for reusable code\n- Avoid `any` type when possible\n\n## Project Framework Documentation:\nTypeScript Best Practices:\n- Use strict mode configuration\n- Define proper interfaces and types\n- Avoid any type when possible\n- Use proper error handling patterns\n- Implement proper async/await patterns\n- Use generic types for reusable code\n- Follow naming conventions\nCommon Patterns:\n- Implement proper error handling\n- Use proper logging and debugging\n- Follow security best practices\n- Implement proper testing\n- Use proper documentation\n- Follow performance optimization guidelines\n\n## Project-specific Requirements:\nProject: PromptMCP\nArchitecture guidelines documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nMain project documentation available\nProject: Dynamic Framework Detection Guide\nArchitecture guidelines documented\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nProject: Context7 Integration Status\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nTesting requirements documented\n\n## Repository Context:\nProject name: promptmcp\nNode.js version: >=18.0.0\nUses TypeScript for type safety\nIncludes Node.js type definitions\nUses Vitest for testing\nUses ESLint for code linting\nTypeScript target: ES2022\nModule system: ESNext\nUses strict TypeScript mode\nEnforces explicit type annotations\n\n## Existing Code Patterns:\n```typescript\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      expect(analyzer).toBeDefined();\r\n    });\r\n\r\n    it('should analyze project structure', async () => {\r\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('{\"name\": \"test-project\"}'),\r\n        readdir: vi.fn().mockResolvedValue([\r\n          { name: 'src', isDirectory: () => true },\r\n          { name: 'package.json', isDirectory: () => false }\r\n        ]),\r\n        stat: vi.fn().mockResolvedValue({ isFile: () => true })\r\n      }));\r\n\r\n      const result = await analyzer.analyze('.');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.projectOverview).toBeDefined();\r\n      expect(result.dependencies).toBeDefined();\r\n      expect(result.configurations).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('CodeGenerator', () => {\r\n    it('should create generator instance', () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      expect(generator).toBeDefined();\r\n    });\r\n\r\n    it('should generate code based on description', async () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('{\"name\": \"test-project\"}'),\r\n        readdir: vi.fn().mockResolvedValue([\r\n          { name: 'src', isDirectory: () => true },\r\n          { name: 'package.json', isDirectory: () => false }\r\n        ]),\r\n        stat: vi.fn().mockResolvedValue({ isFile: () => true })\r\n      }));\r\n\r\n      const result = await analyzer.analyze('.');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.projectOverview).toBeDefined();\r\n      expect(result.dependencies).toBeDefined();\r\n      expect(result.configurations).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('CodeGenerator', () => {\r\n    it('should create generator instance', () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      expect(generator).toBeDefined();\r\n    });\r\n\r\n    it('should generate code based on description', async () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\nconst logger = new Logger('PromptMCP-HTTP');\r\n\r\nasync function startHttpServer() {\r\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\ntry {\nswitch (name) {\ncase 'promptmcp.enhance':\nif (!args || typeof args.prompt !== 'string') {\nthrow new Error('Invalid arguments: prompt is required and must be a string');\n}\n\nconst result = await this.enhanceTool.enhance({\nprompt: args.prompt,\ncontext: args.context || {},\noptions: {\nmaxTokens: 4000,\nincludeMetadata: true\n}\n});\nreturn {\ncontent: [\n{\ntype: 'text',\ntext: JSON.stringify(result, null, 2)\n}\n]\n};\n\ndefault:\nthrow new Error(`Unknown tool: ${name}`);\n}\n} catch (error) {\n        this.logger.error('Tool execution failed', { \r\n          tool: name, \r\n          error: (error as Error).message \r\n        });\r\n        throw error;\r\n      }\r\n```\n\n## Instructions:\nMake your response consistent with the project's existing patterns, best practices, and coding standards. Use the provided context to ensure your solution fits well with the existing codebase.",
      "originalTokens": 17,
      "enhancedTokens": 6193,
      "tokenRatio": 364.29411764705884,
      "responseTime": 60,
      "context7Used": true,
      "context7LibrariesResolved": 1,
      "context7Libraries": [
        "/microsoft/typescript"
      ],
      "tokenEfficiencyScore": 80,
      "frameworkAccuracyScore": 100,
      "context7RelevanceScore": 33,
      "overEngineeringScore": 0,
      "overallScore": 78,
      "assessment": "ACCEPTABLE",
      "status": "COMPLETED"
    },
    {
      "testCase": "typescript-debug",
      "name": "TypeScript Debug Task",
      "prompt": "Fix this TypeScript error: Property \"data\" does not exist on type \"unknown\" in my API response handler",
      "enhancedPrompt": "Fix this TypeScript error: Property \"data\" does not exist on type \"unknown\" in my API response handler\n\n## Detected Frameworks/Libraries:\n- **Frameworks**: typescript\n- **Detection Method**: keyword+project\n- **Confidence**: 80.0%\n- **Suggestions**: Detected typescript (keyword)\n\n\n## Framework Best Practices (from Context7):\n## /microsoft/typescript Documentation:\n# TypeScript Documentation\n\n## Error Handling Patterns\n\n### Try-Catch with Error Codes\n```typescript\ntry {\n  const result = await someAsyncOperation();\n  return result;\n} catch (error) {\n  if (error.code === 'ENOENT') {\n    this.logger.warn('File not found, using fallback');\n    return fallbackValue;\n  }\n  throw error;\n}\n```\n\n### Type-Safe Error Handling\n```typescript\nfunction handleError(error: unknown): never {\n  if (error instanceof Error) {\n    throw new Error(`Operation failed: ${error.message}`);\n  }\n  throw new Error('Unknown error occurred');\n}\n```\n\n## Async/Await Patterns\n\n### Promise Handling\n```typescript\nasync function processData(data: any[]): Promise<ProcessedData[]> {\n  try {\n    const results = await Promise.all(\n      data.map(async (item) => {\n        const processed = await processItem(item);\n        return processed;\n      })\n    );\n    return results;\n  } catch (error) {\n    this.logger.error('Data processing failed', { error });\n    throw error;\n  }\n}\n```\n\n## Type Definitions\n\n### Generic Types\n```typescript\ninterface ApiResponse<T> {\n  data: T;\n  success: boolean;\n  error?: string;\n}\n\nfunction createApiResponse<T>(data: T, success: boolean = true): ApiResponse<T> {\n  return { data, success };\n}\n```\n\n## Best Practices\n\n### Proper Error Handling\n- Always use try-catch blocks for async operations\n- Check error codes for specific error types\n- Provide meaningful error messages\n- Use type guards for error narrowing\n\n### Type Safety\n- Use strict TypeScript configuration\n- Define proper interfaces and types\n- Use generic types for reusable code\n- Avoid `any` type when possible\n\n## Project Framework Documentation:\nTypeScript Best Practices:\n- Use strict mode configuration\n- Define proper interfaces and types\n- Avoid any type when possible\n- Use proper error handling patterns\n- Implement proper async/await patterns\n- Use generic types for reusable code\n- Follow naming conventions\nCommon Patterns:\n- Implement proper error handling\n- Use proper logging and debugging\n- Follow security best practices\n- Implement proper testing\n- Use proper documentation\n- Follow performance optimization guidelines\n\n## Project-specific Requirements:\nProject: PromptMCP\nArchitecture guidelines documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nAPI documentation available\nContributing guidelines available\nContributing guidelines available\nContributing guidelines available\nTesting requirements documented\nContributing guidelines available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nContributing guidelines available\nMain project documentation available\nProject: Dynamic Framework Detection Guide\nArchitecture guidelines documented\nAPI documentation available\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nProject: Context7 Integration Status\nTesting requirements documented\nTesting requirements documented\nTesting requirements documented\nAPI documentation available\nTesting requirements documented\n\n## Repository Context:\nProject name: promptmcp\nNode.js version: >=18.0.0\nUses TypeScript for type safety\nIncludes Node.js type definitions\nUses Vitest for testing\nUses ESLint for code linting\nTypeScript target: ES2022\nModule system: ESNext\nUses strict TypeScript mode\nEnforces explicit type annotations\n\n## Existing Code Patterns:\n```typescript\nconst logger = new Logger('PromptMCP-HTTP');\r\n\r\nasync function startHttpServer() {\r\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const config = new ConfigService();\r\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const context7Integration = new Context7IntegrationService(logger, config);\r\n  \r\n  // Initialize Context7 integration\r\n  try {\r\n    logger.info('Initializing Context7 integration...');\r\n    await context7Integration.initialize();\r\n    logger.info('Context7 integration initialized successfully');\r\n  } catch (error) {\r\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\n  \r\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\n  const server = createServer(async (req, res) => {\r\n    // Enable CORS\r\n    res.setHeader('Access-Control-Allow-Origin', '*');\r\n    res.setHeader('Access-Control-Allow-Methods', 'GET, POST, OPTIONS');\r\n    res.setHeader('Access-Control-Allow-Headers', 'Content-Type');\r\n    \r\n    if (req.method === 'OPTIONS') {\r\n      res.writeHead(200);\r\n      res.end();\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'GET' && req.url === '/health') {\r\n      res.writeHead(200, { 'Content-Type': 'application/json' });\r\n      res.end(JSON.stringify({ \r\n        status: 'healthy', \r\n        service: 'PromptMCP',\r\n        version: '1.0.0',\r\n        timestamp: new Date().toISOString()\r\n      }));\r\n      return;\r\n    }\r\n    \r\n    if (req.method === 'POST' && req.url === '/enhance') {\r\n      try {\r\n        let body = '';\r\n        req.on('data', chunk => {\r\n          body += chunk.toString();\r\n        });\r\n        \r\n        req.on('end', async () => {\r\n          try {\r\n            const request = JSON.parse(body);\r\n            const result = await context7Integration.enhancePrompt(\r\n              request.prompt,\r\n              request.context || {},\r\n              {\r\n                maxTokens: 4000\r\n              }\r\n            );\r\n            \r\n            res.writeHead(200, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify(result));\r\n          } catch (error) {\r\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\n        });\r\n      } catch (error) {\r\n        logger.error('Request processing failed', { error: (error as Error).message });\r\n        res.writeHead(500, { 'Content-Type': 'application/json' });\r\n        res.end(JSON.stringify({ \r\n          error: 'Internal server error', \r\n          message: (error as Error).message \r\n        }));\r\n      }\r\n      return;\r\n    }\r\n    \r\n    // Default response\r\n    res.writeHead(404, { 'Content-Type': 'application/json' });\r\n    res.end(JSON.stringify({ \r\n      error: 'Not found',\r\n      message: 'Use POST /enhance to enhance prompts or GET /health for status'\r\n    }));\r\n  });\r\n  \r\n  server.listen(PORT, () => {\r\n    logger.info(`ðŸš€ PromptMCP HTTP Server running on port ${PORT}`);\r\n    logger.info('ðŸ“ Ready to enhance prompts with perfect context!');\r\n    logger.info(`ðŸ”— Health check: http://localhost:${PORT}/health`);\r\n    logger.info(`ðŸ”— Enhance endpoint: POST http://localhost:${PORT}/enhance`);\r\n  });\r\n  \r\n  server.on('error', (error) => {\r\n    logger.error('Server error', { error: error.message });\r\n    process.exit(1);\r\n  });\r\n}\r\n\r\nstartHttpServer().catch((error) => {\r\n  logger.error('Failed to start server', { error: error.message });\r\n  process.exit(1);\r\n});\r\n\ntry {\nswitch (name) {\ncase 'promptmcp.enhance':\nif (!args || typeof args.prompt !== 'string') {\nthrow new Error('Invalid arguments: prompt is required and must be a string');\n}\n\nconst result = await this.enhanceTool.enhance({\nprompt: args.prompt,\ncontext: args.context || {},\noptions: {\nmaxTokens: 4000,\nincludeMetadata: true\n}\n});\nreturn {\ncontent: [\n{\ntype: 'text',\ntext: JSON.stringify(result, null, 2)\n}\n]\n};\n\ndefault:\nthrow new Error(`Unknown tool: ${name}`);\n}\n} catch (error) {\n        this.logger.error('Tool execution failed', { \r\n          tool: name, \r\n          error: (error as Error).message \r\n        });\r\n        throw error;\r\n      }\r\ntry {\nconst server = new PromptMCPServer();\nawait server.start();\n\nconsole.log(`ðŸš€ PromptMCP Server running on port ${PORT}`);\nconsole.log('ðŸ“ Ready to enhance prompts with perfect context!');\n} catch (error) {\n    console.error('âŒ Failed to start PromptMCP server:', error);\r\n    process.exit(1);\r\n  }\r\ntry {\nlogger.info('Initializing Context7 integration...');\nawait context7Integration.initialize();\nlogger.info('Context7 integration initialized successfully');\n} catch (error) {\n    logger.error('Failed to initialize Context7 integration', {\r\n      error: error instanceof Error ? error.message : 'Unknown error'\r\n    });\r\n    // Continue without Context7 - graceful degradation\r\n  }\r\ntry {\nconst request = JSON.parse(body);\nconst result = await context7Integration.enhancePrompt(\nrequest.prompt,\nrequest.context || {},\n{\nmaxTokens: 4000\n}\n);\n\nres.writeHead(200, { 'Content-Type': 'application/json' });\nres.end(JSON.stringify(result));\n} catch (error) {\n            logger.error('Enhancement failed', { error: (error as Error).message });\r\n            res.writeHead(400, { 'Content-Type': 'application/json' });\r\n            res.end(JSON.stringify({ \r\n              error: 'Enhancement failed', \r\n              message: (error as Error).message \r\n            }));\r\n          }\r\ntry {\nthis.logger.info('Initializing enhanced Context7 integration...');\n// The enhanced tool initializes its own services\nthis.logger.info('Enhanced Context7 integration initialized successfully');\n} catch (error) {\n      this.logger.error('Failed to initialize enhanced Context7 integration', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      // Continue without Context7 - graceful degradation\r\n    }\r\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      expect(analyzer).toBeDefined();\r\n    });\r\n\r\n    it('should analyze project structure', async () => {\r\n      const analyzer = new ProjectAnalyzer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('{\"name\": \"test-project\"}'),\r\n        readdir: vi.fn().mockResolvedValue([\r\n          { name: 'src', isDirectory: () => true },\r\n          { name: 'package.json', isDirectory: () => false }\r\n        ]),\r\n        stat: vi.fn().mockResolvedValue({ isFile: () => true })\r\n      }));\r\n\r\n      const result = await analyzer.analyze('.');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.projectOverview).toBeDefined();\r\n      expect(result.dependencies).toBeDefined();\r\n      expect(result.configurations).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('CodeGenerator', () => {\r\n    it('should create generator instance', () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      expect(generator).toBeDefined();\r\n    });\r\n\r\n    it('should generate code based on description', async () => {\r\n      const generator = new CodeGenerator(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await generator.create('dark theme Hello World');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.createdFiles).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.nextSteps).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('ErrorFixer', () => {\r\n    it('should create fixer instance', () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      expect(fixer).toBeDefined();\r\n    });\r\n\r\n    it('should diagnose and fix errors', async () => {\r\n      const fixer = new ErrorFixer(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        readFile: vi.fn().mockResolvedValue('function test() { return \"hello\"; }'),\r\n        writeFile: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await fixer.fix('TypeScript error: missing return type');\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.appliedFixes).toBeDefined();\r\n      expect(result.explanation).toBeDefined();\r\n      expect(result.validationResult).toBeDefined();\r\n    });\r\n  });\r\n\r\n  describe('LessonLearner', () => {\r\n    it('should create learner instance', () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      expect(learner).toBeDefined();\r\n    });\r\n\r\n    it('should learn from feedback and context', async () => {\r\n      const learner = new LessonLearner(logger, config);\r\n      \r\n      // Mock file system operations\r\n      vi.mock('fs/promises', () => ({\r\n        writeFile: vi.fn().mockResolvedValue(undefined),\r\n        mkdir: vi.fn().mockResolvedValue(undefined)\r\n      }));\r\n\r\n      const result = await learner.learn(\r\n        'This solution works perfectly!',\r\n        'function hello() { return \"world\"; }',\r\n        ['javascript', 'function']\r\n      );\r\n      \r\n      expect(result).toBeDefined();\r\n      expect(result.confirmation).toBeDefined();\r\n      expect(result.lessonId).toBeDefined();\r\n      expect(result.impact).toBeDefined();\r\n    });\r\n  });\r\n});\r\n\n```\n\n## Instructions:\nMake your response consistent with the project's existing patterns, best practices, and coding standards. Use the provided context to ensure your solution fits well with the existing codebase.",
      "originalTokens": 17,
      "enhancedTokens": 4954,
      "tokenRatio": 291.4117647058824,
      "responseTime": 63,
      "context7Used": true,
      "context7LibrariesResolved": 1,
      "context7Libraries": [
        "/microsoft/typescript"
      ],
      "tokenEfficiencyScore": 80,
      "frameworkAccuracyScore": 100,
      "context7RelevanceScore": 100,
      "overEngineeringScore": 0,
      "overallScore": 95,
      "assessment": "EXCELLENT",
      "status": "COMPLETED"
    }
  ],
  "summary": {
    "totalTests": 5,
    "completedTests": 5,
    "failedTests": 0,
    "averageTokenRatio": 846.787330316742,
    "averageResponseTime": 60.2,
    "averageOverallScore": 52.8,
    "overEngineeredTests": 2,
    "overEngineeringRate": 40,
    "context7UsageRate": 100,
    "averageContext7Libraries": 1
  },
  "context7Metrics": {
    "usageRate": 100,
    "averageLibrariesResolved": 1,
    "averageRelevanceScore": 40.6,
    "correctLibrarySelections": 1,
    "correctSelectionRate": 20
  },
  "improvements": {},
  "criticalIssues": [
    {
      "category": "Token Efficiency",
      "severity": "CRITICAL",
      "issue": "Average token ratio is too high",
      "current": "846.79x",
      "target": "<5.0x"
    },
    {
      "category": "Context7 Accuracy",
      "severity": "HIGH",
      "issue": "Context7 library selection accuracy is too low",
      "current": "20.0%",
      "target": ">90%"
    }
  ]
}