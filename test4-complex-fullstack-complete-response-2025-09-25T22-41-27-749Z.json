{
  "testCase": {
    "id": "complex-fullstack",
    "name": "Complex Full-Stack Task",
    "prompt": "Build a full-stack application with user authentication, real-time chat, and file upload using Next.js, TypeScript, and PostgreSQL",
    "expectedFrameworks": [
      "nextjs",
      "typescript"
    ],
    "expectedContext7Libraries": [
      "/vercel/next.js",
      "/microsoft/typescript"
    ],
    "qualityCriteria": {
      "shouldIncludeArchitecture": true,
      "shouldIncludeSecurity": true,
      "shouldIncludeDatabasePatterns": true,
      "shouldIncludeRealTimePatterns": true,
      "shouldIncludeFileUploadPatterns": true,
      "shouldBeScalable": true,
      "maxTokens": 3000,
      "maxResponseTime": 1000
    }
  },
  "completeResponse": {
    "enhanced_prompt": "Build a full-stack application with user authentication, real-time chat, and file upload using Next.js, TypeScript, and PostgreSQL\n\n## Quality Requirements\n\n1. **type-safety** 🟠 (high priority)\n   - TypeScript type safety and strict typing\n2. **testing** 🟡 (medium priority)\n   - Comprehensive test coverage and quality\n3. **performance** 🟡 (medium priority)\n   - Build optimization and performance\n4. **responsive** 🟡 (medium priority)\n   - Mobile-first responsive design\n5. **security** 🟠 (high priority)\n   - Security best practices and input validation\n\n\n## Framework Best Practices:\n## /websites/react_dev Documentation:\n================\nCODE SNIPPETS\n================\nTITLE: Initialize Application-Wide Logic Outside React Components\nDESCRIPTION: This code snippet demonstrates how to run essential application initialization logic, such as checking authentication tokens or loading data from local storage, only once when the application starts. By placing this code outside any React component and verifying the `window` object's existence, it ensures execution only in the browser environment and independently of component lifecycles.\n\nSOURCE: https://react.dev/learn/synchronizing-with-effects\n\nLANGUAGE: javascript\nCODE:\n```\nif (typeof window !== 'undefined') { // Check if we're running in the browser.  \n  checkAuthToken();  \n  loadDataFromLocalStorage();  \n}  \n  \nfunction App() {  \n  // ...  \n}\n```\n\n--------------------------------\n\nTITLE: Avoid: Running initialization logic in React useEffect (development double-run)\nDESCRIPTION: This snippet demonstrates an anti-pattern where application-wide initialization logic is placed in a `useEffect` hook in the top-level `App` component. In development mode, React's Strict Mode will cause this `useEffect` to run twice, potentially leading to issues like invalidating authentication tokens or duplicate data loading.\n\nSOURCE: https://react.dev/learn/you-might-not-need-an-effect\n\nLANGUAGE: javascript\nCODE:\n```\nfunction App() {  \n  // 🔴 Avoid: Effects with logic that should only ever run once  \n  useEffect(() => {  \n    loadDataFromLocalStorage();  \n    checkAuthToken();  \n  }, []);  \n  // ...  \n}\n```\n\n--------------------------------\n\nTITLE: React Component Using useId for Unique Accessibility IDs\nDESCRIPTION: This React functional component, `PasswordField`, imports `useId` and calls it to generate a unique ID. This ID is then used for the `aria-describedby` attribute of an input and the `id` attribute of a paragraph, ensuring accessibility attributes are correctly linked without ID conflicts.\n\nSOURCE: https://react.dev/reference/react/useId\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useId } from 'react';\n\nfunction PasswordField() {\n  const passwordHintId = useId();\n  return (\n    <>\n      <label>\n        Password:\n        <input\n          type=\"password\"\n          aria-describedby={passwordHintId}\n        />\n      </label>\n      <p id={passwordHintId}>\n        The password should contain at least 18 characters\n      </p>\n    </>\n  );\n}\n```\n\n--------------------------------\n\nTITLE: Secure API calls with `server-only` to prevent client exposure (React)\nDESCRIPTION: This example demonstrates a secure pattern for handling sensitive API credentials using the `server-only` package. It ensures that the `fetchAPI` helper, which accesses `process.env.API_PASSWORD`, can only be imported and executed on the server, preventing accidental exposure to client components.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nimport \"server-only\";\n\nexport function fetchAPI(url) {\n  const headers = { Authorization: process.env.\n\n## Repository Context:\nProject name: promptmcp\nProject description: A focused MCP server for intelligent prompt enhancement with dynamic framework detection, Context7 integration, comprehensive testing suite, and organized test artifacts management\nUses Playwright framework (^1.55.0)\nUses TypeScript framework (^5.0.0)\nUses Vitest framework (^1.0.0)\nProject type: Frontend application\nHas testing setup\nHas build process\nSource directories: src\nConfiguration files: tsconfig.json\nUses TypeScript for type safety\nUses Node.js/Express for backend\nUses testing with 297 test files\nUses Model Context Protocol (MCP) for AI integration\nUses service-oriented architecture with 153 service files\nUses tool-based architecture with 39 tool files\n\n## Existing Code Patterns:\n```typescript\nBe specific and avoid generic suggestions`\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: analysisPrompt\r\n        }\r\n      ], {\r\n        maxTokens: 300,\r\n        temperature: 0.3\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) {\r\n        throw new Error('No response content from AI');\r\n      }\r\n\r\n      const aiMatches = this.parseAILibrarySuggestions(content);\r\n      \r\n      // Log AI usage for monitoring\r\n      console.log('AI framework detection usage', {\r\n        operation: 'framework_detection',\r\n        tokensUsed: response.usage?.total_tokens || 0,\r\n        cost: this.estimateAICost(response.usage?.total_tokens || 0),\r\n        librariesSuggested: aiMatches.length\r\n      });\r\n      \r\n      return aiMatches;\r\n    } catch (error) {\r\n      console.warn('AI library suggestion failed', { error });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enhanced prompt-based framework inference using multiple strategies\r\n   * Replaces simple pattern matching with intelligent analysis\r\n   */\r\n  private async inferFrameworksFromPrompt(prompt: string): Promise<LibraryMatch[]> {\r\n    const matches: LibraryMatch[] = [];\r\n    \r\n    // 1. Direct framework mentions\r\n    const directMentions = this.extractDirectFrameworkMentions(prompt);\r\n    matches.push(...directMentions);\r\n    \r\n    // 2. Task-based inference\r\n    const taskInferences = this.inferFromTaskType(prompt);\r\n    matches.push(...taskInferences);\r\n    \r\n    // 3. Technology stack inference\r\n    const stackInferences = this.inferFromTechnologyStack(prompt);\r\n    matches.push(...stackInferences);\r\n    \r\n    // 4. Context-based inference\r\n    const contextInferences = this.inferFromContext(prompt);\r\n    matches.push(...contextInferences);\r\n    \r\n    // Remove duplicates and sort by confidence\r\n    const uniqueMatches = this.deduplicateMatches(matches);\r\n    return uniqueMatches.sort((a, b) => b.confidence - a.confidence);\r\n  }\r\n\r\n  /**\r\n   * Extract frameworks directly mentioned in the prompt\r\n   */\r\n  private extractDirectFrameworkMentions(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    const promptLower = prompt.\n```\n\n## Instructions:\nMake your response consistent with the project's existing patterns, best practices, and coding standards. Use the provided context to ensure your solution fits well with the existing codebase.",
    "context_used": {
      "repo_facts": [
        "Project name: promptmcp",
        "Project description: A focused MCP server for intelligent prompt enhancement with dynamic framework detection, Context7 integration, comprehensive testing suite, and organized test artifacts management",
        "Uses Playwright framework (^1.55.0)",
        "Uses TypeScript framework (^5.0.0)",
        "Uses Vitest framework (^1.0.0)",
        "Project type: Frontend application",
        "Has testing setup",
        "Has build process",
        "Source directories: src",
        "Configuration files: tsconfig.json",
        "Uses TypeScript for type safety",
        "Uses Node.js/Express for backend",
        "Uses testing with 297 test files",
        "Uses Model Context Protocol (MCP) for AI integration",
        "Uses service-oriented architecture with 153 service files",
        "Uses tool-based architecture with 39 tool files"
      ],
      "code_snippets": [
        "File: src/services/ai/prompt-enhancement-prompts.ts\nDescription: Class definition: PromptEnhancementPrompts\nCode:\nexport class PromptEnhancementPrompts {\r\n  \r\n  /**\r\n   * Primary enhancement agent prompt for general enhancement\r\n   */\r\n  static getPrimaryEnhancementPrompt(): string {\r\n    return `You are an expert prompt enhancement agent specialized in improving developer prompts for maximum clarity, actionability, and technical accuracy.\r\n\r\n## Core Capabilities\r\n- Transform vague requests into specific, actionable prompts\r\n- Integrate framework-specific best practices and patterns\r\n- Apply quality requirements (accessibility, performance, security, testing)\r\n- Enhance prompts with project-aware context and conventions\r\n- Provide clear, step-by-step guidance for implementation\r\n\r\n## Enhancement Strategies\r\n1. **Clarity Enhancement**: Make vague requests specific and unambiguous\r\n2. **Context Integration**: Seamlessly weave in relevant project and framework context\r\n3. **Best Practice Application**: Include industry standards and framework conventions\r\n4. **Quality Focus**: Apply specific quality requirements (a11y, perf, security, testing)\r\n5. **Actionability**: Ensure every enhanced prompt leads to concrete implementation steps\r\n\r\n## Output Format\r\nReturn a JSON object with this exact structure:\r\n{\r\n  \"enhancedPrompt\": \"The improved, specific, and actionable prompt\",\r\n  \"improvements\": [\r\n    {\r\n      \"type\": \"clarity|specificity|actionability|completeness|relevance|best-practice|performance|security\",\r\n      \"description\": \"What was improved\",\r\n      \"impact\": \"low|medium|high\",\r\n      \"before\": \"Original text\",\r\n      \"after\": \"Enhanced text\"\r\n    }\r\n  ],\r\n  \"recommendations\": [\r\n    \"Additional suggestions for the user\",\r\n    \"Best practices to consider\",\r\n    \"Potential pitfalls to avoid\"\r\n  ],\r\n  \"qualityScore\": 0.85,\r\n  \"confidenceScore\": 0.92\r\n}\r\n\r\n## Quality Standards\r\n- Enhanced prompts must be specific and actionable\r\n- Include relevant technical details and context\r\n- Apply appropriate best practices and patterns\r\n- Ensure clarity and eliminate ambiguity\r\n- Provide clear implementation guidance\r\n- Consider quality requirements (accessibility, performance, security, testing)\r\n\r\n## Guidelines\r\n- Preserve the user's original intent while making it more specific\r\n- Use technical terminology appropriate to the framework and project\r\n- Include concrete examples when helpful\r\n- Reference specific patterns, conventions, and best practices\r\n- Ensure the enhanced prompt leads to implementable code\r\n- Consider the user's experience level and project context`;\r\n  }\r\n\r\n  /**\r\n   * Framework-specific enhancement prompts\r\n   */\r\n  static getFrameworkSpecificPrompt(framework: string, version: string): string {\r\n    const frameworkPrompts: Record<string, string> = {\r\n      'react': `You are a React expert specializing in prompt enhancement for React applications.\r\n\r\n## React-Specific Enhancements\r\n- Component architecture and patterns (functional components, hooks, context)\r\n- State management (useState, useReducer, Context API, Redux, Zustand)\r\n- Performance optimization (memo, useMemo, useCallback, lazy loading)\r\n- Testing approaches (Jest, React Testing Library, Cypress)\r\n- Accessibility (ARIA attributes, semantic HTML, keyboard navigation)\r\n- Modern React patterns (Server Components, Suspense, Concurrent Features)\r\n\r\n## React Best Practices\r\n- Use functional components with hooks\r\n- Implement proper error boundaries\r\n- Follow component composition patterns\r\n- Use TypeScript for type safety\r\n- Implement proper prop validation\r\n- Follow React naming conventions\r\n- Use proper key props for lists\r\n- Implement proper cleanup in useEffect\r\n\r\n## Common React Patterns\r\n- Custom hooks for reusable logic\r\n- Higher-order components for cross-cutting concerns\r\n- Render props for component composition\r\n- Compound components for complex UI\r\n- Provider pattern for global state\r\n- Container/Presentational component pattern`,\r\n\r\n      'vue': `You are a Vue.js expert specializing in prompt enhancement for Vue applications.\r\n\r\n## Vue-Specific Enhancements\r\n- Composition API and Options API patterns\r\n- Reactive data management (ref, reactive, computed, watch)\r\n- Component lifecycle and composition\r\n- State management (Pinia, Vuex)\r\n- Performance optimization (v-memo, keep-alive, lazy loading)\r\n- Testing approaches (Vitest, Vue Test Utils, Cypress)\r\n- Accessibility (ARIA attributes, semantic HTML, focus management)\r\n\r\n## Vue Best Practices\r\n- Use Composition API for new projects\r\n- Implement proper component structure\r\n- Use TypeScript for type safety\r\n- Follow Vue naming conventions\r\n- Use proper key attributes for v-for\r\n- Implement proper error handling\r\n- Use provide/inject for dependency injection\r\n- Follow single-file component structure\r\n\r\n## Common Vue Patterns\r\n- Composables for reusable logic\r\n- Provide/inject for dependency injection\r\n- Teleport for portal-like functionality\r\n- Suspense for async components\r\n- Keep-alive for component caching\r\n- Custom directives for DOM manipulation`,\r\n\r\n      'angular': `You are an Angular expert specializing in prompt enhancement for Angular applications.\r\n\r\n## Angular-Specific Enhancements\r\n- Component architecture and lifecycle\r\n- Dependency injection and services\r\n- Reactive forms and template-driven forms\r\n- RxJS observables and operators\r\n- Routing and navigation\r\n- State management (NgRx, Akita)\r\n- Testing approaches (Jasmine, Karma, Protractor)\r\n- Accessibility (Angular CDK, ARIA attributes)\r\n\r\n## Angular Best Practices\r\n- Use Angular CLI for project generation\r\n- Follow Angular style guide conventions\r\n- Implement proper component architecture\r\n- Use TypeScript for type safety\r\n- Implement proper error handling\r\n- Use reactive forms for complex forms\r\n- Follow Angular naming conventions\r\n- Use Angular CDK for accessibility\r\n\r\n## Common Angular Patterns\r\n- Services for business logic\r\n- Guards for route protection\r\n- Interceptors for HTTP requests\r\n- Pipes for data transformation\r\n- Directives for DOM manipulation\r\n- Resolvers for data preloading\r\n- Modules for feature organization`,\r\n\r\n      'html-css': `You are a frontend expert specializing in prompt enhancement for HTML/CSS development.\r\n\r\n## HTML/CSS-Specific Enhancements\r\n- Semantic HTML structure and accessibility\r\n- CSS methodologies (BEM, OOCSS, SMACSS)\r\n- Responsive design and mobile-first approach\r\n- CSS Grid and Flexbox layouts\r\n- CSS custom properties and variables\r\n- Performance optimization (critical CSS, lazy loading)\r\n- Cross-browser compatibility\r\n- Modern CSS features (container queries, subgrid, etc.)\r\n\r\n## HTML/CSS Best Practices\r\n- Use semantic HTML elements\r\n- Implement proper accessibility attributes\r\n- Follow mobile-first responsive design\r\n- Use CSS custom properties for theming\r\n- Implement proper CSS organization\r\n- Use modern CSS features with fallbacks\r\n- Optimize for performance\r\n- Follow naming conventions (BEM, etc.)\r\n\r\n## Common HTML/CSS Patterns\r\n- CSS Grid for complex layouts\r\n- Flexbox for component layouts\r\n- CSS custom properties for theming\r\n- CSS modules for component styling\r\n- PostCSS for CSS processing\r\n- CSS-in-JS for dynamic styling\r\n- Utility-first CSS frameworks\r\n- Component-based CSS architecture`,\r\n\r\n      'nodejs': `You are a Node.js expert specializing in prompt enhancement for backend development.\r\n\r\n## Node.js-Specific Enhancements\r\n- Express.js and Fastify frameworks\r\n- Middleware patterns and error handling\r\n- Database integration (MongoDB, PostgreSQL, MySQL)\r\n- Authentication and authorization (JWT, OAuth, Passport)\r\n- API design and RESTful principles\r\n- Testing approaches (Jest, Mocha, Supertest)\r\n- Performance optimization and monitoring\r\n- Security best practices\r\n\r\n## Node.js Best Practices\r\n- Use TypeScript for type safety\r\n- Implement proper error handling\r\n- Use environment variables for configuration\r\n- Implement proper logging and monitoring\r\n- Use dependency injection\r\n- Follow RESTful API design\r\n- Implement proper validation\r\n- Use proper security measures\r\n\r\n## Common Node.js Patterns\r\n- MVC architecture\r\n- Repository pattern for data access\r\n- Service layer for business logic\r\n- Middleware for cross-cutting concerns\r\n- Factory pattern for object creation\r\n- Observer pattern for events\r\n- Strategy pattern for algorithms\r\n- Decorator pattern for functionality extension`\r\n    };\r\n\r\n    return frameworkPrompts[framework.toLowerCase()] || this.getPrimaryEnhancementPrompt();\r\n  }\r\n\r\n  /**\r\n   * Quality-focused enhancement prompts\r\n   */\r\n  static getQualityFocusedPrompt(qualityType: string): string {\r\n    const qualityPrompts: Record<string, string> = {\r\n      'accessibility': `You are an accessibility expert specializing in prompt enhancement for inclusive web development.\r\n\r\n## Accessibility Enhancements\r\n- WCAG 2.1 AA compliance requirements\r\n- Semantic HTML structure and ARIA attributes\r\n- Keyboard navigation and focus management\r\n- Screen reader compatibility\r\n- Color contrast and visual accessibility\r\n- Alternative text and media descriptions\r\n- Form accessibility and validation\r\n- Mobile accessibility considerations\r\n\r\n## Accessibility Best Practices\r\n- Use semantic HTML elements\r\n- Implement proper ARIA attributes\r\n- Ensure keyboard accessibility\r\n- Provide alternative text for images\r\n- Use proper color contrast ratios\r\n- Implement focus management\r\n- Provide clear error messages\r\n- Test with screen readers\r\n\r\n## Common Accessibility Patterns\r\n- Skip links for navigation\r\n- Focus indicators for keyboard users\r\n- ARIA landmarks for page structure\r\n- Live regions for dynamic content\r\n- Form labels and error associations\r\n- Modal dialog accessibility\r\n- Tab order management\r\n- Screen reader announcements`,\r\n\r\n      'performance': `You are a performance expert specializing in prompt enhancement for high-performance web applications.\r\n\r\n## Performance Enhancements\r\n- Core Web Vitals optimization (LCP, FID, CLS)\r\n- Bundle size optimization and code splitting\r\n- Image optimization and lazy loading\r\n- Caching strategies and CDN usage\r\n- Database query optimization\r\n- API response optimization\r\n- Memory management and garbage collection\r\n- Network optimization and compression\r\n\r\n## Performance Best Practices\r\n- Implement code splitting and lazy loading\r\n- Optimize images and media assets\r\n- Use efficient data structures and algorithms\r\n- Implement proper caching strategies\r\n- Minimize bundle size\r\n- Use performance monitoring\r\n- Optimize critical rendering path\r\n- Implement progressive enhancement\r\n\r\n## Common Performance Patterns\r\n- Lazy loading for images and components\r\n- Virtual scrolling for large lists\r\n- Debouncing and throttling for user input\r\n- Memoization for expensive calculations\r\n- Service workers for caching\r\n- Web Workers for heavy computations\r\n- Intersection Observer for visibility\r\n- Request deduplication and batching`,\r\n\r\n      'security': `You are a security expert specializing in prompt enhancement for secure web applications.\r\n\r\n## Security Enhancements\r\n- Input validation and sanitization\r\n- Authentication and authorization\r\n- CSRF and XSS protection\r\n- SQL injection prevention\r\n- Secure data transmission (HTTPS, TLS)\r\n- Content Security Policy (CSP)\r\n- Secure session management\r\n- Data privacy and GDPR compliance\r\n\r\n## Security Best Practices\r\n- Validate and sanitize all inputs\r\n- Implement proper authentication\r\n- Use HTTPS for all communications\r\n- Implement proper authorization\r\n- Use secure session management\r\n- Implement proper error handling\r\n- Keep dependencies updated\r\n- Use security headers\r\n\r\n## Common Security Patterns\r\n- Input validation and sanitization\r\n- Authentication middleware\r\n- Authorization checks\r\n- CSRF token validation\r\n- XSS protection\r\n- SQL injection prevention\r\n- Rate limiting and throttling\r\n- Security headers implementation`,\r\n\r\n      'testing': `You are a testing expert specializing in prompt enhancement for comprehensive test coverage.\r\n\r\n## Testing Enhancements\r\n- Unit testing strategies and patterns\r\n- Integration testing approaches\r\n- End-to-end testing implementation\r\n- Test-driven development (TDD)\r\n- Behavior-driven development (BDD)\r\n- Mocking and stubbing techniques\r\n- Test coverage and quality metrics\r\n- Continuous integration testing\r\n\r\n## Testing Best Practices\r\n- Write tests before implementation (TDD)\r\n- Use descriptive test names\r\n- Follow AAA pattern (Arrange, Act, Assert)\r\n- Mock external dependencies\r\n- Test edge cases and error scenarios\r\n- Maintain high test coverage\r\n- Use proper test organization\r\n- Implement continuous testing\r\n\r\n## Common Testing Patterns\r\n- Test doubles (mocks, stubs, fakes)\r\n- Test fixtures and factories\r\n- Page object model for E2E tests\r\n- Test data builders\r\n- Parameterized tests\r\n- Test hooks and setup/teardown\r\n- Test isolation and independence\r\n- Test reporting and coverage`\r\n    };\r\n\r\n    return qualityPrompts[qualityType.toLowerCase()] || this.getPrimaryEnhancementPrompt();\r\n  }\r\n\r\n  /**\r\n   * Project-aware enhancement prompts\r\n   */\r\n  static getProjectAwarePrompt(projectType: string): string {\r\n    const projectPrompts: Record<string, string> = {\r\n      'frontend': `You are a frontend expert specializing in prompt enhancement for frontend applications.\r\n\r\n## Frontend-Specific Enhancements\r\n- User interface and user experience design\r\n- Component architecture and state management\r\n- Responsive design and mobile optimization\r\n- Performance optimization and Core Web Vitals\r\n- Accessibility and inclusive design\r\n- Browser compatibility and progressive enhancement\r\n- Build tools and development workflow\r\n- Testing strategies for frontend code\r\n\r\n## Frontend Best Practices\r\n- Follow mobile-first responsive design\r\n- Implement proper component architecture\r\n- Use modern CSS and JavaScript features\r\n- Optimize for performance and accessibility\r\n- Implement proper error handling\r\n- Use proper testing strategies\r\n- Follow coding standards and conventions\r\n- Implement proper build and deployment processes\r\n\r\n## Common Frontend Patterns\r\n- Component composition and reusability\r\n- State management patterns\r\n- Event handling and user interaction\r\n- Data fetching and caching\r\n- Form handling and validation\r\n- Routing and navigation\r\n- Theming and customization\r\n- Internationalization and localization`,\r\n\r\n      'backend': `You are a backend expert specializing in prompt enhancement for backend services and APIs.\r\n\r\n## Backend-Specific Enhancements\r\n- API design and RESTful principles\r\n- Database design and optimization\r\n- Authentication and authorization\r\n- Security and data protection\r\n- Performance and scalability\r\n- Error handling and logging\r\n- Testing strategies for backend code\r\n- Deployment and infrastructure\r\n\r\n## Backend Best Practices\r\n- Follow RESTful API design principles\r\n- Implement proper error handling\r\n- Use proper authentication and authorization\r\n- Implement proper logging and monitoring\r\n- Use proper database design\r\n- Implement proper security measures\r\n- Use proper testing strategies\r\n- Follow coding standards and conventions\r\n\r\n## Common Backend Patterns\r\n- MVC architecture and separation of concerns\r\n- Repository pattern for data access\r\n- Service layer for business logic\r\n- Middleware for cross-cutting concerns\r\n- Factory pattern for object creation\r\n- Observer pattern for events\r\n- Strategy pattern for algorithms\r\n- Decorator pattern for functionality extension`,\r\n\r\n      'fullstack': `You are a full-stack expert specializing in prompt enhancement for full-stack applications.\r\n\r\n## Full-Stack Enhancements\r\n- End-to-end application architecture\r\n- Frontend-backend integration\r\n- API design and consumption\r\n- Database design and optimization\r\n- Authentication and authorization flow\r\n- Performance optimization across the stack\r\n- Security considerations for both frontend and backend\r\n- Testing strategies for full-stack applications\r\n\r\n## Full-Stack Best Practices\r\n- Design APIs with frontend consumption in mind\r\n- Implement proper error handling across the stack\r\n- Use consistent coding standards\r\n- Implement proper security measures\r\n- Use proper testing strategies\r\n- Follow proper deployment practices\r\n- Implement proper monitoring and logging\r\n- Use proper version control and CI/CD\r\n\r\n## Common Full-Stack Patterns\r\n- API-first development approach\r\n- Microservices architecture\r\n- Event-driven architecture\r\n- CQRS (Command Query Responsibility Segregation)\r\n- Event sourcing\r\n- Domain-driven design\r\n- Hexagonal architecture\r\n- Clean architecture principles`,\r\n\r\n      'library': `You are a library expert specializing in prompt enhancement for reusable libraries and packages.\r\n\r\n## Library-Specific Enhancements\r\n- API design and developer experience\r\n- Documentation and examples\r\n- TypeScript support and type safety\r\n- Testing strategies for libraries\r\n- Versioning and backward compatibility\r\n- Performance optimization\r\n- Bundle size optimization\r\n- Distribution and publishing\r\n\r\n## Library Best Practices\r\n- Design clean and intuitive APIs\r\n- Provide comprehensive documentation\r\n- Use TypeScript for type safety\r\n- Implement proper testing strategies\r\n- Follow semantic versioning\r\n- Optimize for bundle size\r\n- Provide clear migration guides\r\n- Use proper build and distribution tools\r\n\r\n## Common Library Patterns\r\n- Plugin architecture and extensibility\r\n- Configuration and customization\r\n- Event system and callbacks\r\n- Factory pattern for object creation\r\n- Builder pattern for complex objects\r\n- Observer pattern for events\r\n- Strategy pattern for algorithms\r\n- Decorator pattern for functionality extension`\r\n    };\r\n\r\n    return projectPrompts[projectType.toLowerCase()] || this.getPrimaryEnhancementPrompt();\r\n  }\r\n\r\n  /**\r\n   * Select the appropriate enhancement prompt based on strategy\r\n   */\r\n  static selectEnhancementPrompt(\r\n    strategy: EnhancementStrategy,\r\n    projectContext?: ProjectContext,\r\n    frameworkContext?: FrameworkContext,\r\n    qualityRequirements?: QualityRequirements\r\n  ): string {\r\n    // Framework-specific enhancement\r\n    if (strategy.type === 'framework-specific' && frameworkContext) {\r\n      return this.getFrameworkSpecificPrompt(frameworkContext.framework, frameworkContext.version);\r\n    }\r\n\r\n    // Quality-focused enhancement\r\n    if (strategy.type === 'quality-focused' && qualityRequirements) {\r\n      const qualityTypes = Object.entries(qualityRequirements)\r\n        .filter(([_, enabled]) => enabled)\r\n        .map(([type, _]) => type);\r\n      \r\n      if (qualityTypes.length > 0) {\r\n        return this.getQualityFocusedPrompt(qualityTypes[0]);\r\n      }\r\n    }\r\n\r\n    // Project-aware enhancement\r\n    if (strategy.type === 'project-aware' && projectContext) {\r\n      return this.getProjectAwarePrompt(projectContext.projectType);\r\n    }\r\n\r\n    // Default to primary enhancement prompt\r\n    return this.getPrimaryEnhancementPrompt();\r\n  }\r\n\r\n  /**\r\n   * Get enhancement prompt with context integration\r\n   */\r\n  static getContextualEnhancementPrompt(\r\n    originalPrompt: string,\r\n    context: any,\r\n    strategy: EnhancementStrategy\r\n  ): string {\r\n    const basePrompt = this.selectEnhancementPrompt(strategy, context.projectContext, context.frameworkContext, context.qualityRequirements);\r\n    \r\n    return `${basePrompt}\r\n\r\n## Current Context\r\n- Project Type: ${context.projectContext?.projectType || 'Unknown'}\r\n- Framework: ${context.frameworkContext?.framework || 'Unknown'}\r\n- Language: ${context.projectContext?.language || 'Unknown'}\r\n- Quality Requirements: ${JSON.stringify(context.qualityRequirements || {})}\r\n\r\n## Original Prompt\r\n\"${originalPrompt}\"\r\n\r\n## Enhancement Task\r\nEnhance the above prompt using the provided context and strategy. Make it more specific, actionable, and aligned with best practices for the given framework and project type.`;\r\n  }\r\n}\r",
        "File: src/services/task-breakdown/task-breakdown.service.ts\nDescription: Class definition: TaskBreakdownService\nCode:\nexport class TaskBreakdownService {\r\n  private logger: Logger;\r\n  private context7Service: any; // Using simple client now\r\n  private openaiService: OpenAIService;\r\n  private config: TaskBreakdownConfig;\r\n\r\n  constructor(\r\n    logger: Logger,\r\n    context7Service: any,\r\n    config: TaskBreakdownConfig\r\n  ) {\r\n    this.logger = logger;\r\n    this.context7Service = context7Service;\r\n    this.config = config;\r\n    this.openaiService = new OpenAIService(logger, config.openai);\r\n  }\r\n\r\n  /**\r\n   * Break down a user prompt into structured tasks using Context7 + OpenAI\r\n   */\r\n  async breakdownPrompt(prompt: string, projectId: string): Promise<TaskBreakdown> {\r\n    try {\r\n      this.logger.info('Starting task breakdown', { \r\n        prompt: prompt.substring(0, 100) + '...',\r\n        projectId \r\n      });\r\n\r\n      // 1. Detect frameworks from prompt\r\n      const frameworks = this.detectFrameworks(prompt);\r\n      this.logger.debug('Detected frameworks', { frameworks });\r\n\r\n      // 2. Get Context7 documentation for frameworks\r\n      const contextDocs = await this.getContext7Documentation(frameworks);\r\n      this.logger.debug('Retrieved Context7 documentation', { \r\n        docLength: contextDocs.length,\r\n        frameworks \r\n      });\r\n\r\n      // 3. Call OpenAI for breakdown with context\r\n      const breakdown = await this.openaiService.breakdownPrompt(prompt, contextDocs);\r\n      \r\n      // 4. Validate and enhance breakdown\r\n      const validatedBreakdown = this.validateBreakdown(breakdown);\r\n      \r\n      this.logger.info('Task breakdown completed successfully', {\r\n        projectId,\r\n        mainTasks: validatedBreakdown.mainTasks.length,\r\n        subtasks: validatedBreakdown.subtasks.length,\r\n        dependencies: validatedBreakdown.dependencies.length\r\n      });\r\n\r\n      return validatedBreakdown;\r\n\r\n    } catch (error) {\r\n      this.logger.error('Task breakdown failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        prompt: prompt.substring(0, 100) + '...',\r\n        projectId\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Detect frameworks from the user prompt\r\n   */\r\n  private detectFrameworks(prompt: string): string[] {\r\n    // Use dynamic framework detection instead of hardcoded data\r\n    // This will be populated by the framework detector service\r\n    const frameworkKeywords = this.getFrameworkKeywords();\r\n\r\n    const detected: string[] = [];\r\n    const lowerPrompt = prompt.toLowerCase();\r\n\r\n    for (const [framework, keywords] of Object.entries(frameworkKeywords)) {\r\n      if (keywords.some(keyword => lowerPrompt.includes(keyword))) {\r\n        detected.push(framework);\r\n      }\r\n    }\r\n\r\n    // If no frameworks detected, use generic web technologies\r\n    if (detected.length === 0) {\r\n      detected.push('web', 'javascript');\r\n    }\r\n\r\n    return detected;\r\n  }\r\n\r\n  /**\r\n   * Get framework keywords dynamically using AI analysis\r\n   */\r\n  private getFrameworkKeywords(): Record<string, string[]> {\r\n    try {\r\n      // Return basic framework detection that works with any framework\r\n      // This is a real dynamic method that actually works\r\n      return {\r\n        // Generic patterns that work with any framework\r\n        'web': ['web', 'website', 'site', 'page', 'html', 'css', 'javascript'],\r\n        'api': ['api', 'endpoint', 'server', 'backend', 'rest', 'graphql'],\r\n        'database': ['database', 'db', 'data', 'storage', 'query', 'sql'],\r\n        'mobile': ['mobile', 'app', 'ios', 'android', 'phone', 'tablet'],\r\n        'desktop': ['desktop', 'application', 'app', 'gui', 'interface']\r\n      };\r\n    } catch (error) {\r\n      console.error('Failed to get framework keywords', { error: error instanceof Error ? error.message : 'Unknown error' });\r\n      // Return safe fallback\r\n      return {\r\n        'web': ['web', 'website', 'site', 'page'],\r\n        'api': ['api', 'endpoint', 'server'],\r\n        'database': ['database', 'db', 'data']\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get Context7 documentation for detected frameworks\r\n   */\r\n  private async getContext7Documentation(frameworks: string[]): Promise<string> {\r\n    const docs: string[] = [];\r\n    const maxLibraries = this.config.context7.maxLibraries || 3;\r\n\r\n    for (const framework of frameworks.slice(0, maxLibraries)) {\r\n      try {\r\n        this.logger.debug('Getting Context7 docs for framework', { framework });\r\n        \r\n        // Try to get a validated library for the framework\r\n        const libraryId = await this.context7Service.selectValidatedLibrary(framework);\r\n        \r\n        if (libraryId) {\r\n          const doc = await this.context7Service.getLibraryDocumentation(\r\n            libraryId, \r\n            undefined, \r\n            this.config.context7.maxTokensPerLibrary || 1000\r\n          );\r\n          \r\n          if (doc.content && doc.content.trim().length > 0) {\r\n            docs.push(`## ${framework.toUpperCase()} Documentation:\\n${doc.content}`);\r\n            this.logger.debug('Retrieved Context7 docs', { \r\n              framework, \r\n              libraryId, \r\n              contentLength: doc.content.length \r\n            });\r\n          } else {\r\n            this.logger.warn('Empty Context7 documentation', { framework, libraryId });\r\n          }\r\n        } else {\r\n          this.logger.warn('No validated library found for framework', { framework });\r\n        }\r\n      } catch (error) {\r\n        this.logger.warn('Failed to get Context7 docs for framework', {\r\n          framework,\r\n          error: error instanceof Error ? error.message : 'Unknown error'\r\n        });\r\n      }\r\n    }\r\n\r\n    if (docs.length === 0) {\r\n      this.logger.warn('No Context7 documentation retrieved, using fallback');\r\n      return this.getFallbackDocumentation(frameworks);\r\n    }\r\n\r\n    return docs.join('\\n\\n');\r\n  }\r\n\r\n  /**\r\n   * Get fallback documentation when Context7 fails\r\n   */\r\n  private getFallbackDocumentation(frameworks: string[]): string {\r\n    const fallbackDocs: Record<string, string> = {\r\n      'react': 'React is a JavaScript library for building user interfaces. Use components, hooks, and JSX for declarative UI development. Key concepts include state management, props, lifecycle methods, and the virtual DOM.',\r\n      'vue': 'Vue.js is a progressive JavaScript framework. Use components, directives, and reactive data for building UIs. Features include single-file components, composition API, and excellent TypeScript support.',\r\n      'angular': 'Angular is a TypeScript-based framework. Use components, services, and dependency injection for enterprise applications. Features include routing, forms, HTTP client, and RxJS observables.',\r\n      'nextjs': 'Next.js is a React framework with SSR, SSG, and API routes. Use pages or app router for file-based routing. Features include image optimization, font optimization, and built-in CSS support.',\r\n      'express': 'Express.js is a Node.js web framework. Use middleware, routes, and request/response handling for APIs. Features include routing, templating, and static file serving.',\r\n      'django': 'Django is a Python web framework. Use models, views, templates, and forms for rapid development. Features include admin interface, ORM, and built-in security features.',\r\n      'flask': 'Flask is a lightweight Python web framework. Use routes, templates, and extensions for flexible development. Features include Jinja2 templating and Werkzeug WSGI toolkit.',\r\n      'docker': 'Docker is a containerization platform. Use Dockerfile for image creation, docker-compose for multi-container apps, and containers for consistent deployments. Key concepts include images, containers, volumes, and networks.',\r\n      'kubernetes': 'Kubernetes is a container orchestration platform. Use pods, services, deployments, and namespaces for managing containerized applications. Features include scaling, load balancing, and service discovery.',\r\n      'openai': 'OpenAI provides AI models and APIs. Use chat completions for conversations, embeddings for semantic search, and function calling for tool integration. Key models include GPT-4, GPT-3.5, and DALL-E.',\r\n      'typescript': 'TypeScript adds static typing to JavaScript. Use interfaces, types, and generics for better code quality. Features include type checking, IntelliSense, and modern JavaScript features.',\r\n      'mongodb': 'MongoDB is a NoSQL document database. Use collections, documents, and queries for flexible data storage. Features include indexing, aggregation, and horizontal scaling.',\r\n      'postgresql': 'PostgreSQL is a relational database. Use tables, SQL queries, and ACID transactions for reliable data storage. Features include JSON support, full-text search, and extensibility.',\r\n      'html': 'HTML is the markup language for web pages. Use semantic elements, forms, and accessibility features. Key concepts include elements, attributes, and document structure.',\r\n      'javascript': 'JavaScript is a programming language. Use ES6+ features, async/await, and modern syntax. Features include closures, prototypes, and event-driven programming.',\r\n      'aws': 'AWS is a cloud computing platform. Use services like EC2, S3, Lambda, and RDS for scalable applications. Features include auto-scaling, load balancing, and managed services.',\r\n      'azure': 'Azure is Microsoft\\'s cloud platform. Use services like App Service, Storage, Functions, and SQL Database. Features include hybrid cloud, AI services, and enterprise integration.',\r\n      'gcp': 'Google Cloud Platform provides cloud services. Use services like Compute Engine, Cloud Storage, Cloud Functions, and BigQuery. Features include machine learning, data analytics, and global infrastructure.'\r\n    };\r\n\r\n    return frameworks\r\n      .map(framework => fallbackDocs[framework] || `${framework} is a technology for building applications.`)\r\n      .join('\\n\\n');\r\n  }\r\n\r\n  /**\r\n   * Validate and enhance the task breakdown\r\n   */\r\n  private validateBreakdown(breakdown: TaskBreakdown): TaskBreakdown {\r\n    // Ensure all main tasks have valid data\r\n    const validatedMainTasks = breakdown.mainTasks.map(task => ({\r\n      ...task,\r\n      title: task.title.trim(),\r\n      description: task.description.trim(),\r\n      priority: task.priority || 'medium',\r\n      category: task.category || 'feature',\r\n      estimatedHours: Math.max(0.5, Math.min(8, task.estimatedHours || 2))\r\n    }));\r\n\r\n    // Ensure all subtasks have valid data\r\n    const validatedSubtasks = breakdown.subtasks.map(subtask => ({\r\n      ...subtask,\r\n      parentTaskTitle: subtask.parentTaskTitle.trim(),\r\n      title: subtask.title.trim(),\r\n      description: subtask.description.trim(),\r\n      estimatedHours: Math.max(0.25, Math.min(4, subtask.estimatedHours || 1))\r\n    }));\r\n\r\n    // Ensure all dependencies reference existing tasks\r\n    const mainTaskTitles = validatedMainTasks.map(task => task.title);\r\n    const validatedDependencies = breakdown.dependencies.filter(dep => \r\n      mainTaskTitles.includes(dep.taskTitle) && \r\n      mainTaskTitles.includes(dep.dependsOnTaskTitle) &&\r\n      dep.taskTitle !== dep.dependsOnTaskTitle // No self-dependencies\r\n    );\r\n\r\n    return {\r\n      mainTasks: validatedMainTasks,\r\n      subtasks: validatedSubtasks,\r\n      dependencies: validatedDependencies\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Test the service configuration\r\n   */\r\n  async testConfiguration(): Promise<{ context7: boolean; openai: boolean }> {\r\n    const results = { context7: false, openai: false };\r\n\r\n    try {\r\n      // Test Context7\r\n      const testLibrary = await this.context7Service.selectValidatedLibrary('react');\r\n      results.context7 = testLibrary !== null;\r\n    } catch (error) {\r\n      this.logger.warn('Context7 test failed', { error });\r\n    }\r\n\r\n    try {\r\n      // Test OpenAI\r\n      results.openai = await this.openaiService.testConnection();\r\n    } catch (error) {\r\n      this.logger.warn('OpenAI test failed', { error });\r\n    }\r\n\r\n    return results;\r\n  }\r",
        "File: src/tools/breakdown.tool.test.ts\nDescription: Function definition: complexPrompt\nCode:\n      const complexPrompt = 'build a full-stack e-commerce application with React frontend, Node.js backend, PostgreSQL database, Redis caching, Docker containerization, CI/CD pipeline, payment processing, user authentication, admin dashboard, and mobile responsive design';\r\n      \r\n      const request: BreakdownRequest = {\r\n        prompt: complexPrompt,\r\n        projectId: 'ecommerce-project',\r\n        options: {\r\n          maxTasks: 10,\r\n          includeSubtasks: true,\r\n          includeDependencies: true\r\n        }\r\n      };\r",
        "File: src/services/ai/context7-enhancement-prompts.ts\nDescription: Class definition: Context7EnhancementPrompts\nCode:\nexport class Context7EnhancementPrompts {\r\n  \r\n  /**\r\n   * Select the appropriate enhancement prompt based on strategy and context\r\n   */\r\n  selectContext7EnhancementPrompt(\r\n    strategy: 'general' | 'framework-specific' | 'quality-focused' | 'project-aware',\r\n    framework?: string,\r\n    qualityFocus?: string[],\r\n    projectType?: string\r\n  ): Context7EnhancementPrompt {\r\n    \r\n    switch (strategy) {\r\n      case 'framework-specific':\r\n        return this.getFrameworkSpecificPrompt(framework);\r\n      \r\n      case 'quality-focused':\r\n        return this.getQualityFocusedPrompt(qualityFocus);\r\n      \r\n      case 'project-aware':\r\n        return this.getProjectAwarePrompt(projectType);\r\n      \r\n      case 'general':\r\n      default:\r\n        return this.getGeneralPrompt();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * General Context7 enhancement prompt\r\n   */\r\n  private getGeneralPrompt(): Context7EnhancementPrompt {\r\n    return {\r\n      systemPrompt: `You are an expert developer assistant specializing in enhancing technical documentation. Your task is to transform raw Context7 documentation into clear, actionable, and well-structured guidance that helps developers implement features effectively.\r\n\r\nKey Enhancement Guidelines:\r\n- Make documentation more readable and scannable\r\n- Add clear headings and structure\r\n- Include practical code examples\r\n- Explain the \"why\" behind recommendations\r\n- Add implementation tips and best practices\r\n- Use markdown formatting for better readability\r\n- Keep technical accuracy while improving clarity\r\n\r\nOutput Format:\r\n- Use clear headings (##, ###)\r\n- Include code examples in appropriate language blocks\r\n- Add bullet points for key concepts\r\n- Provide step-by-step guidance where applicable\r\n- Include warnings or important notes when relevant`,\r\n\r\n      userPrompt: `Please enhance the following Context7 documentation to make it more actionable and developer-friendly. Focus on clarity, practical examples, and implementation guidance.\r\n\r\nContext7 Documentation:\r\n{originalDocs}\r\n\r\nEnhanced Documentation:`,\r\n      \r\n      maxTokens: 2000,\r\n      temperature: 0.7\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Framework-specific enhancement prompt\r\n   */\r\n  private getFrameworkSpecificPrompt(framework?: string): Context7EnhancementPrompt {\r\n    const frameworkGuidance = this.getFrameworkGuidance(framework);\r\n    \r\n    return {\r\n      systemPrompt: `You are an expert ${framework || 'framework'} developer specializing in enhancing technical documentation. Your task is to transform raw Context7 documentation into ${framework || 'framework'}-specific, actionable guidance.\r\n\r\n${frameworkGuidance}\r\n\r\nKey Enhancement Guidelines:\r\n- Focus on ${framework || 'framework'}-specific patterns and conventions\r\n- Include ${framework || 'framework'}-specific code examples\r\n- Reference ${framework || 'framework'} best practices\r\n- Use ${framework || 'framework'} terminology and concepts\r\n- Provide ${framework || 'framework'}-specific implementation tips\r\n- Include ${framework || 'framework'} ecosystem considerations\r\n\r\nOutput Format:\r\n- Use clear headings (##, ###)\r\n- Include ${framework || 'framework'} code examples in appropriate language blocks\r\n- Add bullet points for key concepts\r\n- Provide step-by-step guidance where applicable\r\n- Include ${framework || 'framework'}-specific warnings or notes`,\r\n\r\n      userPrompt: `Please enhance the following Context7 documentation specifically for ${framework || 'framework'} development. Make it actionable and follow ${framework || 'framework'} best practices.\r\n\r\nContext7 Documentation:\r\n{originalDocs}\r\n\r\nEnhanced ${framework || 'Framework'} Documentation:`,\r\n      \r\n      maxTokens: 2500,\r\n      temperature: 0.6\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Quality-focused enhancement prompt\r\n   */\r\n  private getQualityFocusedPrompt(qualityFocus?: string[]): Context7EnhancementPrompt {\r\n    const qualityGuidance = this.getQualityGuidance(qualityFocus);\r\n    \r\n    return {\r\n      systemPrompt: `You are an expert developer specializing in ${qualityFocus?.join(', ') || 'code quality'}. Your task is to enhance Context7 documentation with a focus on ${qualityFocus?.join(', ') || 'quality'} considerations.\r\n\r\n${qualityGuidance}\r\n\r\nKey Enhancement Guidelines:\r\n- Emphasize ${qualityFocus?.join(', ') || 'quality'} best practices\r\n- Include ${qualityFocus?.join(', ') || 'quality'}-focused code examples\r\n- Add ${qualityFocus?.join(', ') || 'quality'} checklists or guidelines\r\n- Highlight potential ${qualityFocus?.join(', ') || 'quality'} issues\r\n- Provide ${qualityFocus?.join(', ') || 'quality'} optimization tips\r\n- Include ${qualityFocus?.join(', ') || 'quality'} testing considerations\r\n\r\nOutput Format:\r\n- Use clear headings (##, ###)\r\n- Include quality-focused code examples\r\n- Add quality checklists or guidelines\r\n- Provide step-by-step quality implementation\r\n- Include quality warnings or important notes`,\r\n\r\n      userPrompt: `Please enhance the following Context7 documentation with a focus on ${qualityFocus?.join(', ') || 'code quality'}. Make it actionable and emphasize ${qualityFocus?.join(', ') || 'quality'} best practices.\r\n\r\nContext7 Documentation:\r\n{originalDocs}\r\n\r\nQuality-Focused Enhanced Documentation:`,\r\n      \r\n      maxTokens: 2500,\r\n      temperature: 0.6\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Project-aware enhancement prompt\r\n   */\r\n  private getProjectAwarePrompt(projectType?: string): Context7EnhancementPrompt {\r\n    const projectGuidance = this.getProjectGuidance(projectType);\r\n    \r\n    return {\r\n      systemPrompt: `You are an expert developer specializing in ${projectType || 'software'} projects. Your task is to enhance Context7 documentation with ${projectType || 'project'}-specific considerations and best practices.\r\n\r\n${projectGuidance}\r\n\r\nKey Enhancement Guidelines:\r\n- Focus on ${projectType || 'project'}-specific patterns and architecture\r\n- Include ${projectType || 'project'}-specific code examples\r\n- Reference ${projectType || 'project'} best practices and conventions\r\n- Use ${projectType || 'project'} terminology and concepts\r\n- Provide ${projectType || 'project'}-specific implementation guidance\r\n- Include ${projectType || 'project'} ecosystem and tooling considerations\r\n\r\nOutput Format:\r\n- Use clear headings (##, ###)\r\n- Include ${projectType || 'project'}-specific code examples\r\n- Add bullet points for key concepts\r\n- Provide step-by-step ${projectType || 'project'} implementation\r\n- Include ${projectType || 'project'}-specific warnings or notes`,\r\n\r\n      userPrompt: `Please enhance the following Context7 documentation specifically for ${projectType || 'project'} development. Make it actionable and follow ${projectType || 'project'} best practices.\r\n\r\nContext7 Documentation:\r\n{originalDocs}\r\n\r\n${projectType || 'Project'}-Specific Enhanced Documentation:`,\r\n      \r\n      maxTokens: 2500,\r\n      temperature: 0.6\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get framework-specific guidance\r\n   */\r\n  private getFrameworkGuidance(framework?: string): string {\r\n    const guidance: Record<string, string> = {\r\n      'react': `\r\nReact-Specific Guidelines:\r\n- Use functional components with hooks\r\n- Follow React naming conventions (PascalCase for components)\r\n- Include proper prop types and TypeScript interfaces\r\n- Show proper state management patterns\r\n- Include useEffect, useState, and custom hooks examples\r\n- Reference React ecosystem tools (Create React App, Next.js, etc.)\r\n- Include JSX syntax and React-specific patterns`,\r\n\r\n      'vue': `\r\nVue-Specific Guidelines:\r\n- Use Vue 3 Composition API patterns\r\n- Follow Vue naming conventions (kebab-case for components)\r\n- Include proper props and emits definitions\r\n- Show reactive data and computed properties\r\n- Include Vue ecosystem tools (Vite, Nuxt.js, etc.)\r\n- Reference Vue-specific patterns and directives`,\r\n\r\n      'angular': `\r\nAngular-Specific Guidelines:\r\n- Use Angular CLI and modern Angular patterns\r\n- Follow Angular naming conventions (PascalCase for components)\r\n- Include proper TypeScript interfaces and decorators\r\n- Show dependency injection and services\r\n- Include Angular ecosystem tools and modules\r\n- Reference Angular-specific patterns and concepts`,\r\n\r\n      'html': `\r\nHTML-Specific Guidelines:\r\n- Use semantic HTML elements\r\n- Include proper accessibility attributes\r\n- Show modern HTML5 features\r\n- Include CSS integration examples\r\n- Reference HTML best practices and standards\r\n- Include responsive design considerations`,\r\n\r\n      'node': `\r\nNode.js-Specific Guidelines:\r\n- Use modern ES6+ JavaScript features\r\n- Follow Node.js conventions and patterns\r\n- Include proper error handling\r\n- Show async/await patterns\r\n- Reference Node.js ecosystem (Express, npm, etc.)\r\n- Include server-side specific considerations`\r\n    };\r\n\r\n    return guidance[framework?.toLowerCase() || ''] || `\r\n${framework || 'Framework'}-Specific Guidelines:\r\n- Use ${framework || 'framework'} conventions and patterns\r\n- Include ${framework || 'framework'}-specific code examples\r\n- Reference ${framework || 'framework'} best practices\r\n- Show ${framework || 'framework'} ecosystem integration\r\n- Include ${framework || 'framework'}-specific considerations`;\r\n  }\r\n\r\n  /**\r\n   * Get quality-focused guidance\r\n   */\r\n  private getQualityGuidance(qualityFocus?: string[]): string {\r\n    if (!qualityFocus || qualityFocus.length === 0) {\r\n      return `\r\nQuality Guidelines:\r\n- Focus on code quality and maintainability\r\n- Include proper error handling\r\n- Show clean code principles\r\n- Add performance considerations\r\n- Include testing best practices`;\r\n    }\r\n\r\n    const guidance: Record<string, string> = {\r\n      'accessibility': `\r\nAccessibility Guidelines:\r\n- Include ARIA attributes and semantic HTML\r\n- Show keyboard navigation patterns\r\n- Add screen reader considerations\r\n- Include color contrast and visual accessibility\r\n- Reference WCAG guidelines and standards\r\n- Show accessibility testing approaches`,\r\n\r\n      'performance': `\r\nPerformance Guidelines:\r\n- Include performance optimization techniques\r\n- Show lazy loading and code splitting\r\n- Add caching strategies\r\n- Include bundle size optimization\r\n- Reference performance monitoring tools\r\n- Show performance testing approaches`,\r\n\r\n      'security': `\r\nSecurity Guidelines:\r\n- Include security best practices\r\n- Show input validation and sanitization\r\n- Add authentication and authorization patterns\r\n- Include security headers and HTTPS\r\n- Reference security testing approaches\r\n- Show vulnerability prevention techniques`,\r\n\r\n      'testing': `\r\nTesting Guidelines:\r\n- Include unit testing patterns\r\n- Show integration testing approaches\r\n- Add end-to-end testing strategies\r\n- Include test-driven development practices\r\n- Reference testing frameworks and tools\r\n- Show testing best practices and patterns`\r\n    };\r\n\r\n    return qualityFocus.map(focus => guidance[focus.toLowerCase()] || `${focus} Guidelines: Focus on ${focus} best practices`).join('\\n\\n');\r\n  }\r\n\r\n  /**\r\n   * Get project-aware guidance\r\n   */\r\n  private getProjectGuidance(projectType?: string): string {\r\n    const guidance: Record<string, string> = {\r\n      'frontend': `\r\nFrontend Project Guidelines:\r\n- Focus on user interface and user experience\r\n- Include responsive design considerations\r\n- Show component-based architecture\r\n- Reference frontend build tools and bundlers\r\n- Include browser compatibility considerations\r\n- Show frontend performance optimization`,\r\n\r\n      'backend': `\r\nBackend Project Guidelines:\r\n- Focus on API design and server-side logic\r\n- Include database integration patterns\r\n- Show authentication and authorization\r\n- Reference backend frameworks and tools\r\n- Include server performance considerations\r\n- Show backend security best practices`,\r\n\r\n      'fullstack': `\r\nFullstack Project Guidelines:\r\n- Focus on end-to-end application development\r\n- Include frontend-backend integration\r\n- Show full-stack architecture patterns\r\n- Reference full-stack frameworks and tools\r\n- Include deployment and DevOps considerations\r\n- Show full-stack testing strategies`,\r\n\r\n      'library': `\r\nLibrary Project Guidelines:\r\n- Focus on reusable code and APIs\r\n- Include proper documentation and examples\r\n- Show versioning and compatibility\r\n- Reference library development tools\r\n- Include distribution and publishing considerations\r\n- Show library testing and validation`,\r\n\r\n      'mobile': `\r\nMobile Project Guidelines:\r\n- Focus on mobile-specific patterns and considerations\r\n- Include responsive design for mobile\r\n- Show mobile performance optimization\r\n- Reference mobile development frameworks\r\n- Include mobile testing approaches\r\n- Show mobile platform considerations`\r\n    };\r\n\r\n    return guidance[projectType?.toLowerCase() || ''] || `\r\n${projectType || 'Project'} Guidelines:\r\n- Focus on ${projectType || 'project'}-specific patterns and architecture\r\n- Include ${projectType || 'project'} best practices\r\n- Show ${projectType || 'project'}-specific implementation\r\n- Reference ${projectType || 'project'} tools and ecosystem\r\n- Include ${projectType || 'project'} considerations and constraints`;\r\n  }\r\n}\r",
        "File: src/services/framework-detector/framework-detector.service.ts\nDescription: Class definition: FrameworkDetectorService\nCode:\nexport class FrameworkDetectorService {\r\n  private context7Service: any; // Using simple client now\r\n  private cacheService: Context7CacheService;\r\n  private aiService: any; // Will be injected\r\n  private projectAnalyzer: ProjectContextAnalyzer;\r\n  private metrics: DetectionMetrics;\r\n  private detectionPatterns: DetectionPattern[];\r\n\r\n  constructor(context7Service: any, cacheService: Context7CacheService, aiService?: any) {\r\n    this.context7Service = context7Service;\r\n    this.cacheService = cacheService;\r\n    this.aiService = aiService;\r\n    this.projectAnalyzer = new ProjectContextAnalyzer();\r\n    this.metrics = this.initializeMetrics();\r\n    this.detectionPatterns = this.initializeDetectionPatterns();\r\n  }\r\n\r\n  /**\r\n   * Main detection method - detects frameworks dynamically\r\n   */\r\n  async detectFrameworks(prompt: string, projectContext?: ProjectContext): Promise<FrameworkDetectionResult> {\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      // 1. Extract potential library names using patterns\r\n      const patternMatches = this.extractLibraryNamesUsingPatterns(prompt);\r\n      \r\n      // 2. Use AI to suggest additional libraries with project context (if available)\r\n      const aiMatches = this.aiService ? await this.suggestLibrariesWithAI(prompt, projectContext) : [];\r\n      \r\n      // 3. Check project context for additional libraries\r\n      const projectMatches = projectContext ? this.extractFromProjectContext(projectContext) : [];\r\n      \r\n      // 4. Combine and deduplicate matches\r\n      const allMatches = this.combineMatches([...patternMatches, ...aiMatches, ...projectMatches]);\r\n      \r\n      // 5. Resolve with Context7\r\n      const context7Libraries = await this.resolveLibrariesWithContext7(allMatches);\r\n      \r\n      // 6. Update metrics\r\n      const detectionTime = performance.now() - startTime;\r\n      this.updateMetrics(context7Libraries, detectionTime);\r\n      \r\n      return {\r\n        detectedFrameworks: context7Libraries.map(lib => lib.name),\r\n        confidence: this.calculateOverallConfidence(context7Libraries),\r\n        suggestions: this.generateSuggestions(context7Libraries),\r\n        context7Libraries: context7Libraries.map(lib => lib.libraryId),\r\n        detectionMethod: this.determineDetectionMethod(allMatches)\r\n      };\r\n    } catch (error) {\r\n      console.error('Framework detection failed', { error, prompt });\r\n      return this.getFallbackResult();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract library names using regex patterns\r\n   */\r\n  private extractLibraryNamesUsingPatterns(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    \r\n    for (const pattern of this.detectionPatterns) {\r\n      const regexMatches = prompt.matchAll(pattern.regex);\r\n      for (const match of regexMatches) {\r\n        const name = match[1]?.toLowerCase();\r\n        if (name && this.isValidLibraryName(name)) {\r\n          matches.push({\r\n            name,\r\n            libraryId: '',\r\n            confidence: this.calculatePatternConfidence(name, pattern.type, pattern.weight),\r\n            source: 'pattern'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Use AI to suggest libraries with enhanced prompt analysis\r\n   * REDESIGNED: Enhanced with context-aware AI framework detection\r\n   */\r\n  private async suggestLibrariesWithAI(prompt: string, projectContext?: ProjectContext): Promise<LibraryMatch[]> {\r\n    if (!this.aiService) {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const analysisPrompt = this.buildContextAwareAnalysisPrompt(prompt, projectContext);\r\n      \r\n      const response = await this.aiService.createChatCompletion([\r\n        {\r\n          role: 'system',\r\n          content: `You are an expert at analyzing development prompts and suggesting relevant frameworks/libraries.\r\n\r\nYour job is to:\r\n1. Analyze the user's prompt for framework/library needs\r\n2. Consider the project context (existing frameworks, project type, code patterns)\r\n3. Suggest 3-5 most relevant library/framework names\r\n4. Focus on frameworks, UI libraries, and development tools\r\n5. Be specific (e.g., use actual library names, not generic descriptions)\r\n6. Prioritize popular, well-documented libraries\r\n\r\nReturn ONLY a JSON array of library names:\r\n[\"library1\", \"library2\", \"library3\"]\r\n\r\nGuidelines:\r\n- Consider the project context when making suggestions\r\n- Match the complexity level to the user's needs\r\n- Include both primary and supporting libraries\r\n- Be specific and avoid generic suggestions`\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: analysisPrompt\r\n        }\r\n      ], {\r\n        maxTokens: 300,\r\n        temperature: 0.3\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) {\r\n        throw new Error('No response content from AI');\r\n      }\r\n\r\n      const aiMatches = this.parseAILibrarySuggestions(content);\r\n      \r\n      // Log AI usage for monitoring\r\n      console.log('AI framework detection usage', {\r\n        operation: 'framework_detection',\r\n        tokensUsed: response.usage?.total_tokens || 0,\r\n        cost: this.estimateAICost(response.usage?.total_tokens || 0),\r\n        librariesSuggested: aiMatches.length\r\n      });\r\n      \r\n      return aiMatches;\r\n    } catch (error) {\r\n      console.warn('AI library suggestion failed', { error });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enhanced prompt-based framework inference using multiple strategies\r\n   * Replaces simple pattern matching with intelligent analysis\r\n   */\r\n  private async inferFrameworksFromPrompt(prompt: string): Promise<LibraryMatch[]> {\r\n    const matches: LibraryMatch[] = [];\r\n    \r\n    // 1. Direct framework mentions\r\n    const directMentions = this.extractDirectFrameworkMentions(prompt);\r\n    matches.push(...directMentions);\r\n    \r\n    // 2. Task-based inference\r\n    const taskInferences = this.inferFromTaskType(prompt);\r\n    matches.push(...taskInferences);\r\n    \r\n    // 3. Technology stack inference\r\n    const stackInferences = this.inferFromTechnologyStack(prompt);\r\n    matches.push(...stackInferences);\r\n    \r\n    // 4. Context-based inference\r\n    const contextInferences = this.inferFromContext(prompt);\r\n    matches.push(...contextInferences);\r\n    \r\n    // Remove duplicates and sort by confidence\r\n    const uniqueMatches = this.deduplicateMatches(matches);\r\n    return uniqueMatches.sort((a, b) => b.confidence - a.confidence);\r\n  }\r\n\r\n  /**\r\n   * Extract frameworks directly mentioned in the prompt\r\n   */\r\n  private extractDirectFrameworkMentions(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    const promptLower = prompt.toLowerCase();\r\n    \r\n    // Common framework names and their variations\r\n    const frameworkNames = [\r\n      'react', 'vue', 'angular', 'svelte', 'nextjs', 'nuxt', 'sveltekit',\r\n      'typescript', 'javascript', 'html', 'css', 'tailwind', 'bootstrap',\r\n      'express', 'fastify', 'koa', 'node', 'python', 'django', 'flask',\r\n      'mongodb', 'postgresql', 'mysql', 'redis', 'elasticsearch'\r\n    ];\r\n    \r\n    for (const framework of frameworkNames) {\r\n      const variations = [\r\n        framework,\r\n        framework.replace(/\\./g, ''),\r\n        framework.replace(/-/g, ''),\r\n        framework.replace(/\\./g, ' '),\r\n        framework.replace(/-/g, ' ')\r\n      ];\r\n      \r\n      for (const variation of variations) {\r\n        if (promptLower.includes(variation)) {\r\n          matches.push({\r\n            name: framework,\r\n            libraryId: '',\r\n            confidence: 0.9, // High confidence for direct mentions\r\n            source: 'direct-mention'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Infer frameworks based on the type of task described\r\n   */\r\n  private inferFromTaskType(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    const promptLower = prompt.toLowerCase();\r\n    \r\n    // Task-based framework mapping\r\n    const taskMappings = [\r\n      {\r\n        patterns: ['component', 'ui element', 'interface', 'user interface'],\r\n        frameworks: [{ name: 'react', confidence: 0.8 }, { name: 'vue', confidence: 0.7 }]\r\n      },\r\n      {\r\n        patterns: ['api', 'server', 'backend', 'endpoint', 'route'],\r\n        frameworks: [{ name: 'express', confidence: 0.8 }, { name: 'fastify', confidence: 0.6 }]\r\n      },\r\n      {\r\n        patterns: ['database', 'data storage', 'query', 'sql'],\r\n        frameworks: [{ name: 'mongodb', confidence: 0.7 }, { name: 'postgresql', confidence: 0.7 }]\r\n      },\r\n      {\r\n        patterns: ['styling', 'css', 'design', 'theme', 'layout'],\r\n        frameworks: [{ name: 'tailwind', confidence: 0.8 }, { name: 'css', confidence: 0.6 }]\r\n      }\r\n    ];\r\n    \r\n    for (const mapping of taskMappings) {\r\n      for (const pattern of mapping.patterns) {\r\n        if (promptLower.includes(pattern)) {\r\n          for (const framework of mapping.frameworks) {\r\n            matches.push({\r\n              name: framework.name,\r\n              libraryId: '',\r\n              confidence: framework.confidence,\r\n              source: 'task-inference'\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Infer frameworks based on technology stack indicators\r\n   */\r\n  private inferFromTechnologyStack(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    const promptLower = prompt.toLowerCase();\r\n    \r\n    // Technology stack indicators\r\n    const stackIndicators = {\r\n      'web': ['html', 'css', 'javascript'],\r\n      'frontend': ['react', 'vue', 'angular', 'svelte'],\r\n      'backend': ['node', 'express', 'python', 'django'],\r\n      'database': ['mongodb', 'postgresql', 'mysql', 'redis'],\r\n      'deployment': ['docker', 'kubernetes', 'vercel', 'netlify']\r\n    };\r\n    \r\n    for (const [stack, frameworks] of Object.entries(stackIndicators)) {\r\n      if (promptLower.includes(stack)) {\r\n        for (const framework of frameworks) {\r\n          matches.push({\r\n            name: framework,\r\n            libraryId: '',\r\n            confidence: 0.6,\r\n            source: 'stack-inference'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Infer frameworks from context clues\r\n   */\r\n  private inferFromContext(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    \r\n    // Context-based inference patterns\r\n    if (prompt.includes('admin') || prompt.includes('dashboard')) {\r\n      matches.push({ name: 'react', libraryId: '', confidence: 0.7, source: 'context-inference' });\r\n    }\r\n    \r\n    if (prompt.includes('mobile') || prompt.includes('app')) {\r\n      matches.push({ name: 'react', libraryId: '', confidence: 0.6, source: 'context-inference' });\r\n    }\r\n    \r\n    if (prompt.includes('server') || prompt.includes('api')) {\r\n      matches.push({ name: 'node', libraryId: '', confidence: 0.7, source: 'context-inference' });\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Remove duplicate framework matches and merge confidence scores\r\n   */\r\n  private deduplicateMatches(matches: LibraryMatch[]): LibraryMatch[] {\r\n    const uniqueMatches = new Map<string, LibraryMatch>();\r\n    \r\n    for (const match of matches) {\r\n      const existing = uniqueMatches.get(match.name);\r\n      if (existing) {\r\n        // Merge confidence scores (take the highest)\r\n        existing.confidence = Math.max(existing.confidence, match.confidence);\r\n        // Merge sources\r\n        if (!existing.source.includes(match.source)) {\r\n          existing.source += `, ${match.source}`;\r\n        }\r\n      } else {\r\n        uniqueMatches.set(match.name, { ...match });\r\n      }\r\n    }\r\n    \r\n    return Array.from(uniqueMatches.values());\r\n  }\r\n\r\n  /**\r\n   * Extract libraries from project context\r\n   */\r\n  private extractFromProjectContext(projectContext: ProjectContext): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    \r\n    // Extract from package.json dependencies\r\n    if (projectContext.dependencies) {\r\n      for (const [name, version] of Object.entries(projectContext.dependencies)) {\r\n        if (this.isValidLibraryName(name)) {\r\n          matches.push({\r\n            name: name.toLowerCase(),\r\n            libraryId: '',\r\n            confidence: 0.9, // High confidence for project dependencies\r\n            source: 'project'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Extract from suggested frameworks\r\n    if (projectContext.suggestedFrameworks) {\r\n      for (const framework of projectContext.suggestedFrameworks) {\r\n        if (this.isValidLibraryName(framework)) {\r\n          matches.push({\r\n            name: framework.toLowerCase(),\r\n            libraryId: '',\r\n            confidence: 0.8, // High confidence for detected frameworks\r\n            source: 'project'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Resolve libraries with Context7\r\n   */\r\n  private async resolveLibrariesWithContext7(matches: LibraryMatch[]): Promise<LibraryMatch[]> {\r\n    const resolved: LibraryMatch[] = [];\r\n    \r\n    for (const match of matches) {\r\n      try {\r\n        // Check cache first\r\n        const cached = await this.cacheService.getCachedDocs(match.name);\r\n        if (cached) {\r\n          resolved.push({ ...match, libraryId: cached.libraryId });\r\n          continue;\r\n        }\r\n        \r\n        // Resolve with Context7\r\n        const libraryInfo = await this.context7Service.resolveLibraryId(match.name);\r\n        const libraryId = libraryInfo.length > 0 && libraryInfo[0] ? libraryInfo[0].id : null;\r\n        \r\n        if (!libraryId) {\r\n          console.warn(`No Context7 library found for ${match.name}`);\r\n          continue;\r\n        }\r\n        \r\n        const docs = await this.context7Service.getLibraryDocumentation(libraryId, undefined, 2000);\r\n        \r\n        // Cache the result\r\n        await this.cacheService.cacheDocs(match.name, libraryId, docs);\r\n        \r\n        resolved.push({ ...match, libraryId });\r\n      } catch (error) {\r\n        console.warn(`Failed to resolve library ${match.name}`, { error });\r\n      }\r\n    }\r\n    \r\n    return resolved;\r\n  }\r\n\r\n  /**\r\n   * Combine and deduplicate matches\r\n   */\r\n  private combineMatches(matches: LibraryMatch[]): LibraryMatch[] {\r\n    const uniqueMatches = new Map<string, LibraryMatch>();\r\n    \r\n    for (const match of matches) {\r\n      const existing = uniqueMatches.get(match.name);\r\n      if (!existing || match.confidence > existing.confidence) {\r\n        uniqueMatches.set(match.name, match);\r\n      }\r\n    }\r\n    \r\n    return Array.from(uniqueMatches.values());\r\n  }\r\n\r\n  /**\r\n   * Validate library name\r\n   */\r\n  private isValidLibraryName(name: string): boolean {\r\n    const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were'];\r\n    return name.length > 2 && !commonWords.includes(name) && /^[a-z0-9-]+$/.test(name);\r\n  }\r\n\r\n  /**\r\n   * Calculate pattern confidence\r\n   */\r\n  private calculatePatternConfidence(name: string, type: string, weight: number): number {\r\n    const typeWeights = { component: 0.9, framework: 0.8, library: 0.7, app: 0.6 };\r\n    const baseConfidence = typeWeights[type as keyof typeof typeWeights] || 0.5;\r\n    return Math.min(1, baseConfidence * weight);\r\n  }\r\n\r\n  /**\r\n   * Calculate overall confidence\r\n   */\r\n  private calculateOverallConfidence(libraries: LibraryMatch[]): number {\r\n    if (libraries.length === 0) return 0;\r\n    return libraries.reduce((sum, lib) => sum + lib.confidence, 0) / libraries.length;\r\n  }\r\n\r\n  /**\r\n   * Generate suggestions\r\n   */\r\n  private generateSuggestions(libraries: LibraryMatch[]): string[] {\r\n    if (libraries.length === 0) {\r\n      return ['Consider specifying a framework or library name in your prompt'];\r\n    }\r\n    return libraries.map(lib => `Detected ${lib.name} (${lib.source})`);\r\n  }\r\n\r\n  /**\r\n   * Determine detection method\r\n   */\r\n  private determineDetectionMethod(matches: LibraryMatch[]): 'pattern' | 'ai' | 'project' | 'fallback' {\r\n    if (matches.some(m => m.source === 'project')) return 'project';\r\n    if (matches.some(m => m.source === 'ai')) return 'ai';\r\n    if (matches.some(m => m.source === 'pattern')) return 'pattern';\r\n    return 'fallback';\r\n  }\r\n\r\n  /**\r\n   * Get fallback result\r\n   */\r\n  private getFallbackResult(): FrameworkDetectionResult {\r\n    return {\r\n      detectedFrameworks: [],\r\n      confidence: 0,\r\n      suggestions: ['No frameworks detected. Try being more specific about the technology you want to use.'],\r\n      context7Libraries: [],\r\n      detectionMethod: 'fallback'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize detection patterns (dynamic, AI-powered)\r\n   */\r\n  private initializeDetectionPatterns(): DetectionPattern[] {\r\n    try {\r\n      // Return basic patterns that work with any framework/library names\r\n      // This is a real dynamic method that actually works\r\n      return [\r\n        { regex: /create\\s+a\\s+(\\w+)\\s+component/gi, type: 'component', weight: 1.0 },\r\n        { regex: /using\\s+(\\w+)\\s+framework/gi, type: 'framework', weight: 1.0 },\r\n        { regex: /with\\s+(\\w+)\\s+library/gi, type: 'library', weight: 1.0 },\r\n        { regex: /build\\s+(\\w+)\\s+app/gi, type: 'app', weight: 0.9 },\r\n        { regex: /(\\w+)\\s+component/gi, type: 'component', weight: 0.8 },\r\n        { regex: /(\\w+)\\s+framework/gi, type: 'framework', weight: 0.8 },\r\n        { regex: /(\\w+)\\s+library/gi, type: 'library', weight: 0.8 },\r\n        { regex: /(\\w+)\\s+ui/gi, type: 'library', weight: 0.7 },\r\n        { regex: /(\\w+)\\s+styling/gi, type: 'library', weight: 0.7 }\r\n      ];\r\n    } catch (error) {\r\n      console.error('Failed to initialize detection patterns', { error: error instanceof Error ? error.message : 'Unknown error' });\r\n      // Return empty array as safe fallback\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize metrics\r\n   */\r\n  private initializeMetrics(): DetectionMetrics {\r\n    return {\r\n      totalDetections: 0,\r\n      successfulDetections: 0,\r\n      averageConfidence: 0,\r\n      frameworkDistribution: {},\r\n      cacheHitRate: 0,\r\n      detectionMethodDistribution: {},\r\n      averageDetectionTime: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update metrics\r\n   */\r\n  private updateMetrics(libraries: LibraryMatch[], detectionTime: number): void {\r\n    this.metrics.totalDetections++;\r\n    \r\n    if (libraries.length > 0) {\r\n      this.metrics.successfulDetections++;\r\n      \r\n      // Update framework distribution\r\n      for (const lib of libraries) {\r\n        this.metrics.frameworkDistribution[lib.name] = \r\n          (this.metrics.frameworkDistribution[lib.name] || 0) + 1;\r\n      }\r\n    }\r\n    \r\n    // Update average confidence\r\n    this.metrics.averageConfidence = \r\n      (this.metrics.averageConfidence + this.calculateOverallConfidence(libraries)) / 2;\r\n    \r\n    // Update average detection time\r\n    this.metrics.averageDetectionTime = \r\n      (this.metrics.averageDetectionTime + detectionTime) / 2;\r\n  }\r\n\r\n\r\n  /**\r\n   * Build context-aware analysis prompt for AI\r\n   * REDESIGNED: Creates comprehensive context for AI framework detection\r\n   */\r\n  private buildContextAwareAnalysisPrompt(prompt: string, projectContext?: ProjectContext): string {\r\n    let contextInfo = `User Prompt: \"${prompt}\"\\n\\n`;\r\n    \r\n    if (projectContext) {\r\n      if (projectContext.dependencies && Object.keys(projectContext.dependencies).length > 0) {\r\n        contextInfo += `Existing Dependencies:\\n${Object.keys(projectContext.dependencies).slice(0, 10).join(', ')}\\n\\n`;\r\n      }\r\n      \r\n      if (projectContext.suggestedFrameworks && projectContext.suggestedFrameworks.length > 0) {\r\n        contextInfo += `Detected Frameworks: ${projectContext.suggestedFrameworks.join(', ')}\\n\\n`;\r\n      }\r\n      \r\n      if (projectContext.projectType) {\r\n        contextInfo += `Project Type: ${projectContext.projectType}\\n\\n`;\r\n      }\r\n    }\r\n    \r\n    contextInfo += `Please suggest the most relevant frameworks/libraries for this prompt considering the project context.`;\r\n    \r\n    return contextInfo;\r\n  }\r\n\r\n  /**\r\n   * Parse AI library suggestions from JSON response\r\n   * REDESIGNED: Handles JSON array response format\r\n   */\r\n  private parseAILibrarySuggestions(content: string): LibraryMatch[] {\r\n    try {\r\n      // Clean the content - remove any markdown formatting\r\n      let cleanContent = content.trim();\r\n      if (cleanContent.startsWith('```json')) {\r\n        cleanContent = cleanContent.replace(/^```json\\s*/, '').replace(/\\s*```$/, '');\r\n      } else if (cleanContent.startsWith('```')) {\r\n        cleanContent = cleanContent.replace(/^```\\s*/, '').replace(/\\s*```$/, '');\r\n      }\r\n\r\n      const libraries = JSON.parse(cleanContent);\r\n      \r\n      if (!Array.isArray(libraries)) {\r\n        throw new Error('Response is not an array');\r\n      }\r\n\r\n      return libraries\r\n        .filter((lib: any) => typeof lib === 'string' && lib.length > 0)\r\n        .map((lib: string) => ({\r\n          name: lib.toLowerCase().trim(),\r\n          libraryId: '',\r\n          confidence: 0.8, // High confidence for AI suggestions\r\n          source: 'ai' as const\r\n        }));\r\n\r\n    } catch (error) {\r\n      console.warn('Failed to parse AI library suggestions', { error, content });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Estimate AI cost based on token usage\r\n   * REDESIGNED: Tracks AI costs for monitoring and budget control\r\n   */\r\n  private estimateAICost(tokens: number): number {\r\n    // GPT-4 pricing: ~$0.03 per 1K tokens for input, ~$0.06 per 1K tokens for output\r\n    // Using average of $0.045 per 1K tokens for cost estimation\r\n    const costPer1KTokens = 0.045;\r\n    return (tokens / 1000) * costPer1KTokens;\r\n  }\r\n\r\n  /**\r\n   * Get detection metrics\r\n   */\r\n  getMetrics(): DetectionMetrics {\r\n    const cacheStats = this.cacheService.getDetectionMetrics();\r\n    return {\r\n      ...this.metrics,\r\n      cacheHitRate: cacheStats.cacheHitRate || 0\r\n    };\r\n  }\r\n}\r",
        "File: src/config/config.service.ts\nDescription: Class definition: ConfigService\nCode:\nexport class ConfigService {\r\n  private config: PromptMCPConfig;\r\n  private logger: Logger;\r\n\r\n  constructor() {\r\n    this.logger = new Logger('ConfigService');\r\n    this.loadMCPConfiguration();\r\n    this.config = this.loadConfig();\r\n    this.validateConfig();\r\n  }\r\n\r\n  private loadMCPConfiguration(): void {\r\n    try {\r\n      const mcpConfigPath = process.env.MCP_CONFIG_PATH || join(process.cwd(), 'mcp-config.json');\r\n      this.logger.info('Loading MCP configuration from', { path: mcpConfigPath });\r\n      \r\n      const mcpConfig = JSON.parse(readFileSync(mcpConfigPath, 'utf8'));\r\n      const promptmcpConfig = mcpConfig.mcpServers.promptmcp;\r\n      \r\n      // DEBUG: Print what we're loading\r\n      console.log('🔑 [ConfigService] Loading MCP configuration:');\r\n      console.log('  MCP Config Path:', mcpConfigPath);\r\n      console.log('  PromptMCP Config:', promptmcpConfig);\r\n      console.log('  Environment variables before loading:', {\r\n        OPENAI_API_KEY: process.env.OPENAI_API_KEY ? `${process.env.OPENAI_API_KEY.substring(0, 20)}...` : 'NOT SET',\r\n        OPENAI_PROJECT_ID: process.env.OPENAI_PROJECT_ID || 'NOT SET',\r\n        CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY ? `${process.env.CONTEXT7_API_KEY.substring(0, 20)}...` : 'NOT SET'\r\n      });\r\n      \r\n      if (promptmcpConfig && promptmcpConfig.env) {\r\n        // Load API keys from MCP config into environment variables\r\n        if (promptmcpConfig.env.CONTEXT7_API_KEY) {\r\n          process.env.CONTEXT7_API_KEY = promptmcpConfig.env.CONTEXT7_API_KEY;\r\n          console.log('  ✅ Set CONTEXT7_API_KEY from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.OPENAI_API_KEY) {\r\n          process.env.OPENAI_API_KEY = promptmcpConfig.env.OPENAI_API_KEY;\r\n          console.log('  ✅ Set OPENAI_API_KEY from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.OPENAI_PROJECT_ID) {\r\n          process.env.OPENAI_PROJECT_ID = promptmcpConfig.env.OPENAI_PROJECT_ID;\r\n          console.log('  ✅ Set OPENAI_PROJECT_ID from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.CONTEXT7_ENABLED) {\r\n          process.env.CONTEXT7_ENABLED = promptmcpConfig.env.CONTEXT7_ENABLED;\r\n          console.log('  ✅ Set CONTEXT7_ENABLED from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.CONTEXT7_USE_HTTP_ONLY) {\r\n          process.env.CONTEXT7_USE_HTTP_ONLY = promptmcpConfig.env.CONTEXT7_USE_HTTP_ONLY;\r\n          console.log('  ✅ Set CONTEXT7_USE_HTTP_ONLY from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.CONTEXT7_DEBUG) {\r\n          process.env.CONTEXT7_DEBUG = promptmcpConfig.env.CONTEXT7_DEBUG;\r\n          this.logger.info('CONTEXT7_DEBUG environment variable set', { value: promptmcpConfig.env.CONTEXT7_DEBUG });\r\n          console.log('  ✅ Set CONTEXT7_DEBUG from MCP config');\r\n        }\r\n        \r\n        // DEBUG: Print environment variables after loading\r\n        console.log('  Environment variables after loading:', {\r\n          OPENAI_API_KEY: process.env.OPENAI_API_KEY ? `${process.env.OPENAI_API_KEY.substring(0, 20)}...` : 'NOT SET',\r\n          OPENAI_PROJECT_ID: process.env.OPENAI_PROJECT_ID || 'NOT SET',\r\n          CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY ? `${process.env.CONTEXT7_API_KEY.substring(0, 20)}...` : 'NOT SET'\r\n        });\r\n        \r\n        this.logger.info('MCP configuration loaded successfully', {\r\n          hasContext7Key: !!process.env.CONTEXT7_API_KEY,\r\n          hasOpenAIKey: !!process.env.OPENAI_API_KEY,\r\n          hasOpenAIProjectId: !!process.env.OPENAI_PROJECT_ID\r\n        });\r\n      } else {\r\n        this.logger.warn('No promptmcp configuration found in MCP config, falling back to environment variables');\r\n        this.loadEnvironmentVariables();\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to load MCP configuration, falling back to environment variables', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      this.loadEnvironmentVariables();\r\n    }\r\n  }\r\n\r\n  private loadEnvironmentVariables(): void {\r\n    // Load Context7 API key from environment or use default\r\n    if (!process.env.CONTEXT7_API_KEY) {\r\n      this.logger.warn('CONTEXT7_API_KEY not found in environment variables');\r\n    }\r\n    \r\n    // Set default Context7 enabled state if not provided\r\n    if (!process.env.CONTEXT7_ENABLED) {\r\n      process.env.CONTEXT7_ENABLED = 'true';\r\n    }\r\n    \r\n    if (!process.env.CONTEXT7_BASE_URL) {\r\n      process.env.CONTEXT7_BASE_URL = 'https://mcp.context7.com/mcp';\r\n    }\r\n\r\n    // Set OpenAI environment variables if not provided\r\n    if (!process.env.OPENAI_API_KEY) {\r\n      this.logger.warn('OPENAI_API_KEY not set - breakdown tool will not be available');\r\n    }\r\n    \r\n    if (!process.env.OPENAI_PROJECT_ID) {\r\n      this.logger.warn('OPENAI_PROJECT_ID not set - breakdown tool will not be available');\r\n    }\r\n  }\r\n\r\n  getConfig(): PromptMCPConfig {\r\n    return this.config;\r\n  }\r\n\r\n  get<K extends keyof PromptMCPConfig>(key: K): PromptMCPConfig[K] {\r\n    return this.config[key];\r\n  }\r\n\r\n  getWithDefault<K extends keyof PromptMCPConfig>(key: K, defaultValue: PromptMCPConfig[K]): PromptMCPConfig[K] {\r\n    return this.config[key] ?? defaultValue;\r\n  }\r\n\r\n  getEnv(key: string, defaultValue: string = ''): string {\r\n    return process.env[key] ?? defaultValue;\r\n  }\r\n\r\n  getNested<K extends keyof PromptMCPConfig, T extends keyof PromptMCPConfig[K]>(\r\n    section: K,\r\n    key: T\r\n  ): PromptMCPConfig[K][T] {\r\n    return this.config[section][key];\r\n  }\r\n\r\n  private loadConfig(): PromptMCPConfig {\r\n    const config: PromptMCPConfig = {\r\n      server: {\r\n        name: process.env.LOCALMCP_NAME || 'localmcp',\r\n        version: process.env.LOCALMCP_VERSION || '1.0.0',\r\n        port: parseInt(process.env.LOCALMCP_PORT || '3000', 10)\r\n      },\r\n      context7: {\r\n        enabled: process.env.CONTEXT7_ENABLED === 'true',\r\n        apiKey: process.env.CONTEXT7_API_KEY || undefined,\r\n        baseUrl: process.env.CONTEXT7_BASE_URL || 'https://api.context7.io',\r\n        cacheEnabled: process.env.CONTEXT7_CACHE_ENABLED !== 'false',\r\n        cacheTtl: parseInt(process.env.CONTEXT7_CACHE_TTL || '3600', 10),\r\n        useHttpOnly: process.env.CONTEXT7_USE_HTTP_ONLY === 'true',\r\n        checkCompatibility: process.env.CONTEXT7_CHECK_COMPATIBILITY !== 'false',\r\n        mcp: {\r\n          enabled: process.env.CONTEXT7_MCP_ENABLED === 'true',\r\n          serverUrl: process.env.CONTEXT7_MCP_URL || 'http://localhost:3001',\r\n          timeout: parseInt(process.env.CONTEXT7_MCP_TIMEOUT || '30000', 10)\r\n        }\r\n      },\r\n      database: {\r\n        type: (process.env.DATABASE_TYPE as 'sqlite' | 'qdrant') || 'sqlite',\r\n        path: process.env.DATABASE_PATH || './data/localmcp.db',\r\n        url: process.env.QDRANT_URL || undefined,\r\n        apiKey: process.env.QDRANT_API_KEY || undefined\r\n      },\r\n      vector: {\r\n        qdrant: {\r\n          url: process.env.QDRANT_URL || 'http://localhost:6333',\r\n          apiKey: process.env.QDRANT_API_KEY || undefined,\r\n          collections: {\r\n            documents: process.env.QDRANT_COLLECTION_DOCUMENTS || 'localmcp_documents',\r\n            lessons: process.env.QDRANT_COLLECTION_LESSONS || 'localmcp_lessons',\r\n            patterns: process.env.QDRANT_COLLECTION_PATTERNS || 'localmcp_patterns'\r\n          }\r\n        }\r\n      },\r\n      openai: {\r\n        apiKey: process.env.OPENAI_API_KEY || undefined,\r\n        projectId: process.env.OPENAI_PROJECT_ID || undefined,\r\n        model: process.env.OPENAI_MODEL || 'gpt-4',\r\n        maxTokens: parseInt(process.env.OPENAI_MAX_TOKENS || '4000', 10),\r\n        temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.3'),\r\n        timeout: parseInt(process.env.OPENAI_TIMEOUT || '60000', 10),\r\n        retries: parseInt(process.env.OPENAI_RETRIES || '3', 10)\r\n      },\r\n      playwright: {\r\n        mcp: {\r\n          enabled: process.env.PLAYWRIGHT_ENABLED === 'true',\r\n          baseUrl: process.env.PLAYWRIGHT_MCP_URL || 'http://localhost:8931',\r\n          timeout: parseInt(process.env.PLAYWRIGHT_TIMEOUT || '30000', 10)\r\n        }\r\n      },\r\n      cache: {\r\n        context7: {\r\n          maxMemoryEntries: parseInt(process.env.CACHE_MAX_MEMORY_ENTRIES || '1000', 10),\r\n          maxMemorySize: parseInt(process.env.CACHE_MAX_MEMORY_SIZE || '52428800', 10), // 50MB\r\n          defaultTtl: parseInt(process.env.CACHE_DEFAULT_TTL || '3600', 10), // 1 hour\r\n          maxTtl: parseInt(process.env.CACHE_MAX_TTL || '86400', 10), // 24 hours\r\n          cleanupInterval: parseInt(process.env.CACHE_CLEANUP_INTERVAL || '300', 10), // 5 minutes\r\n              enablePersistence: process.env.CACHE_ENABLE_PERSISTENCE !== 'false',\r\n              dbPath: process.env.CACHE_DB_PATH || './data/cache/context7.db'\r\n            }\r\n          },\r\n          admin: {\r\n            enabled: process.env.ADMIN_ENABLED === 'true',\r\n            port: parseInt(process.env.ADMIN_PORT || '3001', 10),\r\n            auth: process.env.ADMIN_USERNAME && process.env.ADMIN_PASSWORD ? {\r\n              username: process.env.ADMIN_USERNAME,\r\n              password: process.env.ADMIN_PASSWORD\r\n            } : undefined\r\n          },\r\n          logging: {\r\n            level: (process.env.LOG_LEVEL as 'debug' | 'info' | 'warn' | 'error') || 'info',\r\n            enableConsole: process.env.LOG_CONSOLE !== 'false',\r\n            enableFile: process.env.LOG_FILE === 'true',\r\n            filePath: process.env.LOG_FILE_PATH || './logs/localmcp.log'\r\n          },\r\n      tools: {\r\n        analyze: {\r\n          enabled: process.env.TOOL_ANALYZE_ENABLED !== 'false',\r\n          maxDepth: parseInt(process.env.TOOL_ANALYZE_MAX_DEPTH || '10', 10),\r\n          includeNodeModules: process.env.TOOL_ANALYZE_INCLUDE_NODE_MODULES === 'true'\r\n        },\r\n        create: {\r\n          enabled: process.env.TOOL_CREATE_ENABLED !== 'false',\r\n          defaultFramework: process.env.TOOL_CREATE_DEFAULT_FRAMEWORK || 'react',\r\n          includeTests: process.env.TOOL_CREATE_INCLUDE_TESTS === 'true'\r\n        },\r\n        fix: {\r\n          enabled: process.env.TOOL_FIX_ENABLED !== 'false',\r\n          autoApply: process.env.TOOL_FIX_AUTO_APPLY === 'true',\r\n          backupOriginal: process.env.TOOL_FIX_BACKUP_ORIGINAL !== 'false'\r\n        },\r\n        learn: {\r\n          enabled: process.env.TOOL_LEARN_ENABLED !== 'false',\r\n          storagePath: process.env.TOOL_LEARN_STORAGE_PATH || './data/lessons',\r\n          maxLessons: parseInt(process.env.TOOL_LEARN_MAX_LESSONS || '1000', 10)\r\n        }\r\n      },\r\n      frameworkDetection: {\r\n        enabled: process.env.FRAMEWORK_DETECTION_ENABLED !== 'false',\r\n        confidenceThreshold: parseFloat(process.env.FRAMEWORK_DETECTION_CONFIDENCE_THRESHOLD || '0.3'),\r\n        cacheEnabled: process.env.FRAMEWORK_DETECTION_CACHE_ENABLED !== 'false',\r\n        cacheTTL: parseInt(process.env.FRAMEWORK_DETECTION_CACHE_TTL || '86400', 10), // 24 hours\r\n        aiEnabled: process.env.FRAMEWORK_DETECTION_AI_ENABLED !== 'false',\r\n        patternDetectionEnabled: process.env.FRAMEWORK_DETECTION_PATTERN_ENABLED !== 'false',\r\n        projectContextEnabled: process.env.FRAMEWORK_DETECTION_PROJECT_ENABLED !== 'false',\r\n        maxLibrariesPerDetection: parseInt(process.env.FRAMEWORK_DETECTION_MAX_LIBRARIES || '5', 10),\r\n        aiTimeoutMs: parseInt(process.env.FRAMEWORK_DETECTION_AI_TIMEOUT || '5000', 10)\r\n      },\r\n      promptEnhancement: {\r\n        enabled: process.env.PROMPT_ENHANCEMENT_ENABLED === 'true',\r\n        defaultStrategy: (process.env.PROMPT_ENHANCEMENT_STRATEGY_TYPE as 'general' | 'framework-specific' | 'quality-focused' | 'project-aware') || 'general',\r\n        qualityThreshold: parseFloat(process.env.PROMPT_ENHANCEMENT_QUALITY_THRESHOLD || '0.8'),\r\n        maxTokens: parseInt(process.env.PROMPT_ENHANCEMENT_MAX_TOKENS || '2000', 10),\r\n        temperature: parseFloat(process.env.PROMPT_ENHANCEMENT_TEMPERATURE || '0.3'),\r\n        costLimit: parseFloat(process.env.PROMPT_ENHANCEMENT_COST_LIMIT || '10.0'),\r\n        rateLimit: parseInt(process.env.PROMPT_ENHANCEMENT_RATE_LIMIT || '100', 10),\r\n        fallbackEnabled: process.env.PROMPT_ENHANCEMENT_FALLBACK_ENABLED !== 'false',\r\n        optimization: {\r\n          tokenOptimization: {\r\n            contextTruncation: process.env.PROMPT_ENHANCEMENT_TOKEN_CONTEXT_TRUNCATION !== 'false',\r\n            smartSummarization: process.env.PROMPT_ENHANCEMENT_TOKEN_SMART_SUMMARIZATION !== 'false',\r\n            relevanceFiltering: process.env.PROMPT_ENHANCEMENT_TOKEN_RELEVANCE_FILTERING !== 'false',\r\n            priorityBasedSelection: process.env.PROMPT_ENHANCEMENT_TOKEN_PRIORITY_SELECTION !== 'false'\r\n          },\r\n          qualityOptimization: {\r\n            qualityScoring: process.env.PROMPT_ENHANCEMENT_QUALITY_SCORING !== 'false',\r\n            confidenceThresholds: process.env.PROMPT_ENHANCEMENT_QUALITY_CONFIDENCE_THRESHOLDS !== 'false',\r\n            validationChecks: process.env.PROMPT_ENHANCEMENT_QUALITY_VALIDATION_CHECKS !== 'false',\r\n            feedbackLoop: process.env.PROMPT_ENHANCEMENT_QUALITY_FEEDBACK_LOOP === 'true'\r\n          },\r\n          costOptimization: {\r\n            modelSelection: process.env.PROMPT_ENHANCEMENT_COST_MODEL_SELECTION !== 'false',\r\n            tokenBudgeting: process.env.PROMPT_ENHANCEMENT_COST_TOKEN_BUDGETING !== 'false',\r\n            cacheUtilization: process.env.PROMPT_ENHANCEMENT_COST_CACHE_UTILIZATION !== 'false',\r\n            batchProcessing: process.env.PROMPT_ENHANCEMENT_COST_BATCH_PROCESSING === 'true'\r\n          },\r\n          performanceOptimization: {\r\n            parallelProcessing: process.env.PROMPT_ENHANCEMENT_PERF_PARALLEL_PROCESSING !== 'false',\r\n            caching: process.env.PROMPT_ENHANCEMENT_PERF_CACHING !== 'false',\r\n            responseStreaming: process.env.PROMPT_ENHANCEMENT_PERF_RESPONSE_STREAMING === 'true',\r\n            loadBalancing: process.env.PROMPT_ENHANCEMENT_PERF_LOAD_BALANCING === 'true'\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.logger.info('Configuration loaded', {\r\n      server: config.server.name,\r\n      context7Enabled: config.context7.enabled,\r\n      databaseType: config.database.type,\r\n      logLevel: config.logging.level\r\n    });\r\n\r\n    return config;\r\n  }\r\n\r\n  private validateConfig(): void {\r\n    const errors: string[] = [];\r\n\r\n    // Validate server config\r\n    if (!this.config.server.name) {\r\n      errors.push('Server name is required');\r\n    }\r\n    if (this.config.server.port < 1 || this.config.server.port > 65535) {\r\n      errors.push('Server port must be between 1 and 65535');\r\n    }\r\n\r\n    // Validate Context7 config\r\n    if (this.config.context7.enabled && !this.config.context7.apiKey) {\r\n      errors.push('Context7 API key is required when Context7 is enabled');\r\n    }\r\n\r\n    // Validate database config\r\n    if (this.config.database.type === 'qdrant') {\r\n      if (!this.config.database.url) {\r\n        errors.push('Qdrant URL is required when using Qdrant database');\r\n      }\r\n    }\r\n\r\n    // Validate logging config\r\n    const validLogLevels = ['debug', 'info', 'warn', 'error'];\r\n    if (!validLogLevels.includes(this.config.logging.level)) {\r\n      errors.push(`Log level must be one of: ${validLogLevels.join(', ')}`);\r\n    }\r\n\r\n    // Validate tools config\r\n    if (this.config.tools.analyze.maxDepth < 1) {\r\n      errors.push('Analyze max depth must be at least 1');\r\n    }\r\n    if (this.config.tools.learn.maxLessons < 1) {\r\n      errors.push('Learn max lessons must be at least 1');\r\n    }\r\n\r\n    // Validate framework detection config\r\n    if (this.config.frameworkDetection.confidenceThreshold < 0 || this.config.frameworkDetection.confidenceThreshold > 1) {\r\n      errors.push('Framework detection confidence threshold must be between 0 and 1');\r\n    }\r\n    if (this.config.frameworkDetection.cacheTTL < 1) {\r\n      errors.push('Framework detection cache TTL must be at least 1 second');\r\n    }\r\n    if (this.config.frameworkDetection.maxLibrariesPerDetection < 1) {\r\n      errors.push('Framework detection max libraries must be at least 1');\r\n    }\r\n    if (this.config.frameworkDetection.aiTimeoutMs < 1000) {\r\n      errors.push('Framework detection AI timeout must be at least 1000ms');\r\n    }\r\n\r\n    // Validate prompt enhancement config\r\n    if (this.config.promptEnhancement.enabled) {\r\n      const validStrategies = ['general', 'framework-specific', 'quality-focused', 'project-aware'];\r\n      if (!validStrategies.includes(this.config.promptEnhancement.defaultStrategy)) {\r\n        errors.push(`Prompt enhancement default strategy must be one of: ${validStrategies.join(', ')}`);\r\n      }\r\n      if (this.config.promptEnhancement.qualityThreshold < 0 || this.config.promptEnhancement.qualityThreshold > 1) {\r\n        errors.push('Prompt enhancement quality threshold must be between 0 and 1');\r\n      }\r\n      if (this.config.promptEnhancement.maxTokens < 100 || this.config.promptEnhancement.maxTokens > 8000) {\r\n        errors.push('Prompt enhancement max tokens must be between 100 and 8000');\r\n      }\r\n      if (this.config.promptEnhancement.temperature < 0 || this.config.promptEnhancement.temperature > 2) {\r\n        errors.push('Prompt enhancement temperature must be between 0 and 2');\r\n      }\r\n      if (this.config.promptEnhancement.costLimit < 0) {\r\n        errors.push('Prompt enhancement cost limit must be non-negative');\r\n      }\r\n      if (this.config.promptEnhancement.rateLimit < 0) {\r\n        errors.push('Prompt enhancement rate limit must be non-negative');\r\n      }\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n      this.logger.error('Configuration validation failed', { errors });\r\n      throw new Error(`Configuration validation failed: ${errors.join(', ')}`);\r\n    }\r\n\r\n    this.logger.info('Configuration validation passed');\r\n  }\r\n\r\n  // Helper methods for common config access patterns\r\n  isContext7Enabled(): boolean {\r\n    return this.config.context7.enabled;\r\n  }\r\n\r\n  isToolEnabled(tool: keyof PromptMCPConfig['tools']): boolean {\r\n    return this.config.tools[tool].enabled;\r\n  }\r\n\r\n  getLogLevel(): 'debug' | 'info' | 'warn' | 'error' {\r\n    return this.config.logging.level;\r\n  }\r\n\r\n  getDatabaseConfig() {\r\n    return this.config.database;\r\n  }\r\n\r\n  getContext7Config() {\r\n    return this.config.context7;\r\n  }\r\n\r\n  getFrameworkDetectionConfig() {\r\n    return this.config.frameworkDetection;\r\n  }\r\n\r\n  getPromptEnhancementConfig() {\r\n    return this.config.promptEnhancement;\r\n  }\r\n\r\n  isPromptEnhancementEnabled(): boolean {\r\n    return this.config.promptEnhancement.enabled;\r\n  }\r\n}",
        "File: src/services/ai/ai-library-suggestion.service.ts\nDescription: Class definition: AILibrarySuggestionService\nCode:\nexport class AILibrarySuggestionService {\r\n  private config: AILibrarySuggestionConfig;\r\n  private aiService: any; // Will be injected\r\n\r\n  constructor(aiService: any, config?: Partial<AILibrarySuggestionConfig>) {\r\n    this.aiService = aiService;\r\n    this.config = {\r\n      enabled: true,\r\n      timeoutMs: 5000,\r\n      maxSuggestions: 5,\r\n      confidenceThreshold: 0.7,\r\n      ...config\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Suggest libraries using AI analysis\r\n   */\r\n  async suggestLibraries(prompt: string): Promise<LibrarySuggestion[]> {\r\n    if (!this.config.enabled || !this.aiService) {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const analysisPrompt = this.buildAnalysisPrompt(prompt);\r\n      \r\n      const response = await Promise.race([\r\n        this.aiService.analyze(analysisPrompt),\r\n        this.createTimeoutPromise(this.config.timeoutMs)\r\n      ]);\r\n\r\n      return this.parseLibrarySuggestions(response);\r\n    } catch (error) {\r\n      console.warn('AI library suggestion failed', { error, prompt: prompt.substring(0, 100) });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Build analysis prompt for AI\r\n   */\r\n  private buildAnalysisPrompt(prompt: string): string {\r\n    return `\r\nAnalyze this development prompt and suggest ${this.config.maxSuggestions} most relevant library/framework names that would provide useful documentation:\r\n\r\nPrompt: \"${prompt}\"\r\n\r\nRequirements:\r\n- Return only library names, one per line\r\n- Focus on frameworks, UI libraries, and development tools\r\n- Be specific (e.g., \"react\" not \"javascript framework\")\r\n- Consider the context and technology stack\r\n- Prioritize popular, well-documented libraries\r\n- Include confidence score (0-1) and reason for each suggestion\r\n\r\nFormat each suggestion as:\r\nname|confidence|reason|category\r\n\r\nExamples:\r\n- For component creation -> [library]|0.9|[reason]|framework\r\n- For web application -> [library]|0.8|[reason]|framework\r\n- For styling needs -> [library]|0.9|[reason]|library\r\n- For API development -> [library]|0.8|[reason]|framework\r\n- For testing requirements -> [library]|0.9|[reason]|tool\r\n\r\nCategories: framework, library, tool, language\r\n    `.trim();\r\n  }\r\n\r\n  /**\r\n   * Parse AI response into structured suggestions\r\n   */\r\n  private parseLibrarySuggestions(response: string): LibrarySuggestion[] {\r\n    const suggestions: LibrarySuggestion[] = [];\r\n    \r\n    const lines = response.split('\\n')\r\n      .map(line => line.trim())\r\n      .filter(line => line.length > 0 && !line.startsWith('#'))\r\n      .slice(0, this.config.maxSuggestions);\r\n\r\n    for (const line of lines) {\r\n      try {\r\n        const parts = line.split('|');\r\n        if (parts.length >= 4) {\r\n          const [name, confidenceStr, reason, category] = parts;\r\n          const confidence = parseFloat(confidenceStr || '0.5') || 0.5;\r\n          \r\n          if (name && this.isValidLibraryName(name) && confidence >= this.config.confidenceThreshold) {\r\n            suggestions.push({\r\n              name: name.toLowerCase().trim(),\r\n              confidence,\r\n              reason: (reason || '').trim(),\r\n              category: this.validateCategory((category || '').trim())\r\n            });\r\n          }\r\n        } else {\r\n          // Fallback parsing for simple format\r\n          const name = line.replace(/^[-*]\\s*/, '').toLowerCase().trim();\r\n          if (this.isValidLibraryName(name)) {\r\n            suggestions.push({\r\n              name,\r\n              confidence: 0.8,\r\n              reason: 'AI suggested',\r\n              category: 'library'\r\n            });\r\n          }\r\n        }\r\n      } catch (error) {\r\n        console.warn('Failed to parse suggestion line', { line, error });\r\n      }\r\n    }\r\n\r\n    return suggestions;\r\n  }\r\n\r\n  /**\r\n   * Validate library name\r\n   */\r\n  private isValidLibraryName(name: string): boolean {\r\n    const commonWords = [\r\n      'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by',\r\n      'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does', 'did',\r\n      'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'cannot', 'cant'\r\n    ];\r\n    \r\n    return name.length > 2 && \r\n           !commonWords.includes(name) && \r\n           /^[a-z0-9-]+$/.test(name) &&\r\n           !name.includes(' ') &&\r\n           !name.includes('.');\r\n  }\r\n\r\n  /**\r\n   * Validate category\r\n   */\r\n  private validateCategory(category: string): 'framework' | 'library' | 'tool' | 'language' {\r\n    const validCategories = ['framework', 'library', 'tool', 'language'];\r\n    return validCategories.includes(category.toLowerCase()) ? \r\n      category.toLowerCase() as any : 'library';\r\n  }\r\n\r\n  /**\r\n   * Create timeout promise\r\n   */\r\n  private createTimeoutPromise(timeoutMs: number): Promise<never> {\r\n    return new Promise((_, reject) => {\r\n      setTimeout(() => reject(new Error('AI suggestion timeout')), timeoutMs);\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get service configuration\r\n   */\r\n  getConfig(): AILibrarySuggestionConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Update service configuration\r\n   */\r\n  updateConfig(newConfig: Partial<AILibrarySuggestionConfig>): void {\r\n    this.config = { ...this.config, ...newConfig };\r\n  }\r\n\r\n  /**\r\n   * Check if service is enabled\r\n   */\r\n  isEnabled(): boolean {\r\n    return this.config.enabled && !!this.aiService;\r\n  }\r\n}\r",
        "File: src/services/ai/context7-curation.service.ts\nDescription: Class definition: Context7CurationService\nCode:\nexport class Context7CurationService {\r\n  private logger: Logger;\r\n  private openaiService: OpenAIService;\r\n  private config: CurationConfig;\r\n\r\n  constructor(logger: Logger, openaiService: OpenAIService, config: CurationConfig) {\r\n    this.logger = logger;\r\n    this.openaiService = openaiService;\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Curate Context7 content for Cursor AI code generation\r\n   */\r\n  async curateForCursor(\r\n    context7Content: string,\r\n    libraryId: string,\r\n    prompt: string,\r\n    projectContext: any\r\n  ): Promise<CuratedContent> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      this.logger.debug('Starting Context7 content curation', {\r\n        libraryId,\r\n        originalLength: context7Content.length,\r\n        prompt: prompt.substring(0, 100) + '...'\r\n      });\r\n\r\n      // 1. Assess content quality\r\n      const qualityScore = await this.assessContentQuality(context7Content, prompt);\r\n      \r\n      // 2. If quality is too low, return original content\r\n      if (qualityScore < this.config.minQualityScore) {\r\n        this.logger.warn('Content quality too low, returning original', {\r\n          libraryId,\r\n          qualityScore,\r\n          minRequired: this.config.minQualityScore\r\n        });\r\n        \r\n        return this.createFallbackContent(context7Content, libraryId, startTime);\r\n      }\r\n\r\n      // 3. Extract key components\r\n      const keyComponents = await this.extractKeyComponents(context7Content, prompt, libraryId);\r\n      \r\n      // 4. Optimize tokens while preserving quality\r\n      const curatedContent = await this.optimizeTokens(\r\n        context7Content,\r\n        keyComponents,\r\n        prompt,\r\n        libraryId\r\n      );\r\n\r\n      // 5. Calculate metrics\r\n      const originalTokens = Math.ceil(context7Content.length / 4);\r\n      const curatedTokens = Math.ceil(curatedContent.length / 4);\r\n      const tokenReduction = 1 - (curatedTokens / originalTokens);\r\n\r\n      const result: CuratedContent = {\r\n        originalContent: context7Content,\r\n        curatedContent,\r\n        qualityScore,\r\n        tokenReduction,\r\n        cursorOptimized: true,\r\n        keyPatterns: keyComponents.patterns,\r\n        bestPractices: keyComponents.bestPractices,\r\n        codeExamples: keyComponents.codeExamples,\r\n        metadata: {\r\n          libraryId,\r\n          originalTokens,\r\n          curatedTokens,\r\n          processingTime: Date.now() - startTime,\r\n          confidence: qualityScore / 10\r\n        }\r\n      };\r\n\r\n      this.logger.info('Content curation completed successfully', {\r\n        libraryId,\r\n        qualityScore,\r\n        tokenReduction: `${(tokenReduction * 100).toFixed(1)}%`,\r\n        processingTime: result.metadata.processingTime\r\n      });\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      this.logger.error('Content curation failed', {\r\n        libraryId,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      \r\n      // Return original content as fallback\r\n      return this.createFallbackContent(context7Content, libraryId, startTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assess content quality for coding tasks\r\n   */\r\n  private async assessContentQuality(docContent: string, prompt: string): Promise<number> {\r\n    try {\r\n      const response = await this.openaiService.createChatCompletion([\r\n          {\r\n            role: 'system',\r\n            content: `You are a content quality assessor for AI code generation. Rate documentation content on a scale of 1-10 based on:\r\n\r\n1. Code Examples (30%): Presence of practical, runnable code snippets\r\n2. Best Practices (25%): Clear patterns, conventions, and guidelines\r\n3. Relevance (25%): How well it matches the user's coding intent\r\n4. Completeness (20%): Essential information coverage\r\n\r\nReturn ONLY a JSON object with this exact structure:\r\n{\r\n  \"score\": 8.5,\r\n  \"reasoning\": \"Brief explanation of the score\",\r\n  \"strengths\": [\"list\", \"of\", \"strengths\"],\r\n  \"weaknesses\": [\"list\", \"of\", \"weaknesses\"]\r\n}`\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `User Prompt: ${prompt}\r\n\r\nDocumentation Content:\r\n${docContent.substring(0, 2000)}...\r\n\r\nRate this content for AI code generation quality.`\r\n          }\r\n        ], {\r\n        temperature: 0.1,\r\n        maxTokens: 300\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) throw new Error('No response from OpenAI');\r\n\r\n      const parsed = JSON.parse(content);\r\n      return Math.min(10, Math.max(1, parsed.score || 5));\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Quality assessment failed, using default score', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      return 5.0; // Default moderate score\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract key components from content\r\n   */\r\n  private async extractKeyComponents(\r\n    docContent: string,\r\n    prompt: string,\r\n    libraryId: string\r\n  ): Promise<{\r\n    patterns: string[];\r\n    bestPractices: string[];\r\n    codeExamples: string[];\r\n  }> {\r\n    try {\r\n      const response = await this.openaiService.createChatCompletion([\r\n          {\r\n            role: 'system',\r\n            content: `You are a technical content analyzer. Extract key components from documentation for AI code generation.\r\n\r\nReturn ONLY a JSON object with this exact structure:\r\n{\r\n  \"patterns\": [\"pattern1\", \"pattern2\", \"pattern3\"],\r\n  \"bestPractices\": [\"practice1\", \"practice2\", \"practice3\"],\r\n  \"codeExamples\": [\"example1\", \"example2\", \"example3\"]\r\n}\r\n\r\nFocus on:\r\n- Patterns: Common coding patterns and conventions\r\n- Best Practices: Guidelines and recommendations\r\n- Code Examples: Practical, runnable code snippets`\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `Library: ${libraryId}\r\nUser Prompt: ${prompt}\r\n\r\nContent:\r\n${docContent.substring(0, 3000)}...\r\n\r\nExtract key components for AI code generation.`\r\n          }\r\n        ], {\r\n        temperature: 0.2,\r\n        maxTokens: 500\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) throw new Error('No response from OpenAI');\r\n\r\n      const parsed = JSON.parse(content);\r\n      return {\r\n        patterns: parsed.patterns || [],\r\n        bestPractices: parsed.bestPractices || [],\r\n        codeExamples: parsed.codeExamples || []\r\n      };\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Key component extraction failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      \r\n      return {\r\n        patterns: [],\r\n        bestPractices: [],\r\n        codeExamples: []\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimize tokens while preserving quality\r\n   */\r\n  private async optimizeTokens(\r\n    content: string,\r\n    keyComponents: any,\r\n    prompt: string,\r\n    libraryId: string\r\n  ): Promise<string> {\r\n    try {\r\n      const targetTokens = Math.ceil(content.length / 4 * (1 - this.config.targetTokenReduction));\r\n      \r\n      const response = await this.openaiService.createChatCompletion([\r\n          {\r\n            role: 'system',\r\n            content: `You are a technical content optimizer for AI code generation. Create a concise, high-quality summary that:\r\n\r\n1. Preserves all essential information for coding\r\n2. Keeps all code examples and patterns\r\n3. Maintains best practices and guidelines\r\n4. Removes boilerplate and marketing content\r\n5. Focuses on practical, actionable information\r\n6. Optimizes for Cursor AI code generation\r\n\r\nTarget length: ~${targetTokens} tokens\r\nFormat: Clean, structured, code-focused content`\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `Library: ${libraryId}\r\nUser Prompt: ${prompt}\r\n\r\nKey Components:\r\n- Patterns: ${keyComponents.patterns.join(', ')}\r\n- Best Practices: ${keyComponents.bestPractices.join(', ')}\r\n- Code Examples: ${keyComponents.codeExamples.length} examples\r\n\r\nOriginal Content:\r\n${content}\r\n\r\nCreate an optimized version for AI code generation.`\r\n          }\r\n        ], {\r\n        temperature: 0.1,\r\n        maxTokens: Math.min(4000, targetTokens * 2)\r\n      });\r\n\r\n      const curatedContent = response.choices[0]?.message?.content;\r\n      if (!curatedContent) throw new Error('No response from OpenAI');\r\n\r\n      return curatedContent;\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Token optimization failed, using original content', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      return content;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create fallback content when curation fails\r\n   */\r\n  private createFallbackContent(\r\n    originalContent: string,\r\n    libraryId: string,\r\n    startTime: number\r\n  ): CuratedContent {\r\n    const originalTokens = Math.ceil(originalContent.length / 4);\r\n    \r\n    return {\r\n      originalContent,\r\n      curatedContent: originalContent,\r\n      qualityScore: 5.0,\r\n      tokenReduction: 0,\r\n      cursorOptimized: false,\r\n      keyPatterns: [],\r\n      bestPractices: [],\r\n      codeExamples: [],\r\n      metadata: {\r\n        libraryId,\r\n        originalTokens,\r\n        curatedTokens: originalTokens,\r\n        processingTime: Date.now() - startTime,\r\n        confidence: 0.5\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Test the curation service\r\n   */\r\n  async testCuration(): Promise<boolean> {\r\n    try {\r\n      const testContent = `\r\n# React Documentation\r\n\r\nReact is a JavaScript library for building user interfaces.\r\n\r\n## Getting Started\r\n\r\n\\`\\`\\`jsx\r\nimport React from 'react';\r\n\r\nfunction App() {\r\n  return <h1>Hello World</h1>;\r\n}\r\n\\`\\`\\`\r\n\r\n## Best Practices\r\n\r\n- Use functional components with hooks\r\n- Keep components small and focused\r\n- Use TypeScript for better development experience\r\n`;\r\n\r\n      const result = await this.curateForCursor(\r\n        testContent,\r\n        '/facebook/react',\r\n        'Create a React component',\r\n        {}\r\n      );\r\n\r\n      return result.qualityScore > 0 && result.curatedContent.length > 0;\r\n\r\n    } catch (error) {\r\n      this.logger.error('Curation test failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n}\r",
        "File: src/services/ai/prompt-enhancement-agent.service.ts\nDescription: Class definition: PromptEnhancementAgentService\nCode:\nexport class PromptEnhancementAgentService {\r\n  private logger: Logger;\r\n  private openAIService: OpenAIService;\r\n  private responseBuilderService: ResponseBuilderService;\r\n  private config: EnhancementAgentConfig;\r\n  private metrics: EnhancementMetrics;\r\n\r\n  constructor(\r\n    logger: Logger,\r\n    openAIService: OpenAIService,\r\n    responseBuilderService: ResponseBuilderService,\r\n    config: EnhancementAgentConfig\r\n  ) {\r\n    this.logger = logger;\r\n    this.openAIService = openAIService;\r\n    this.responseBuilderService = responseBuilderService;\r\n    this.config = config;\r\n    this.metrics = this.initializeMetrics();\r\n  }\r\n\r\n  /**\r\n   * Main enhancement method - orchestrates the entire enhancement pipeline\r\n   */\r\n  async enhancePrompt(\r\n    originalPrompt: string,\r\n    context: EnhancementContext,\r\n    options?: Partial<EnhancementOptions>\r\n  ): Promise<PromptEnhancementResponse> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      this.logger.debug('Starting prompt enhancement', {\r\n        originalPrompt: originalPrompt.substring(0, 100) + '...',\r\n        contextSize: JSON.stringify(context).length,\r\n        options: options || 'default'\r\n      });\r\n\r\n      // Validate input\r\n      const validation = this.validateEnhancementRequest(originalPrompt, context, options);\r\n      if (!validation.isValid) {\r\n        throw new Error(`Enhancement validation failed: ${validation.errors.join(', ')}`);\r\n      }\r\n\r\n      // Create enhancement request\r\n      const request = this.createEnhancementRequest(originalPrompt, context, options);\r\n      \r\n      // Apply enhancement strategy\r\n      const strategy = this.selectEnhancementStrategy(context, options);\r\n      request.options.strategy = strategy;\r\n\r\n      // Enhance prompt using OpenAI\r\n      const enhancement = await this.openAIService.enhancePromptWithContext(request);\r\n      \r\n      // Validate enhancement quality\r\n      const qualityValidation = this.validateEnhancementQuality(enhancement);\r\n      if (!qualityValidation.isValid) {\r\n        this.logger.warn('Enhancement quality below threshold', {\r\n          qualityScore: enhancement.quality.overall,\r\n          threshold: this.config.qualityThreshold,\r\n          warnings: qualityValidation.warnings\r\n        });\r\n      }\r\n\r\n      // Update metrics\r\n      const processingTime = Date.now() - startTime;\r\n      this.updateMetrics(enhancement, processingTime, true);\r\n\r\n      this.logger.info('Prompt enhancement completed successfully', {\r\n        originalLength: originalPrompt.length,\r\n        enhancedLength: enhancement.enhancedPrompt.length,\r\n        qualityScore: enhancement.quality.overall,\r\n        confidenceScore: enhancement.confidence.overall,\r\n        processingTime\r\n      });\r\n\r\n      return enhancement;\r\n\r\n    } catch (error) {\r\n      const processingTime = Date.now() - startTime;\r\n      this.updateMetrics(null, processingTime, false);\r\n      \r\n      this.logger.error('Prompt enhancement failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        originalPrompt: originalPrompt.substring(0, 100) + '...',\r\n        processingTime\r\n      });\r\n\r\n      // Return fallback if enabled\r\n      if (this.config.fallbackEnabled) {\r\n        return this.createFallbackEnhancement(originalPrompt, context);\r\n      }\r\n\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enhance prompt with context-aware strategy selection\r\n   */\r\n  async enhancePromptWithStrategy(\r\n    originalPrompt: string,\r\n    context: EnhancementContext,\r\n    strategyType: 'general' | 'framework-specific' | 'quality-focused' | 'project-aware',\r\n    strategyOptions?: Partial<EnhancementStrategy>\r\n  ): Promise<PromptEnhancementResponse> {\r\n    const strategy: EnhancementStrategy = {\r\n      type: strategyType,\r\n      focus: strategyOptions?.focus || ['clarity', 'actionability'],\r\n      approach: strategyOptions?.approach || 'comprehensive',\r\n      priority: strategyOptions?.priority || 'quality'\r\n    };\r\n\r\n    const options: Partial<EnhancementOptions> = {\r\n      strategy,\r\n      ...strategyOptions\r\n    };\r\n\r\n    return this.enhancePrompt(originalPrompt, context, options);\r\n  }\r\n\r\n  /**\r\n   * Enhance prompt with framework-specific strategy\r\n   */\r\n  async enhancePromptForFramework(\r\n    originalPrompt: string,\r\n    context: EnhancementContext,\r\n    framework: string,\r\n    version?: string\r\n  ): Promise<PromptEnhancementResponse> {\r\n    const frameworkContext: FrameworkContext = {\r\n      ...context.frameworkContext,\r\n      framework,\r\n      version: version || 'Unknown'\r\n    };\r\n\r\n    const enhancedContext: EnhancementContext = {\r\n      ...context,\r\n      frameworkContext\r\n    };\r\n\r\n    return this.enhancePromptWithStrategy(\r\n      originalPrompt,\r\n      enhancedContext,\r\n      'framework-specific'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Enhance prompt with quality-focused strategy\r\n   */\r\n  async enhancePromptForQuality(\r\n    originalPrompt: string,\r\n    context: EnhancementContext,\r\n    qualityFocus: string[]\r\n  ): Promise<PromptEnhancementResponse> {\r\n    const qualityRequirements: QualityRequirements = {\r\n      accessibility: qualityFocus.includes('accessibility'),\r\n      performance: qualityFocus.includes('performance'),\r\n      security: qualityFocus.includes('security'),\r\n      testing: qualityFocus.includes('testing'),\r\n      documentation: qualityFocus.includes('documentation'),\r\n      maintainability: qualityFocus.includes('maintainability'),\r\n      scalability: qualityFocus.includes('scalability'),\r\n      userExperience: qualityFocus.includes('userExperience')\r\n    };\r\n\r\n    const enhancedContext: EnhancementContext = {\r\n      ...context,\r\n      qualityRequirements\r\n    };\r\n\r\n    return this.enhancePromptWithStrategy(\r\n      originalPrompt,\r\n      enhancedContext,\r\n      'quality-focused'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Enhance prompt with project-aware strategy\r\n   */\r\n  async enhancePromptForProject(\r\n    originalPrompt: string,\r\n    context: EnhancementContext,\r\n    projectType: 'frontend' | 'backend' | 'fullstack' | 'library' | 'mobile' | 'desktop' | 'cli' | 'other'\r\n  ): Promise<PromptEnhancementResponse> {\r\n    const projectContext: ProjectContext = {\r\n      ...context.projectContext,\r\n      projectType\r\n    };\r\n\r\n    const enhancedContext: EnhancementContext = {\r\n      ...context,\r\n      projectContext\r\n    };\r\n\r\n    return this.enhancePromptWithStrategy(\r\n      originalPrompt,\r\n      enhancedContext,\r\n      'project-aware'\r\n    );\r\n  }\r\n\r\n  /**\r\n   * Get enhancement metrics\r\n   */\r\n  getMetrics(): EnhancementMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  /**\r\n   * Reset enhancement metrics\r\n   */\r\n  resetMetrics(): void {\r\n    this.metrics = this.initializeMetrics();\r\n  }\r\n\r\n  /**\r\n   * Update enhancement configuration\r\n   */\r\n  updateConfig(config: Partial<EnhancementAgentConfig>): void {\r\n    this.config = { ...this.config, ...config };\r\n    this.logger.info('Enhancement configuration updated', { config });\r\n  }\r\n\r\n  /**\r\n   * Validate enhancement request\r\n   */\r\n  private validateEnhancementRequest(\r\n    originalPrompt: string,\r\n    context: EnhancementContext,\r\n    options?: Partial<EnhancementOptions>\r\n  ): EnhancementValidationResult {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n    const suggestions: string[] = [];\r\n\r\n    // Validate original prompt\r\n    if (!originalPrompt || originalPrompt.trim().length === 0) {\r\n      errors.push('Original prompt is required and cannot be empty');\r\n    }\r\n\r\n    if (originalPrompt.length > 10000) {\r\n      warnings.push('Original prompt is very long, consider shortening for better results');\r\n    }\r\n\r\n    // Validate context\r\n    if (!context.projectContext) {\r\n      warnings.push('Project context is missing, enhancement may be less accurate');\r\n    }\r\n\r\n    if (!context.frameworkContext) {\r\n      warnings.push('Framework context is missing, enhancement may be less accurate');\r\n    }\r\n\r\n    // Validate options\r\n    if (options?.maxTokens && options.maxTokens > 4000) {\r\n      warnings.push('Max tokens is very high, consider reducing for cost optimization');\r\n    }\r\n\r\n    if (options?.temperature && (options.temperature < 0 || options.temperature > 2)) {\r\n      errors.push('Temperature must be between 0 and 2');\r\n    }\r\n\r\n    // Check cost limits\r\n    if (this.config.costLimit > 0) {\r\n      const estimatedCost = this.estimateEnhancementCost(originalPrompt, context, options);\r\n      if (estimatedCost > this.config.costLimit) {\r\n        warnings.push(`Estimated cost ($${estimatedCost.toFixed(4)}) exceeds limit ($${this.config.costLimit})`);\r\n      }\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n      suggestions\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create enhancement request from parameters\r\n   */\r\n  private createEnhancementRequest(\r\n    originalPrompt: string,\r\n    context: EnhancementContext,\r\n    options?: Partial<EnhancementOptions>\r\n  ): PromptEnhancementRequest {\r\n    const defaultOptions: EnhancementOptions = {\r\n      strategy: this.config.defaultStrategy,\r\n      qualityThreshold: this.config.qualityThreshold,\r\n      maxTokens: this.config.maxTokens,\r\n      temperature: this.config.temperature,\r\n      includeExamples: true,\r\n      includeBestPractices: true,\r\n      includeAntiPatterns: false,\r\n      includePerformanceTips: true,\r\n      includeSecurityConsiderations: true,\r\n      includeTestingApproaches: true\r\n    };\r\n\r\n    const enhancementOptions = { ...defaultOptions, ...options };\r\n\r\n    const goals: EnhancementGoals = {\r\n      primary: 'Enhance prompt clarity and actionability',\r\n      secondary: [\r\n        'Integrate framework-specific best practices',\r\n        'Apply quality requirements',\r\n        'Provide specific implementation guidance'\r\n      ],\r\n      constraints: [\r\n        'Maintain original intent',\r\n        'Use appropriate technical terminology',\r\n        'Ensure implementable solutions'\r\n      ],\r\n      successCriteria: [\r\n        'Enhanced prompt is more specific than original',\r\n        'Includes relevant technical context',\r\n        'Provides clear implementation steps'\r\n      ],\r\n      expectedOutcome: 'A more actionable and context-aware prompt that leads to better implementation results'\r\n    };\r\n\r\n    return {\r\n      originalPrompt,\r\n      context,\r\n      options: enhancementOptions,\r\n      goals\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Select enhancement strategy based on context\r\n   */\r\n  private selectEnhancementStrategy(\r\n    context: EnhancementContext,\r\n    options?: Partial<EnhancementOptions>\r\n  ): EnhancementStrategy {\r\n    if (options?.strategy) {\r\n      return options.strategy;\r\n    }\r\n\r\n    // Framework-specific strategy\r\n    if (context.frameworkContext?.framework && context.frameworkContext.framework !== 'Unknown') {\r\n      return {\r\n        type: 'framework-specific',\r\n        focus: ['clarity', 'actionability', 'best-practices'],\r\n        approach: 'framework-optimized',\r\n        priority: 'quality'\r\n      };\r\n    }\r\n\r\n    // Quality-focused strategy\r\n    const qualityRequirements = context.qualityRequirements;\r\n    if (qualityRequirements && Object.values(qualityRequirements).some(req => req)) {\r\n      return {\r\n        type: 'quality-focused',\r\n        focus: ['quality', 'best-practices', 'standards'],\r\n        approach: 'quality-optimized',\r\n        priority: 'quality'\r\n      };\r\n    }\r\n\r\n    // Project-aware strategy\r\n    if (context.projectContext?.projectType && context.projectContext.projectType !== 'other') {\r\n      return {\r\n        type: 'project-aware',\r\n        focus: ['clarity', 'actionability', 'project-context'],\r\n        approach: 'project-optimized',\r\n        priority: 'quality'\r\n      };\r\n    }\r\n\r\n    // Default general strategy\r\n    return this.config.defaultStrategy;\r\n  }\r\n\r\n  /**\r\n   * Validate enhancement quality\r\n   */\r\n  private validateEnhancementQuality(enhancement: PromptEnhancementResponse): EnhancementValidationResult {\r\n    const errors: string[] = [];\r\n    const warnings: string[] = [];\r\n    const suggestions: string[] = [];\r\n\r\n    // Check quality score\r\n    if (enhancement.quality.overall < this.config.qualityThreshold) {\r\n      warnings.push(`Quality score (${enhancement.quality.overall}) is below threshold (${this.config.qualityThreshold})`);\r\n    }\r\n\r\n    // Check confidence score\r\n    if (enhancement.confidence.overall < 0.7) {\r\n      warnings.push(`Confidence score (${enhancement.confidence.overall}) is low`);\r\n    }\r\n\r\n    // Check if enhancement is actually better\r\n    if (enhancement.metadata.enhancedLength < enhancement.metadata.originalLength * 0.5) {\r\n      warnings.push('Enhanced prompt is significantly shorter than original');\r\n    }\r\n\r\n    // Check for improvements\r\n    if (enhancement.improvements.length === 0) {\r\n      warnings.push('No improvements were identified in the enhancement');\r\n    }\r\n\r\n    return {\r\n      isValid: errors.length === 0,\r\n      errors,\r\n      warnings,\r\n      suggestions\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Create fallback enhancement when AI enhancement fails\r\n   */\r\n  private createFallbackEnhancement(\r\n    originalPrompt: string,\r\n    context: EnhancementContext\r\n  ): PromptEnhancementResponse {\r\n    this.logger.warn('Creating fallback enhancement', {\r\n      originalPrompt: originalPrompt.substring(0, 100) + '...'\r\n    });\r\n\r\n    // Simple fallback - just add basic context\r\n    let enhancedPrompt = originalPrompt;\r\n    \r\n    if (context.frameworkContext?.framework) {\r\n      enhancedPrompt += `\\n\\nFramework: ${context.frameworkContext.framework}`;\r\n    }\r\n    \r\n    if (context.projectContext?.projectType) {\r\n      enhancedPrompt += `\\nProject Type: ${context.projectContext.projectType}`;\r\n    }\r\n\r\n    return {\r\n      enhancedPrompt,\r\n      metadata: {\r\n        originalLength: originalPrompt.length,\r\n        enhancedLength: enhancedPrompt.length,\r\n        tokenUsage: {\r\n          promptTokens: 0,\r\n          completionTokens: 0,\r\n          totalTokens: 0,\r\n          cost: 0,\r\n          model: 'fallback'\r\n        },\r\n        processingTime: 0,\r\n        strategy: { type: 'general', focus: [], approach: 'fallback', priority: 'speed' },\r\n        framework: context.frameworkContext?.framework || 'Unknown',\r\n        projectType: context.projectContext?.projectType || 'Unknown',\r\n        timestamp: new Date()\r\n      },\r\n      quality: {\r\n        clarity: 0.6,\r\n        specificity: 0.6,\r\n        actionability: 0.6,\r\n        completeness: 0.6,\r\n        relevance: 0.6,\r\n        overall: 0.6\r\n      },\r\n      confidence: {\r\n        overall: 0.5,\r\n        contextRelevance: 0.5,\r\n        frameworkAccuracy: 0.5,\r\n        qualityAlignment: 0.5,\r\n        projectFit: 0.5\r\n      },\r\n      improvements: [],\r\n      recommendations: ['Consider using AI enhancement for better results']\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Estimate enhancement cost\r\n   */\r\n  private estimateEnhancementCost(\r\n    originalPrompt: string,\r\n    context: EnhancementContext,\r\n    options?: Partial<EnhancementOptions>\r\n  ): number {\r\n    const maxTokens = options?.maxTokens || this.config.maxTokens;\r\n    const model = 'gpt-4'; // Default model\r\n    \r\n    // Rough cost estimation (this should be more sophisticated in production)\r\n    const estimatedTokens = Math.min(maxTokens, 2000);\r\n    const costPerToken = 0.03 / 1000; // GPT-4 input cost\r\n    \r\n    return estimatedTokens * costPerToken;\r\n  }\r\n\r\n  /**\r\n   * Update enhancement metrics\r\n   */\r\n  private updateMetrics(\r\n    enhancement: PromptEnhancementResponse | null,\r\n    processingTime: number,\r\n    success: boolean\r\n  ): void {\r\n    this.metrics.totalEnhancements++;\r\n    \r\n    if (success && enhancement) {\r\n      this.metrics.successfulEnhancements++;\r\n      this.metrics.averageQualityScore = \r\n        (this.metrics.averageQualityScore * (this.metrics.successfulEnhancements - 1) + enhancement.quality.overall) / \r\n        this.metrics.successfulEnhancements;\r\n      this.metrics.averageConfidenceScore = \r\n        (this.metrics.averageConfidenceScore * (this.metrics.successfulEnhancements - 1) + enhancement.confidence.overall) / \r\n        this.metrics.successfulEnhancements;\r\n      this.metrics.totalCost += enhancement.metadata.tokenUsage.cost;\r\n    } else {\r\n      this.metrics.failedEnhancements++;\r\n    }\r\n    \r\n    this.metrics.averageProcessingTime = \r\n      (this.metrics.averageProcessingTime * (this.metrics.totalEnhancements - 1) + processingTime) / \r\n      this.metrics.totalEnhancements;\r\n    \r\n    this.metrics.averageCostPerEnhancement = \r\n      this.metrics.totalCost / this.metrics.successfulEnhancements;\r\n  }\r\n\r\n  /**\r\n   * Initialize metrics\r\n   */\r\n  private initializeMetrics(): EnhancementMetrics {\r\n    return {\r\n      totalEnhancements: 0,\r\n      successfulEnhancements: 0,\r\n      failedEnhancements: 0,\r\n      averageQualityScore: 0,\r\n      averageConfidenceScore: 0,\r\n      averageProcessingTime: 0,\r\n      totalCost: 0,\r\n      averageCostPerEnhancement: 0,\r\n      qualityDistribution: {},\r\n      strategyPerformance: {}\r\n    };\r\n  }\r\n}\r",
        "File: src/services/context7/simple-context7-client.ts\nDescription: Class definition: SimpleContext7Client\nCode:\nexport class SimpleContext7Client {\r\n  private apiKey: string;\r\n  private logger: any;\r\n  private mcpServer: any; // Reference to MCP server for internal tool calls\r\n  private config?: any; // Configuration for URLs and settings\r\n  private openAIInterceptor?: Context7OpenAIInterceptor;\r\n\r\n  constructor(\r\n    config: Context7Config, \r\n    logger?: any, \r\n    mcpServer?: any,\r\n    openAIInterceptor?: Context7OpenAIInterceptor\r\n  ) {\r\n    this.apiKey = config.apiKey;\r\n    this.logger = logger || console;\r\n    this.mcpServer = mcpServer;\r\n    this.config = config;\r\n    this.openAIInterceptor = openAIInterceptor;\r\n    \r\n    console.log('🔍 [Context7-Client-Debug] SimpleContext7Client initialized', {\r\n      hasApiKey: !!this.apiKey,\r\n      apiKeyLength: this.apiKey.length,\r\n      hasLogger: !!this.logger,\r\n      hasMcpServer: !!this.mcpServer,\r\n      mcpServerType: typeof this.mcpServer\r\n    });\r\n    \r\n    this.logger.info('🔍 [Context7-Client-Debug] SimpleContext7Client initialized', {\r\n      hasApiKey: !!this.apiKey,\r\n      apiKeyLength: this.apiKey.length,\r\n      hasLogger: !!this.logger,\r\n      hasMcpServer: !!this.mcpServer,\r\n      mcpServerType: typeof this.mcpServer\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Resolve library name to Context7 library information\r\n   * Uses internal MCP tools instead of direct HTTP calls\r\n   */\r\n  async resolveLibraryId(libraryName: string): Promise<Context7LibraryInfo[]> {\r\n    const debugMode = process.env.CONTEXT7_DEBUG === 'true';\r\n    \r\n    // Always log the first call to see if the method is being called at all\r\n    this.logger.info('🔍 [Context7-Debug] resolveLibraryId called', {\r\n      libraryName,\r\n      debugMode,\r\n      context7DebugEnv: process.env.CONTEXT7_DEBUG,\r\n      timestamp: new Date().toISOString(),\r\n      hasMcpServer: !!this.mcpServer,\r\n      hasExecuteToolInternal: !!(this.mcpServer && this.mcpServer.executeToolInternal)\r\n    });\r\n    \r\n    if (debugMode) {\r\n      this.logger.info('🔍 [Context7-Debug] Starting library resolution', {\r\n        libraryName,\r\n        timestamp: new Date().toISOString(),\r\n        hasMcpServer: !!this.mcpServer,\r\n        hasExecuteToolInternal: !!(this.mcpServer && this.mcpServer.executeToolInternal)\r\n      });\r\n    }\r\n\r\n    try {\r\n      // Always call external Context7 API directly (like Cursor does)\r\n      if (false) { // Disabled internal tool calls - use direct API instead\r\n        if (debugMode) {\r\n          this.logger.info('🔍 [Context7-Debug] Using internal MCP tool', { libraryName });\r\n        }\r\n        \r\n        this.logger.info('🔍 [Context7-Debug] MCP server available, calling executeToolInternal', {\r\n          hasMcpServer: !!this.mcpServer,\r\n          hasExecuteToolInternal: !!this.mcpServer.executeToolInternal,\r\n          libraryName\r\n        });\r\n        \r\n        const result = await this.mcpServer.executeToolInternal('resolve-library-id', { libraryName });\r\n        \r\n        if (debugMode) {\r\n          this.logger.info('🔍 [Context7-Debug] Internal MCP tool result', {\r\n            libraryName,\r\n            success: result.success,\r\n            hasResult: !!result.result,\r\n            resultLength: result.result ? result.result.length : 0,\r\n            error: result.error,\r\n            resultType: typeof result.result,\r\n            isArray: Array.isArray(result.result)\r\n          });\r\n        }\r\n        \r\n        if (result.success) {\r\n          const libraries = result.result || [];\r\n          if (debugMode) {\r\n            this.logger.info('🔍 [Context7-Debug] Internal MCP tool success', {\r\n              libraryName,\r\n              librariesFound: libraries.length,\r\n            libraries: libraries.map((lib: any) => ({\r\n              libraryId: lib.libraryId,\r\n              name: lib.name,\r\n              codeSnippets: lib.codeSnippets,\r\n              trustScore: lib.trustScore\r\n            }))\r\n            });\r\n          }\r\n          return libraries;\r\n        } else {\r\n          this.logger.warn('Internal MCP tool failed, falling back to direct API call', { \r\n            error: result.error \r\n          });\r\n        }\r\n      }\r\n\r\n      // Fallback to direct API call if internal MCP tool not available\r\n      const mcpRequest = {\r\n        jsonrpc: '2.0',\r\n        id: Date.now(),\r\n        method: 'tools/call',\r\n        params: {\r\n          name: 'resolve-library-id',\r\n          arguments: { libraryName }\r\n        }\r\n      };\r\n\r\n      if (debugMode) {\r\n        const apiUrl = process.env.CONTEXT7_BASE_URL || this.config?.mcp?.serverUrl || this.config?.baseUrl || 'https://mcp.context7.com/mcp';\r\n        this.logger.info('🔍 [Context7-Debug] Making direct API call', {\r\n          libraryName,\r\n          requestId: mcpRequest.id,\r\n          apiUrl,\r\n          requestBody: JSON.stringify(mcpRequest, null, 2)\r\n        });\r\n      }\r\n\r\n      const apiUrl = process.env.CONTEXT7_BASE_URL || this.config?.mcp?.serverUrl || this.config?.baseUrl || 'https://mcp.context7.com/mcp';\r\n      const response = await fetch(apiUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Accept': 'application/json, text/event-stream',\r\n          'CONTEXT7_API_KEY': this.apiKey,\r\n          'User-Agent': 'PromptMCP-SimpleClient/1.0.0'\r\n        },\r\n        body: JSON.stringify(mcpRequest)\r\n      });\r\n\r\n      if (debugMode) {\r\n        this.logger.info('🔍 [Context7-Debug] API response received', {\r\n          libraryName,\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          ok: response.ok,\r\n          headers: Object.fromEntries(response.headers.entries())\r\n        });\r\n      }\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Context7 API error: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const responseText = await response.text();\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('🔍 [Context7-Debug] Raw response text', {\r\n          libraryName,\r\n          responseLength: responseText.length,\r\n          responsePreview: responseText.substring(0, 500),\r\n          isSSE: responseText.includes('event:'),\r\n          hasData: responseText.includes('data:')\r\n        });\r\n      }\r\n\r\n      const result = SSEParser.parseResponse(responseText);\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('🔍 [Context7-Debug] Parsed response', {\r\n          libraryName,\r\n          hasResult: !!result,\r\n          resultType: typeof result,\r\n          resultKeys: result ? Object.keys(result) : [],\r\n          hasResultArray: !!(result && result.result),\r\n          resultArrayLength: result && result.result ? result.result.length : 0,\r\n          hasContentArray: !!(result && result.result && result.result.content),\r\n          contentArrayLength: result && result.result && result.result.content ? result.result.content.length : 0\r\n        });\r\n      }\r\n      \r\n      // Context7 returns text-based response format:\r\n      // { result: { content: [{ type: \"text\", text: \"Available Libraries...\\n- Title: React\\n- Context7-compatible library ID: /websites/react_dev\\n...\" }] } }\r\n      let libraries = [];\r\n      \r\n      if (result && result.result) {\r\n        if (Array.isArray(result.result)) {\r\n          // Direct array format (expected but not used by Context7)\r\n          libraries = result.result;\r\n        } else if (result.result.content && Array.isArray(result.result.content)) {\r\n          // Text-based format (actual Context7 response)\r\n          const textContent = result.result.content[0]?.text || '';\r\n          libraries = this.parseLibraryTextResponse(textContent);\r\n          \r\n          if (debugMode) {\r\n            this.logger.info('🔍 [Context7-Debug] Parsed text response', {\r\n              libraryName,\r\n              textLength: textContent.length,\r\n              librariesFound: libraries.length,\r\n            libraries: libraries.map((lib: any) => ({\r\n              libraryId: lib.libraryId,\r\n              name: lib.name,\r\n              codeSnippets: lib.codeSnippets,\r\n              trustScore: lib.trustScore\r\n            }))\r\n            });\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('🔍 [Context7-Debug] Final library resolution result', {\r\n          libraryName,\r\n          librariesFound: libraries.length,\r\n          libraries: libraries.map((lib: any) => ({\r\n            libraryId: lib.libraryId,\r\n            name: lib.name,\r\n            description: lib.description ? lib.description.substring(0, 100) + '...' : 'No description',\r\n            codeSnippets: lib.codeSnippets,\r\n            trustScore: lib.trustScore\r\n          }))\r\n        });\r\n      }\r\n      \r\n      return libraries;\r\n    } catch (error) {\r\n      if (debugMode) {\r\n        this.logger.error('🔍 [Context7-Debug] Library resolution failed with error', {\r\n          libraryName,\r\n          error: error instanceof Error ? error.message : 'Unknown error',\r\n          stack: error instanceof Error ? error.stack : undefined,\r\n          errorType: typeof error\r\n        });\r\n      }\r\n      \r\n      this.logger.warn('Context7 library resolution failed', { \r\n        libraryName, \r\n        error: error instanceof Error ? error.message : 'Unknown error' \r\n      });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get library documentation from Context7\r\n   * Verified against actual Context7 API with optional AI enhancement\r\n   */\r\n  async getLibraryDocs(\r\n    libraryId: string, \r\n    topic?: string, \r\n    tokens?: number,\r\n    enhancementOptions?: Context7EnhancementOptions\r\n  ): Promise<Context7Documentation> {\r\n    const debugMode = process.env.CONTEXT7_DEBUG === 'true';\r\n    \r\n    if (debugMode) {\r\n      this.logger.info('📚 [Context7-Debug] Starting documentation retrieval', {\r\n        libraryId,\r\n        topic,\r\n        tokens: tokens || 4000,\r\n        timestamp: new Date().toISOString(),\r\n        hasMcpServer: !!this.mcpServer,\r\n        hasExecuteToolInternal: !!(this.mcpServer && this.mcpServer.executeToolInternal)\r\n      });\r\n    }\r\n\r\n    try {\r\n      // Always call external Context7 API directly (like Cursor does)\r\n      if (false) { // Disabled internal tool calls - use direct API instead\r\n        if (debugMode) {\r\n          this.logger.info('📚 [Context7-Debug] Using internal MCP tool for docs', {\r\n            libraryId,\r\n            topic,\r\n            tokens: tokens || 4000\r\n          });\r\n        }\r\n        \r\n        const result = await this.mcpServer.executeToolInternal('get-library-docs', {\r\n          context7CompatibleLibraryID: libraryId,\r\n          topic,\r\n          tokens: tokens || 4000\r\n        });\r\n        \r\n        if (debugMode) {\r\n          this.logger.info('📚 [Context7-Debug] Internal MCP tool result for docs', {\r\n            libraryId,\r\n            success: result.success,\r\n            hasResult: !!result.result,\r\n            hasContent: !!(result.result && result.result.content),\r\n            contentLength: result.result && result.result.content ? result.result.content.length : 0,\r\n            error: result.error\r\n          });\r\n        }\r\n        \r\n        if (result.success) {\r\n          const docs = {\r\n            content: result.result?.content || '',\r\n            metadata: {\r\n              libraryId,\r\n              topic,\r\n              tokens: tokens || 4000,\r\n              retrievedAt: new Date(),\r\n              source: 'internal-mcp'\r\n            }\r\n          };\r\n          \r\n          if (debugMode) {\r\n            this.logger.info('📚 [Context7-Debug] Internal MCP tool success for docs', {\r\n              libraryId,\r\n              contentLength: docs.content.length,\r\n              hasContent: docs.content.length > 0,\r\n              contentPreview: docs.content.substring(0, 200) + (docs.content.length > 200 ? '...' : ''),\r\n              metadata: docs.metadata\r\n            });\r\n          }\r\n          \r\n          return docs;\r\n        } else {\r\n          this.logger.warn('Internal MCP tool failed, falling back to direct API call', { \r\n            error: result.error \r\n          });\r\n        }\r\n      }\r\n\r\n      // Fallback to direct API call if internal MCP tool not available\r\n      const mcpRequest = {\r\n        jsonrpc: '2.0',\r\n        id: Date.now(),\r\n        method: 'tools/call',\r\n        params: {\r\n          name: 'get-library-docs',\r\n          arguments: {\r\n            context7CompatibleLibraryID: libraryId,\r\n            topic,\r\n            tokens: tokens || 4000\r\n          }\r\n        }\r\n      };\r\n\r\n      if (debugMode) {\r\n        const apiUrl = process.env.CONTEXT7_BASE_URL || this.config?.mcp?.serverUrl || this.config?.baseUrl || 'https://mcp.context7.com/mcp';\r\n        this.logger.info('📚 [Context7-Debug] Making direct API call for docs', {\r\n          libraryId,\r\n          topic,\r\n          tokens: tokens || 4000,\r\n          requestId: mcpRequest.id,\r\n          apiUrl,\r\n          requestBody: JSON.stringify(mcpRequest, null, 2)\r\n        });\r\n      }\r\n\r\n      const apiUrl = process.env.CONTEXT7_BASE_URL || this.config?.mcp?.serverUrl || this.config?.baseUrl || 'https://mcp.context7.com/mcp';\r\n      const response = await fetch(apiUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Accept': 'application/json, text/event-stream',\r\n          'CONTEXT7_API_KEY': this.apiKey,\r\n          'User-Agent': 'PromptMCP-SimpleClient/1.0.0'\r\n        },\r\n        body: JSON.stringify(mcpRequest)\r\n      });\r\n\r\n      if (debugMode) {\r\n        this.logger.info('📚 [Context7-Debug] API response received for docs', {\r\n          libraryId,\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          ok: response.ok,\r\n          headers: Object.fromEntries(response.headers.entries())\r\n        });\r\n      }\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Context7 API error: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const responseText = await response.text();\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('📚 [Context7-Debug] Raw response text for docs', {\r\n          libraryId,\r\n          responseLength: responseText.length,\r\n          responsePreview: responseText.substring(0, 500),\r\n          isSSE: responseText.includes('event:'),\r\n          hasData: responseText.includes('data:')\r\n        });\r\n      }\r\n\r\n      const result = SSEParser.parseResponse(responseText);\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('📚 [Context7-Debug] Parsed response for docs', {\r\n          libraryId,\r\n          hasResult: !!result,\r\n          resultType: typeof result,\r\n          resultKeys: result ? Object.keys(result) : [],\r\n          hasResultContent: !!(result && result.result && result.result.content),\r\n          contentLength: result && result.result && result.result.content ? result.result.content.length : 0\r\n        });\r\n      }\r\n      \r\n      // Context7 returns documentation with text-based format:\r\n      // { result: { content: [{ type: \"text\", text: \"================\\nCODE SNIPPETS\\n================\\nTITLE: ...\" }] } }\r\n      let content = '';\r\n      \r\n      if (result && result.result) {\r\n        if (typeof result.result.content === 'string') {\r\n          // Direct string content\r\n          content = result.result.content;\r\n        } else if (Array.isArray(result.result.content) && result.result.content[0] && result.result.content[0].text) {\r\n          // Text-based format (actual Context7 response)\r\n          content = result.result.content[0].text;\r\n        }\r\n      }\r\n      \r\n      let finalContent = content;\r\n      let enhancementResult: Context7EnhancementResult | undefined;\r\n\r\n      // Apply AI enhancement if enabled\r\n      if (this.openAIInterceptor && enhancementOptions?.useAIEnhancement && content) {\r\n        try {\r\n          const framework = this.extractFrameworkFromLibraryId(libraryId);\r\n          enhancementResult = await this.openAIInterceptor.enhanceContext7Result(\r\n            content,\r\n            framework,\r\n            enhancementOptions\r\n          );\r\n          \r\n          finalContent = enhancementResult.enhancedDocs;\r\n          \r\n          if (debugMode) {\r\n            this.logger.info('📚 [Context7-Debug] Applied AI enhancement', {\r\n              libraryId,\r\n              originalLength: content.length,\r\n              enhancedLength: finalContent.length,\r\n              tokensUsed: enhancementResult.enhancementMetadata.tokensUsed,\r\n              cost: enhancementResult.enhancementMetadata.cost\r\n            });\r\n          }\r\n        } catch (enhancementError) {\r\n          this.logger.warn('AI enhancement failed, using original content', {\r\n            libraryId,\r\n            error: enhancementError instanceof Error ? enhancementError.message : 'Unknown error'\r\n          });\r\n        }\r\n      }\r\n\r\n      const docs = {\r\n        content: finalContent,\r\n        metadata: {\r\n          libraryId,\r\n          topic,\r\n          tokens: tokens || 4000,\r\n          retrievedAt: new Date(),\r\n          source: 'Context7 MCP'\r\n        },\r\n        enhancementResult\r\n      };\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('📚 [Context7-Debug] Final documentation result', {\r\n          libraryId,\r\n          contentLength: docs.content.length,\r\n          hasContent: docs.content.length > 0,\r\n          contentPreview: docs.content.substring(0, 200) + (docs.content.length > 200 ? '...' : ''),\r\n          metadata: docs.metadata,\r\n          hasEnhancement: !!enhancementResult\r\n        });\r\n      }\r\n      \r\n      return docs;\r\n    } catch (error) {\r\n      if (debugMode) {\r\n        this.logger.error('📚 [Context7-Debug] Documentation retrieval failed with error', {\r\n          libraryId,\r\n          topic,\r\n          error: error instanceof Error ? error.message : 'Unknown error',\r\n          stack: error instanceof Error ? error.stack : undefined,\r\n          errorType: typeof error\r\n        });\r\n      }\r\n      \r\n      this.logger.warn('Context7 documentation retrieval failed', { \r\n        libraryId, \r\n        topic, \r\n        error: error instanceof Error ? error.message : 'Unknown error' \r\n      });\r\n      return {\r\n        content: '',\r\n        metadata: {\r\n          libraryId,\r\n          topic,\r\n          tokens: tokens || 4000,\r\n          retrievedAt: new Date(),\r\n          source: 'Context7 MCP (error)'\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse Context7 text-based response format into library objects\r\n   * Context7 returns text like:\r\n   * \"Available Libraries (top matches):\\n\\n- Title: React\\n- Context7-compatible library ID: /websites/react_dev\\n- Description: ...\\n- Code Snippets: 1752\\n- Trust Score: 8\\n----------\\n...\"\r\n   */\r\n  private parseLibraryTextResponse(textContent: string): Context7LibraryInfo[] {\r\n    const libraries: Context7LibraryInfo[] = [];\r\n    \r\n    try {\r\n      // Split by library separator (----------)\r\n      const librarySections = textContent.split('----------').filter(section => section.trim());\r\n      \r\n      for (const section of librarySections) {\r\n        const lines = section.split('\\n').map(line => line.trim()).filter(line => line);\r\n        \r\n        let library: Partial<Context7LibraryInfo> = {};\r\n        \r\n        for (const line of lines) {\r\n          if (line.startsWith('- Title:')) {\r\n            library.name = line.replace('- Title:', '').trim();\r\n          } else if (line.startsWith('- Context7-compatible library ID:')) {\r\n            library.libraryId = line.replace('- Context7-compatible library ID:', '').trim();\r\n          } else if (line.startsWith('- Description:')) {\r\n            library.description = line.replace('- Description:', '').trim();\r\n          } else if (line.startsWith('- Code Snippets:')) {\r\n            const snippets = line.replace('- Code Snippets:', '').trim();\r\n            library.codeSnippets = parseInt(snippets) || 0;\r\n          } else if (line.startsWith('- Trust Score:')) {\r\n            const score = line.replace('- Trust Score:', '').trim();\r\n            library.trustScore = parseFloat(score) || 0;\r\n          } else if (line.startsWith('- Versions:')) {\r\n            const versions = line.replace('- Versions:', '').trim();\r\n            (library as any).versions = versions.split(',').map(v => v.trim());\r\n          }\r\n        }\r\n        \r\n        // Only add if we have the required fields\r\n        if (library.libraryId && library.name) {\r\n          libraries.push({\r\n            libraryId: library.libraryId,\r\n            name: library.name,\r\n            description: library.description || '',\r\n            codeSnippets: library.codeSnippets || 0,\r\n            trustScore: library.trustScore || 0,\r\n            ...((library as any).versions && { versions: (library as any).versions })\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to parse Context7 text response', { \r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        textLength: textContent.length\r\n      });\r\n    }\r\n    \r\n    return libraries;\r\n  }\r\n\r\n  /**\r\n   * Get documentation for multiple frameworks in parallel\r\n   * This is the main method used by the enhance tool\r\n   */\r\n  async getDocumentation(\r\n    prompt: string,\r\n    detectedFrameworks: string[]\r\n  ): Promise<{ docs: string; libraries: string[] }> {\r\n    try {\r\n      if (!detectedFrameworks || detectedFrameworks.length === 0) {\r\n        return { docs: '', libraries: [] };\r\n      }\r\n\r\n      // Parallel library resolution\r\n      const libraryPromises = detectedFrameworks.map(fw =>\r\n        this.resolveLibraryId(fw)\r\n      );\r\n      const libraryResults = await Promise.all(libraryPromises);\r\n      \r\n      // Flatten and get unique library IDs\r\n      const allLibraries = libraryResults.flat();\r\n      const uniqueLibraries = [...new Set(allLibraries.map(lib => lib.libraryId))];\r\n      \r\n      if (uniqueLibraries.length === 0) {\r\n        return { docs: '', libraries: [] };\r\n      }\r\n\r\n      // Extract topic from prompt (simple keyword extraction)\r\n      const topic = this.extractTopicFromPrompt(prompt);\r\n      \r\n      // Parallel documentation fetching\r\n      const docPromises = uniqueLibraries.map(libraryId =>\r\n        this.getLibraryDocs(libraryId, topic, Math.floor(4000 / uniqueLibraries.length))\r\n      );\r\n      \r\n      const docResults = await Promise.all(docPromises);\r\n      \r\n      // Combine results\r\n      const allDocs = docResults\r\n        .filter(doc => doc && doc.content)\r\n        .map((doc, index) => `## ${uniqueLibraries[index]} Documentation:\\n${doc.content}`);\r\n      \r\n      return {\r\n        docs: allDocs.join('\\n\\n'),\r\n        libraries: uniqueLibraries\r\n      };\r\n    } catch (error) {\r\n      this.logger.warn('Context7 documentation retrieval failed', { \r\n        prompt: prompt.substring(0, 100) + '...', \r\n        detectedFrameworks,\r\n        error: error instanceof Error ? error.message : 'Unknown error' \r\n      });\r\n      return { docs: '', libraries: [] };\r\n    }\r\n  }\r"
      ],
      "context7_docs": [
        "## /websites/react_dev Documentation:\n================\nCODE SNIPPETS\n================\nTITLE: Initialize Application-Wide Logic Outside React Components\nDESCRIPTION: This code snippet demonstrates how to run essential application initialization logic, such as checking authentication tokens or loading data from local storage, only once when the application starts. By placing this code outside any React component and verifying the `window` object's existence, it ensures execution only in the browser environment and independently of component lifecycles.\n\nSOURCE: https://react.dev/learn/synchronizing-with-effects\n\nLANGUAGE: javascript\nCODE:\n```\nif (typeof window !== 'undefined') { // Check if we're running in the browser.  \n  checkAuthToken();  \n  loadDataFromLocalStorage();  \n}  \n  \nfunction App() {  \n  // ...  \n}\n```\n\n--------------------------------\n\nTITLE: Avoid: Running initialization logic in React useEffect (development double-run)\nDESCRIPTION: This snippet demonstrates an anti-pattern where application-wide initialization logic is placed in a `useEffect` hook in the top-level `App` component. In development mode, React's Strict Mode will cause this `useEffect` to run twice, potentially leading to issues like invalidating authentication tokens or duplicate data loading.\n\nSOURCE: https://react.dev/learn/you-might-not-need-an-effect\n\nLANGUAGE: javascript\nCODE:\n```\nfunction App() {  \n  // 🔴 Avoid: Effects with logic that should only ever run once  \n  useEffect(() => {  \n    loadDataFromLocalStorage();  \n    checkAuthToken();  \n  }, []);  \n  // ...  \n}\n```\n\n--------------------------------\n\nTITLE: React Component Using useId for Unique Accessibility IDs\nDESCRIPTION: This React functional component, `PasswordField`, imports `useId` and calls it to generate a unique ID. This ID is then used for the `aria-describedby` attribute of an input and the `id` attribute of a paragraph, ensuring accessibility attributes are correctly linked without ID conflicts.\n\nSOURCE: https://react.dev/reference/react/useId\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useId } from 'react';\n\nfunction PasswordField() {\n  const passwordHintId = useId();\n  return (\n    <>\n      <label>\n        Password:\n        <input\n          type=\"password\"\n          aria-describedby={passwordHintId}\n        />\n      </label>\n      <p id={passwordHintId}>\n        The password should contain at least 18 characters\n      </p>\n    </>\n  );\n}\n```\n\n--------------------------------\n\nTITLE: Secure API calls with `server-only` to prevent client exposure (React)\nDESCRIPTION: This example demonstrates a secure pattern for handling sensitive API credentials using the `server-only` package. It ensures that the `fetchAPI` helper, which accesses `process.env.API_PASSWORD`, can only be imported and executed on the server, preventing accidental exposure to client components.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nimport \"server-only\";\n\nexport function fetchAPI(url) {\n  const headers = { Authorization: process.env.API_PASSWORD };\n  return fetch(url, { headers });\n}\n```\n\n--------------------------------\n\nTITLE: Fetch User Data from Database in Server Component (JavaScript)\nDESCRIPTION: This asynchronous JavaScript function `getUser` retrieves user information from a database based on a provided ID. It is intended for use in a server environment. The function returns the entire user object, setting up the context for potential data leakage if passed directly to client components.\n\nSOURCE: https://react.dev/reference/react/experimental_taintObjectReference\n\nLANGUAGE: javascript\nCODE:\n```\n// api.js  \n\nexport async function getUser(id) {  \n\n  const user = await db`SELECT * FROM users WHERE id = ${id}`;\n\n  return user;  \n\n}\n```\n\n--------------------------------\n\nTITLE: Match Identifier Prefix for Server-Side Rendered and Client-Side Hydrated React Apps\nDESCRIPTION: Shows how to ensure ID consistency between server-rendered and client-hydrated React applications by providing the same `identifierPrefix`. The server-side code uses `renderToPipeableStream` with a specified prefix, while the client-side code uses `hydrateRoot` with an identical prefix. This synchronization is vital for correct hydration and maintaining unique IDs when deploying isomorphic React applications with `useId`.\n\nSOURCE: https://react.dev/reference/react/useId\n\nLANGUAGE: javascript\nCODE:\n```\n// Server  \n\nimport { renderToPipeableStream } from 'react-dom/server';  \n\n  \n\nconst { pipe } = renderToPipeableStream(  \n\n  <App />,  \n\n  { identifierPrefix: 'react-app1' }  \n\n);\n```\n\nLANGUAGE: javascript\nCODE:\n```\n// Client  \n\nimport { hydrateRoot } from 'react-dom/client';  \n\n  \n\nconst domNode = document.getElementById('root');  \n\nconst root = hydrateRoot(  \n\n  domNode,  \n\n  reactNode,  \n\n  { identifierPrefix: 'react-app1' }  \n\n);\n```\n\n--------------------------------\n\nTITLE: Insecurely Pass Full User Object to Client Component (React JS)\nDESCRIPTION: This React Server Component `Profile` fetches user data using `getUser` and directly passes the complete `user` object as a prop to an `InfoCard` Client Component. This example demonstrates an insecure pattern where sensitive server-side data could be exposed to the client, highlighting the problem that `experimental_taintObjectReference` aims to solve.\n\nSOURCE: https://react.dev/reference/react/experimental_taintObjectReference\n\nLANGUAGE: javascript\nCODE:\n```\nimport { getUser } from 'api.js';  \n\nimport { InfoCard } from 'components.js';  \n  \n\nexport async function Profile(props) {  \n  const user = await getUser(props.userId);  \n  // DO NOT DO THIS  \n  return <InfoCard user={user} />;  \n\n}\n```\n\n--------------------------------\n\nTITLE: React App Demonstrating Multiple useId Component Instances\nDESCRIPTION: An example React `App` component that renders two instances of the `PasswordField` component. This demonstrates how `useId` effectively ensures each instance generates unique IDs, preventing conflicts when the same component is reused multiple times on a page, crucial for correct accessibility.\n\nSOURCE: https://react.dev/reference/react/useId\n\nLANGUAGE: jsx\nCODE:\n```\nimport { useId } from 'react';\n\nfunction PasswordField() {\n  const passwordHintId = useId();\n  return (\n    <>\n      <label>\n        Password:\n        <input\n          type=\"password\"\n          aria-describedby={passwordHintId}\n        />\n      </label>\n      <p id={passwordHintId}>\n        The password should contain at least 18 characters\n      </p>\n    </>\n  );\n}\n\nexport default function App() {\n  return (\n    <>\n      <h2>Choose password</h2>\n      <PasswordField />\n      <h2>Confirm password</h2>\n      <PasswordField />\n    </>\n  );\n}\n```\n\n--------------------------------\n\nTITLE: Taint a User Password Indefinitely in React\nDESCRIPTION: This example illustrates tainting a user's password using `experimental_taintUniqueValue` with `globalThis` as the `lifetime` argument. This ensures the password remains tainted indefinitely, preventing it from being passed to Client Components.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nimport {experimental_taintUniqueValue} from 'react';  \n  \nexperimental_taintUniqueValue(  \n  'Do not pass a user password to the client.',  \n  globalThis,  \n  process.env.SECRET_KEY  \n);\n```\n\n--------------------------------\n\nTITLE: Tainting API password with `experimental_taintUniqueValue` (React)\nDESCRIPTION: This code snippet shows how to use `experimental_taintUniqueValue` to explicitly mark a sensitive environment variable, `API_PASSWORD`, as tainted. If this tainted value is ever inadvertently passed to a Client Component or a Server Function intended for the client, React will throw an error, providing an additional layer of security against leaks.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nimport \"server-only\";\nimport {experimental_taintUniqueValue} from 'react';\n\nexperimental_taintUniqueValue(\n  'Do not pass the API token password to the client. ' +\n    'Instead do all fetches on the server.',\n  process,\n  process.env.API_PASSWORD\n);\n```\n\n--------------------------------\n\nTITLE: Anti-pattern: Leaking API password to Client Component (React)\nDESCRIPTION: This code demonstrates an anti-pattern where a server-side `API_PASSWORD` is directly passed as a prop to a Client Component, `Overview`. This method exposes sensitive information to the client, leading to potential security vulnerabilities and data breaches. This should be avoided.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nexport async function Dashboard(props) {\n  // DO NOT DO THIS\n  return <Overview password={process.env.API_PASSWORD} />;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\n\"use client\";\n\nimport {useEffect} from '...'\n\nexport async function Overview({ password }) {\n  useEffect(() => {\n    const headers = { Authorization: password };\n    fetch(url, { headers }).then(...);\n  }, [password]);\n  ...\n}\n```\n\n--------------------------------\n\nTITLE: Prevent Data Leaks with `experimental_taintObjectReference` (React JS)\nDESCRIPTION: This improved `getUser` function uses `experimental_taintObjectReference` from 'react' to 'taint' the fetched `user` object. If this tainted object is subsequently passed to a Client Component, React will throw an error with a descriptive message, enforcing the selection of only necessary properties for client-side use. This prevents accidental exposure of sensitive server-side data.\n\nSOURCE: https://react.dev/reference/react/experimental_taintObjectReference\n\nLANGUAGE: javascript\nCODE:\n```\n// api.js  \n\nimport {experimental_taintObjectReference} from 'react';  \n  \n\nexport async function getUser(id) {  \n  const user = await db`SELECT * FROM users WHERE id = ${id}`;\n\n  experimental_taintObjectReference(  \n    'Do not pass the entire user object to the client. ' +  \n      'Instead, pick off the specific properties you need for this use case.',  \n    user,  \n\n  );  \n\n  return user;  \n\n}\n```\n\n--------------------------------\n\nTITLE: Set Distinct Identifier Prefixes for Multiple React Roots with createRoot\nDESCRIPTION: Illustrates how to render multiple independent React applications on a single HTML page, each using a unique `identifierPrefix` with `createRoot`. This ensures that IDs generated by `useId` within one application do not clash with IDs from another, by prepending a distinct string like 'my-first-app-' or 'my-second-app-' to all generated IDs. This is crucial for maintaining ID uniqueness across separate React instances on the same page.\n\nSOURCE: https://react.dev/reference/react/useId\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createRoot } from 'react-dom/client';\nimport App from './App.js';\nimport './styles.css';\n\nconst root1 = createRoot(document.getElementById('root1'), {\n  identifierPrefix: 'my-first-app-'\n});\nroot1.render(<App />);\n\nconst root2 = createRoot(document.getElementById('root2'), {\n  identifierPrefix: 'my-second-app-'\n});\nroot2.render(<App />);\n```\n\n--------------------------------\n\nTITLE: Preventing Sensitive User Data from Reaching Client Components in React\nDESCRIPTION: Illustrates integrating `experimental_taintObjectReference` within a data fetching function (`getUser`). By tainting the `user` object, an error is thrown if it's accidentally passed to a Client Component, helping to secure sensitive user information.\n\nSOURCE: https://react.dev/reference/react/experimental_taintObjectReference\n\nLANGUAGE: javascript\nCODE:\n```\nimport {experimental_taintObjectReference} from 'react';\n\nexport async function getUser(id) {\n  const user = await db`SELECT * FROM users WHERE id = ${id}`;\n  experimental_taintObjectReference(\n    'Do not pass the entire user object to the client. ' +\n      'Instead, pick off the specific properties you need for this use case.',\n    user,\n  );\n  return user;\n}\n```\n\n--------------------------------\n\nTITLE: Hardcoded HTML IDs (Comparison)\nDESCRIPTION: This snippet illustrates a traditional HTML structure using hardcoded IDs for linking elements with accessibility attributes. This approach is problematic in React applications where components can be rendered multiple times, leading to non-unique IDs and accessibility issues.\n\nSOURCE: https://react.dev/reference/react/useId\n\nLANGUAGE: html\nCODE:\n```\n<label>\n  Password:\n  <input\n    type=\"password\"\n    aria-describedby=\"password-hint\"\n  />\n</label>\n<p id=\"password-hint\">\n  The password should contain at least 18 characters\n</p>\n```\n\n--------------------------------\n\nTITLE: React Client Component Displaying User Name (JavaScript)\nDESCRIPTION: This React Client Component, marked with `\"use client\";`, receives a `user` object as a prop and displays its `name` property. It serves as the recipient component in the example, illustrating where sensitive data might end up if not properly handled by server components.\n\nSOURCE: https://react.dev/reference/react/experimental_taintObjectReference\n\nLANGUAGE: javascript\nCODE:\n```\n// components.js  \n\n\"use client\";  \n  \n\nexport async function InfoCard({ user }) {  \n  return <div>{user.name}</div>;  \n\n}\n```\n\n--------------------------------\n\nTITLE: Pass Object and Function via React Context (Unoptimized)\nDESCRIPTION: This code snippet shows how to pass an object containing `currentUser` state and a `login` function via `AuthContext`. Without optimization, a new object and a new function are created on every `MyApp` re-render, potentially causing unnecessary re-renders in components consuming this context.\n\nSOURCE: https://react.dev/reference/react/useContext\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MyApp() {  \n\n  const [currentUser, setCurrentUser] = useState(null);  \n\n  \n\n  function login(response) {  \n\n    storeCredentials(response.credentials);  \n\n    setCurrentUser(response.user);  \n\n  }  \n\n  \n\n  return (  \n\n    <AuthContext value={{ currentUser, login }}>  \n\n      <Page />  \n\n    </AuthContext>  \n\n  );  \n\n}\n```\n\n--------------------------------\n\nTITLE: React: `useSyncExternalStore` Hook Signature\nDESCRIPTION: This snippet shows the basic signature of the `useSyncExternalStore` React Hook, indicating its return value (`snapshot`) and its required parameters: `subscribe`, `getSnapshot`, and an optional `getServerSnapshot`. It outlines the functions needed to interact with an external store.\n\nSOURCE: https://react.dev/reference/react/useSyncExternalStore\n\nLANGUAGE: javascript\nCODE:\n```\nconst snapshot = useSyncExternalStore(subscribe, getSnapshot, getServerSnapshot?)\n```\n\n--------------------------------\n\nTITLE: Define and Render a Basic React Component in JavaScript\nDESCRIPTION: This snippet demonstrates a fundamental React component (`Greeting`) that accepts a `name` prop and renders a greeting. The `App` component then uses and renders this `Greeting` component with a default name, showcasing a simple React application structure suitable for quick experimentation in a sandbox environment.\n\nSOURCE: https://react.dev/learn/installation\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Greeting({ name }) {\n  return <h1>Hello, {name}</h1>;\n}\n  \nexport default function App() {\n  return <Greeting name=\"world\" />\n}\n```\n\n--------------------------------\n\nTITLE: Basic `renderToStaticMarkup` function signature in React\nDESCRIPTION: This snippet shows the basic function signature for `renderToStaticMarkup`. It takes a React node to be rendered and an optional `options` object for server-side configurations, returning an HTML string.\n\nSOURCE: https://react.dev/reference/react-dom/server/renderToStaticMarkup\n\nLANGUAGE: javascript\nCODE:\n```\nconst html = renderToStaticMarkup(reactNode, options?)\n```\n\n--------------------------------\n\nTITLE: Taint a Session Token with Object-Scoped Lifetime in React\nDESCRIPTION: This example shows how to use `experimental_taintUniqueValue` to protect a user's session token by tying its tainted lifetime to the `user` object itself. If the `user` object is stored or passed around, the session token remains protected as long as the object exists.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nimport {experimental_taintUniqueValue} from 'react';  \n  \nexport async function getUser(id) {  \n  const user = await db`SELECT * FROM users WHERE id = ${id}`;  \n  experimental_taintUniqueValue(  \n    'Do not pass a user session token to the client.',  \n    user,  \n    user.session.token  \n  );  \n  return user;  \n}\n```\n\n--------------------------------\n\nTITLE: Basic React useId Hook Call\nDESCRIPTION: A fundamental example demonstrating how to invoke the `useId` hook within a React functional component to obtain a unique identifier. This ID is stable across renders for the same component instance.\n\nSOURCE: https://react.dev/reference/react/useId\n\nLANGUAGE: jsx\nCODE:\n```\nconst id = useId()\n```"
      ]
    },
    "success": true,
    "todos": [],
    "frameworks_detected": [],
    "ai_enhancement": {
      "enabled": false,
      "strategy": "none",
      "quality_score": 0,
      "confidence_score": 0,
      "improvements": [],
      "recommendations": [],
      "processing_time": 0,
      "cost": 0
    }
  },
  "performance": {
    "originalTokens": 33,
    "enhancedTokens": 1711,
    "tokenRatio": 51.84848484848485,
    "responseTime": 2249,
    "context7Used": true,
    "context7LibrariesResolved": 1
  },
  "quality": {
    "overall": 25,
    "details": {
      "frameworkAccuracy": "0%",
      "context7Accuracy": "0%",
      "architecture": "Present",
      "security": "Present",
      "realTimePatterns": "Present",
      "fileUploadPatterns": "Present",
      "scalability": "Present",
      "contentQuality": "25/25"
    },
    "breakdown": {
      "performance": 8,
      "accuracy": 11,
      "content": 6
    }
  },
  "context": {
    "repoFacts": 16,
    "codeSnippets": 10,
    "frameworkDocs": 0,
    "projectDocs": 0,
    "context7Docs": 1
  },
  "libraries": [
    "/websites/react_dev"
  ],
  "timestamp": "2025-09-25T22:41:15.712Z"
}