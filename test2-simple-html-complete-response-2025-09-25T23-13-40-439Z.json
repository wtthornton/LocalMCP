{
  "testCase": {
    "id": "simple-html",
    "name": "Simple HTML Button",
    "prompt": "How do I create a button?",
    "expectedFrameworks": [
      "html"
    ],
    "expectedContext7Libraries": [
      "/mdn/html"
    ],
    "qualityCriteria": {
      "shouldIncludeHTMLDocs": true,
      "shouldBePractical": true,
      "shouldIncludeExamples": true,
      "maxTokens": 200,
      "maxResponseTime": 200
    }
  },
  "completeResponse": {
    "enhanced_prompt": "How do I create a button?",
    "context_used": {
      "repo_facts": [
        "Project name: promptmcp",
        "Project description: A focused MCP server for intelligent prompt enhancement with dynamic framework detection, Context7 integration, comprehensive testing suite, and organized test artifacts management",
        "Uses Playwright framework (^1.55.0)",
        "Uses TypeScript framework (^5.0.0)",
        "Uses Vitest framework (^1.0.0)",
        "Project type: Frontend application",
        "Has testing setup",
        "Has build process",
        "Source directories: src",
        "Configuration files: tsconfig.json",
        "Uses TypeScript for type safety",
        "Uses Node.js/Express for backend",
        "Uses testing with 297 test files",
        "Uses Model Context Protocol (MCP) for AI integration",
        "Uses service-oriented architecture with 153 service files",
        "Uses tool-based architecture with 39 tool files"
      ],
      "code_snippets": [
        "File: src/services/ai/context7-curation.service.ts\nDescription: Function definition: response\nCode:\n      const response = await this.openaiService.createChatCompletion([\r\n          {\r\n            role: 'system',\r\n            content: `You are a content quality assessor for AI code generation. Rate documentation content on a scale of 1-10 based on:\r\n\r\n1. Code Examples (30%): Presence of practical, runnable code snippets\r\n2. Best Practices (25%): Clear patterns, conventions, and guidelines\r\n3. Relevance (25%): How well it matches the user's coding intent\r\n4. Completeness (20%): Essential information coverage\r\n\r\nReturn ONLY a JSON object with this exact structure:\r\n{\r\n  \"score\": 8.5,\r\n  \"reasoning\": \"Brief explanation of the score\",\r\n  \"strengths\": [\"list\", \"of\", \"strengths\"],\r\n  \"weaknesses\": [\"list\", \"of\", \"weaknesses\"]\r\n}`\r\n          },\r",
        "File: src/services/ai/context7-curation.service.ts\nDescription: Class definition: Context7CurationService\nCode:\nexport class Context7CurationService {\r\n  private logger: Logger;\r\n  private openaiService: OpenAIService;\r\n  private config: CurationConfig;\r\n\r\n  constructor(logger: Logger, openaiService: OpenAIService, config: CurationConfig) {\r\n    this.logger = logger;\r\n    this.openaiService = openaiService;\r\n    this.config = config;\r\n  }\r\n\r\n  /**\r\n   * Curate Context7 content for Cursor AI code generation\r\n   */\r\n  async curateForCursor(\r\n    context7Content: string,\r\n    libraryId: string,\r\n    prompt: string,\r\n    projectContext: any\r\n  ): Promise<CuratedContent> {\r\n    const startTime = Date.now();\r\n    \r\n    try {\r\n      this.logger.debug('Starting Context7 content curation', {\r\n        libraryId,\r\n        originalLength: context7Content.length,\r\n        prompt: prompt.substring(0, 100) + '...'\r\n      });\r\n\r\n      // 1. Assess content quality\r\n      const qualityScore = await this.assessContentQuality(context7Content, prompt);\r\n      \r\n      // 2. If quality is too low, return original content\r\n      if (qualityScore < this.config.minQualityScore) {\r\n        this.logger.warn('Content quality too low, returning original', {\r\n          libraryId,\r\n          qualityScore,\r\n          minRequired: this.config.minQualityScore\r\n        });\r\n        \r\n        return this.createFallbackContent(context7Content, libraryId, startTime);\r\n      }\r\n\r\n      // 3. Extract key components\r\n      const keyComponents = await this.extractKeyComponents(context7Content, prompt, libraryId);\r\n      \r\n      // 4. Optimize tokens while preserving quality\r\n      const curatedContent = await this.optimizeTokens(\r\n        context7Content,\r\n        keyComponents,\r\n        prompt,\r\n        libraryId\r\n      );\r\n\r\n      // 5. Calculate metrics\r\n      const originalTokens = Math.ceil(context7Content.length / 4);\r\n      const curatedTokens = Math.ceil(curatedContent.length / 4);\r\n      const tokenReduction = 1 - (curatedTokens / originalTokens);\r\n\r\n      const result: CuratedContent = {\r\n        originalContent: context7Content,\r\n        curatedContent,\r\n        qualityScore,\r\n        tokenReduction,\r\n        cursorOptimized: true,\r\n        keyPatterns: keyComponents.patterns,\r\n        bestPractices: keyComponents.bestPractices,\r\n        codeExamples: keyComponents.codeExamples,\r\n        metadata: {\r\n          libraryId,\r\n          originalTokens,\r\n          curatedTokens,\r\n          processingTime: Date.now() - startTime,\r\n          confidence: qualityScore / 10\r\n        }\r\n      };\r\n\r\n      this.logger.info('Content curation completed successfully', {\r\n        libraryId,\r\n        qualityScore,\r\n        tokenReduction: `${(tokenReduction * 100).toFixed(1)}%`,\r\n        processingTime: result.metadata.processingTime\r\n      });\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      this.logger.error('Content curation failed', {\r\n        libraryId,\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      \r\n      // Return original content as fallback\r\n      return this.createFallbackContent(context7Content, libraryId, startTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Assess content quality for coding tasks\r\n   */\r\n  private async assessContentQuality(docContent: string, prompt: string): Promise<number> {\r\n    try {\r\n      const response = await this.openaiService.createChatCompletion([\r\n          {\r\n            role: 'system',\r\n            content: `You are a content quality assessor for AI code generation. Rate documentation content on a scale of 1-10 based on:\r\n\r\n1. Code Examples (30%): Presence of practical, runnable code snippets\r\n2. Best Practices (25%): Clear patterns, conventions, and guidelines\r\n3. Relevance (25%): How well it matches the user's coding intent\r\n4. Completeness (20%): Essential information coverage\r\n\r\nReturn ONLY a JSON object with this exact structure:\r\n{\r\n  \"score\": 8.5,\r\n  \"reasoning\": \"Brief explanation of the score\",\r\n  \"strengths\": [\"list\", \"of\", \"strengths\"],\r\n  \"weaknesses\": [\"list\", \"of\", \"weaknesses\"]\r\n}`\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `User Prompt: ${prompt}\r\n\r\nDocumentation Content:\r\n${docContent.substring(0, 2000)}...\r\n\r\nRate this content for AI code generation quality.`\r\n          }\r\n        ], {\r\n        temperature: 0.1,\r\n        maxTokens: 300\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) throw new Error('No response from OpenAI');\r\n\r\n      const parsed = JSON.parse(content);\r\n      return Math.min(10, Math.max(1, parsed.score || 5));\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Quality assessment failed, using default score', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      return 5.0; // Default moderate score\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract key components from content\r\n   */\r\n  private async extractKeyComponents(\r\n    docContent: string,\r\n    prompt: string,\r\n    libraryId: string\r\n  ): Promise<{\r\n    patterns: string[];\r\n    bestPractices: string[];\r\n    codeExamples: string[];\r\n  }> {\r\n    try {\r\n      const response = await this.openaiService.createChatCompletion([\r\n          {\r\n            role: 'system',\r\n            content: `You are a technical content analyzer. Extract key components from documentation for AI code generation.\r\n\r\nReturn ONLY a JSON object with this exact structure:\r\n{\r\n  \"patterns\": [\"pattern1\", \"pattern2\", \"pattern3\"],\r\n  \"bestPractices\": [\"practice1\", \"practice2\", \"practice3\"],\r\n  \"codeExamples\": [\"example1\", \"example2\", \"example3\"]\r\n}\r\n\r\nFocus on:\r\n- Patterns: Common coding patterns and conventions\r\n- Best Practices: Guidelines and recommendations\r\n- Code Examples: Practical, runnable code snippets`\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `Library: ${libraryId}\r\nUser Prompt: ${prompt}\r\n\r\nContent:\r\n${docContent.substring(0, 3000)}...\r\n\r\nExtract key components for AI code generation.`\r\n          }\r\n        ], {\r\n        temperature: 0.2,\r\n        maxTokens: 500\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) throw new Error('No response from OpenAI');\r\n\r\n      const parsed = JSON.parse(content);\r\n      return {\r\n        patterns: parsed.patterns || [],\r\n        bestPractices: parsed.bestPractices || [],\r\n        codeExamples: parsed.codeExamples || []\r\n      };\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Key component extraction failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      \r\n      return {\r\n        patterns: [],\r\n        bestPractices: [],\r\n        codeExamples: []\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Optimize tokens while preserving quality\r\n   */\r\n  private async optimizeTokens(\r\n    content: string,\r\n    keyComponents: any,\r\n    prompt: string,\r\n    libraryId: string\r\n  ): Promise<string> {\r\n    try {\r\n      const targetTokens = Math.ceil(content.length / 4 * (1 - this.config.targetTokenReduction));\r\n      \r\n      const response = await this.openaiService.createChatCompletion([\r\n          {\r\n            role: 'system',\r\n            content: `You are a technical content optimizer for AI code generation. Create a concise, high-quality summary that:\r\n\r\n1. Preserves all essential information for coding\r\n2. Keeps all code examples and patterns\r\n3. Maintains best practices and guidelines\r\n4. Removes boilerplate and marketing content\r\n5. Focuses on practical, actionable information\r\n6. Optimizes for Cursor AI code generation\r\n\r\nTarget length: ~${targetTokens} tokens\r\nFormat: Clean, structured, code-focused content`\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `Library: ${libraryId}\r\nUser Prompt: ${prompt}\r\n\r\nKey Components:\r\n- Patterns: ${keyComponents.patterns.join(', ')}\r\n- Best Practices: ${keyComponents.bestPractices.join(', ')}\r\n- Code Examples: ${keyComponents.codeExamples.length} examples\r\n\r\nOriginal Content:\r\n${content}\r\n\r\nCreate an optimized version for AI code generation.`\r\n          }\r\n        ], {\r\n        temperature: 0.1,\r\n        maxTokens: Math.min(4000, targetTokens * 2)\r\n      });\r\n\r\n      const curatedContent = response.choices[0]?.message?.content;\r\n      if (!curatedContent) throw new Error('No response from OpenAI');\r\n\r\n      return curatedContent;\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Token optimization failed, using original content', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      return content;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create fallback content when curation fails\r\n   */\r\n  private createFallbackContent(\r\n    originalContent: string,\r\n    libraryId: string,\r\n    startTime: number\r\n  ): CuratedContent {\r\n    const originalTokens = Math.ceil(originalContent.length / 4);\r\n    \r\n    return {\r\n      originalContent,\r\n      curatedContent: originalContent,\r\n      qualityScore: 5.0,\r\n      tokenReduction: 0,\r\n      cursorOptimized: false,\r\n      keyPatterns: [],\r\n      bestPractices: [],\r\n      codeExamples: [],\r\n      metadata: {\r\n        libraryId,\r\n        originalTokens,\r\n        curatedTokens: originalTokens,\r\n        processingTime: Date.now() - startTime,\r\n        confidence: 0.5\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Test the curation service\r\n   */\r\n  async testCuration(): Promise<boolean> {\r\n    try {\r\n      const testContent = `\r\n# React Documentation\r\n\r\nReact is a JavaScript library for building user interfaces.\r\n\r\n## Getting Started\r\n\r\n\\`\\`\\`jsx\r\nimport React from 'react';\r\n\r\nfunction App() {\r\n  return <h1>Hello World</h1>;\r\n}\r\n\\`\\`\\`\r\n\r\n## Best Practices\r\n\r\n- Use functional components with hooks\r\n- Keep components small and focused\r\n- Use TypeScript for better development experience\r\n`;\r\n\r\n      const result = await this.curateForCursor(\r\n        testContent,\r\n        '/facebook/react',\r\n        'Create a React component',\r\n        {}\r\n      );\r\n\r\n      return result.qualityScore > 0 && result.curatedContent.length > 0;\r\n\r\n    } catch (error) {\r\n      this.logger.error('Curation test failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n}\r",
        "File: src/services/ai/context7-enhancement-prompts.ts\nDescription: Class definition: Context7EnhancementPrompts\nCode:\nexport class Context7EnhancementPrompts {\r\n  \r\n  /**\r\n   * Select the appropriate enhancement prompt based on strategy and context\r\n   */\r\n  selectContext7EnhancementPrompt(\r\n    strategy: 'general' | 'framework-specific' | 'quality-focused' | 'project-aware',\r\n    framework?: string,\r\n    qualityFocus?: string[],\r\n    projectType?: string\r\n  ): Context7EnhancementPrompt {\r\n    \r\n    switch (strategy) {\r\n      case 'framework-specific':\r\n        return this.getFrameworkSpecificPrompt(framework);\r\n      \r\n      case 'quality-focused':\r\n        return this.getQualityFocusedPrompt(qualityFocus);\r\n      \r\n      case 'project-aware':\r\n        return this.getProjectAwarePrompt(projectType);\r\n      \r\n      case 'general':\r\n      default:\r\n        return this.getGeneralPrompt();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * General Context7 enhancement prompt\r\n   */\r\n  private getGeneralPrompt(): Context7EnhancementPrompt {\r\n    return {\r\n      systemPrompt: `You are an expert developer assistant specializing in enhancing technical documentation. Your task is to transform raw Context7 documentation into clear, actionable, and well-structured guidance that helps developers implement features effectively.\r\n\r\nKey Enhancement Guidelines:\r\n- Make documentation more readable and scannable\r\n- Add clear headings and structure\r\n- Include practical code examples\r\n- Explain the \"why\" behind recommendations\r\n- Add implementation tips and best practices\r\n- Use markdown formatting for better readability\r\n- Keep technical accuracy while improving clarity\r\n\r\nOutput Format:\r\n- Use clear headings (##, ###)\r\n- Include code examples in appropriate language blocks\r\n- Add bullet points for key concepts\r\n- Provide step-by-step guidance where applicable\r\n- Include warnings or important notes when relevant`,\r\n\r\n      userPrompt: `Please enhance the following Context7 documentation to make it more actionable and developer-friendly. Focus on clarity, practical examples, and implementation guidance.\r\n\r\nContext7 Documentation:\r\n{originalDocs}\r\n\r\nEnhanced Documentation:`,\r\n      \r\n      maxTokens: 2000,\r\n      temperature: 0.7\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Framework-specific enhancement prompt\r\n   */\r\n  private getFrameworkSpecificPrompt(framework?: string): Context7EnhancementPrompt {\r\n    const frameworkGuidance = this.getFrameworkGuidance(framework);\r\n    \r\n    return {\r\n      systemPrompt: `You are an expert ${framework || 'framework'} developer specializing in enhancing technical documentation. Your task is to transform raw Context7 documentation into ${framework || 'framework'}-specific, actionable guidance.\r\n\r\n${frameworkGuidance}\r\n\r\nKey Enhancement Guidelines:\r\n- Focus on ${framework || 'framework'}-specific patterns and conventions\r\n- Include ${framework || 'framework'}-specific code examples\r\n- Reference ${framework || 'framework'} best practices\r\n- Use ${framework || 'framework'} terminology and concepts\r\n- Provide ${framework || 'framework'}-specific implementation tips\r\n- Include ${framework || 'framework'} ecosystem considerations\r\n\r\nOutput Format:\r\n- Use clear headings (##, ###)\r\n- Include ${framework || 'framework'} code examples in appropriate language blocks\r\n- Add bullet points for key concepts\r\n- Provide step-by-step guidance where applicable\r\n- Include ${framework || 'framework'}-specific warnings or notes`,\r\n\r\n      userPrompt: `Please enhance the following Context7 documentation specifically for ${framework || 'framework'} development. Make it actionable and follow ${framework || 'framework'} best practices.\r\n\r\nContext7 Documentation:\r\n{originalDocs}\r\n\r\nEnhanced ${framework || 'Framework'} Documentation:`,\r\n      \r\n      maxTokens: 2500,\r\n      temperature: 0.6\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Quality-focused enhancement prompt\r\n   */\r\n  private getQualityFocusedPrompt(qualityFocus?: string[]): Context7EnhancementPrompt {\r\n    const qualityGuidance = this.getQualityGuidance(qualityFocus);\r\n    \r\n    return {\r\n      systemPrompt: `You are an expert developer specializing in ${qualityFocus?.join(', ') || 'code quality'}. Your task is to enhance Context7 documentation with a focus on ${qualityFocus?.join(', ') || 'quality'} considerations.\r\n\r\n${qualityGuidance}\r\n\r\nKey Enhancement Guidelines:\r\n- Emphasize ${qualityFocus?.join(', ') || 'quality'} best practices\r\n- Include ${qualityFocus?.join(', ') || 'quality'}-focused code examples\r\n- Add ${qualityFocus?.join(', ') || 'quality'} checklists or guidelines\r\n- Highlight potential ${qualityFocus?.join(', ') || 'quality'} issues\r\n- Provide ${qualityFocus?.join(', ') || 'quality'} optimization tips\r\n- Include ${qualityFocus?.join(', ') || 'quality'} testing considerations\r\n\r\nOutput Format:\r\n- Use clear headings (##, ###)\r\n- Include quality-focused code examples\r\n- Add quality checklists or guidelines\r\n- Provide step-by-step quality implementation\r\n- Include quality warnings or important notes`,\r\n\r\n      userPrompt: `Please enhance the following Context7 documentation with a focus on ${qualityFocus?.join(', ') || 'code quality'}. Make it actionable and emphasize ${qualityFocus?.join(', ') || 'quality'} best practices.\r\n\r\nContext7 Documentation:\r\n{originalDocs}\r\n\r\nQuality-Focused Enhanced Documentation:`,\r\n      \r\n      maxTokens: 2500,\r\n      temperature: 0.6\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Project-aware enhancement prompt\r\n   */\r\n  private getProjectAwarePrompt(projectType?: string): Context7EnhancementPrompt {\r\n    const projectGuidance = this.getProjectGuidance(projectType);\r\n    \r\n    return {\r\n      systemPrompt: `You are an expert developer specializing in ${projectType || 'software'} projects. Your task is to enhance Context7 documentation with ${projectType || 'project'}-specific considerations and best practices.\r\n\r\n${projectGuidance}\r\n\r\nKey Enhancement Guidelines:\r\n- Focus on ${projectType || 'project'}-specific patterns and architecture\r\n- Include ${projectType || 'project'}-specific code examples\r\n- Reference ${projectType || 'project'} best practices and conventions\r\n- Use ${projectType || 'project'} terminology and concepts\r\n- Provide ${projectType || 'project'}-specific implementation guidance\r\n- Include ${projectType || 'project'} ecosystem and tooling considerations\r\n\r\nOutput Format:\r\n- Use clear headings (##, ###)\r\n- Include ${projectType || 'project'}-specific code examples\r\n- Add bullet points for key concepts\r\n- Provide step-by-step ${projectType || 'project'} implementation\r\n- Include ${projectType || 'project'}-specific warnings or notes`,\r\n\r\n      userPrompt: `Please enhance the following Context7 documentation specifically for ${projectType || 'project'} development. Make it actionable and follow ${projectType || 'project'} best practices.\r\n\r\nContext7 Documentation:\r\n{originalDocs}\r\n\r\n${projectType || 'Project'}-Specific Enhanced Documentation:`,\r\n      \r\n      maxTokens: 2500,\r\n      temperature: 0.6\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Get framework-specific guidance\r\n   */\r\n  private getFrameworkGuidance(framework?: string): string {\r\n    const guidance: Record<string, string> = {\r\n      'react': `\r\nReact-Specific Guidelines:\r\n- Use functional components with hooks\r\n- Follow React naming conventions (PascalCase for components)\r\n- Include proper prop types and TypeScript interfaces\r\n- Show proper state management patterns\r\n- Include useEffect, useState, and custom hooks examples\r\n- Reference React ecosystem tools (Create React App, Next.js, etc.)\r\n- Include JSX syntax and React-specific patterns`,\r\n\r\n      'vue': `\r\nVue-Specific Guidelines:\r\n- Use Vue 3 Composition API patterns\r\n- Follow Vue naming conventions (kebab-case for components)\r\n- Include proper props and emits definitions\r\n- Show reactive data and computed properties\r\n- Include Vue ecosystem tools (Vite, Nuxt.js, etc.)\r\n- Reference Vue-specific patterns and directives`,\r\n\r\n      'angular': `\r\nAngular-Specific Guidelines:\r\n- Use Angular CLI and modern Angular patterns\r\n- Follow Angular naming conventions (PascalCase for components)\r\n- Include proper TypeScript interfaces and decorators\r\n- Show dependency injection and services\r\n- Include Angular ecosystem tools and modules\r\n- Reference Angular-specific patterns and concepts`,\r\n\r\n      'html': `\r\nHTML-Specific Guidelines:\r\n- Use semantic HTML elements\r\n- Include proper accessibility attributes\r\n- Show modern HTML5 features\r\n- Include CSS integration examples\r\n- Reference HTML best practices and standards\r\n- Include responsive design considerations`,\r\n\r\n      'node': `\r\nNode.js-Specific Guidelines:\r\n- Use modern ES6+ JavaScript features\r\n- Follow Node.js conventions and patterns\r\n- Include proper error handling\r\n- Show async/await patterns\r\n- Reference Node.js ecosystem (Express, npm, etc.)\r\n- Include server-side specific considerations`\r\n    };\r\n\r\n    return guidance[framework?.toLowerCase() || ''] || `\r\n${framework || 'Framework'}-Specific Guidelines:\r\n- Use ${framework || 'framework'} conventions and patterns\r\n- Include ${framework || 'framework'}-specific code examples\r\n- Reference ${framework || 'framework'} best practices\r\n- Show ${framework || 'framework'} ecosystem integration\r\n- Include ${framework || 'framework'}-specific considerations`;\r\n  }\r\n\r\n  /**\r\n   * Get quality-focused guidance\r\n   */\r\n  private getQualityGuidance(qualityFocus?: string[]): string {\r\n    if (!qualityFocus || qualityFocus.length === 0) {\r\n      return `\r\nQuality Guidelines:\r\n- Focus on code quality and maintainability\r\n- Include proper error handling\r\n- Show clean code principles\r\n- Add performance considerations\r\n- Include testing best practices`;\r\n    }\r\n\r\n    const guidance: Record<string, string> = {\r\n      'accessibility': `\r\nAccessibility Guidelines:\r\n- Include ARIA attributes and semantic HTML\r\n- Show keyboard navigation patterns\r\n- Add screen reader considerations\r\n- Include color contrast and visual accessibility\r\n- Reference WCAG guidelines and standards\r\n- Show accessibility testing approaches`,\r\n\r\n      'performance': `\r\nPerformance Guidelines:\r\n- Include performance optimization techniques\r\n- Show lazy loading and code splitting\r\n- Add caching strategies\r\n- Include bundle size optimization\r\n- Reference performance monitoring tools\r\n- Show performance testing approaches`,\r\n\r\n      'security': `\r\nSecurity Guidelines:\r\n- Include security best practices\r\n- Show input validation and sanitization\r\n- Add authentication and authorization patterns\r\n- Include security headers and HTTPS\r\n- Reference security testing approaches\r\n- Show vulnerability prevention techniques`,\r\n\r\n      'testing': `\r\nTesting Guidelines:\r\n- Include unit testing patterns\r\n- Show integration testing approaches\r\n- Add end-to-end testing strategies\r\n- Include test-driven development practices\r\n- Reference testing frameworks and tools\r\n- Show testing best practices and patterns`\r\n    };\r\n\r\n    return qualityFocus.map(focus => guidance[focus.toLowerCase()] || `${focus} Guidelines: Focus on ${focus} best practices`).join('\\n\\n');\r\n  }\r\n\r\n  /**\r\n   * Get project-aware guidance\r\n   */\r\n  private getProjectGuidance(projectType?: string): string {\r\n    const guidance: Record<string, string> = {\r\n      'frontend': `\r\nFrontend Project Guidelines:\r\n- Focus on user interface and user experience\r\n- Include responsive design considerations\r\n- Show component-based architecture\r\n- Reference frontend build tools and bundlers\r\n- Include browser compatibility considerations\r\n- Show frontend performance optimization`,\r\n\r\n      'backend': `\r\nBackend Project Guidelines:\r\n- Focus on API design and server-side logic\r\n- Include database integration patterns\r\n- Show authentication and authorization\r\n- Reference backend frameworks and tools\r\n- Include server performance considerations\r\n- Show backend security best practices`,\r\n\r\n      'fullstack': `\r\nFullstack Project Guidelines:\r\n- Focus on end-to-end application development\r\n- Include frontend-backend integration\r\n- Show full-stack architecture patterns\r\n- Reference full-stack frameworks and tools\r\n- Include deployment and DevOps considerations\r\n- Show full-stack testing strategies`,\r\n\r\n      'library': `\r\nLibrary Project Guidelines:\r\n- Focus on reusable code and APIs\r\n- Include proper documentation and examples\r\n- Show versioning and compatibility\r\n- Reference library development tools\r\n- Include distribution and publishing considerations\r\n- Show library testing and validation`,\r\n\r\n      'mobile': `\r\nMobile Project Guidelines:\r\n- Focus on mobile-specific patterns and considerations\r\n- Include responsive design for mobile\r\n- Show mobile performance optimization\r\n- Reference mobile development frameworks\r\n- Include mobile testing approaches\r\n- Show mobile platform considerations`\r\n    };\r\n\r\n    return guidance[projectType?.toLowerCase() || ''] || `\r\n${projectType || 'Project'} Guidelines:\r\n- Focus on ${projectType || 'project'}-specific patterns and architecture\r\n- Include ${projectType || 'project'} best practices\r\n- Show ${projectType || 'project'}-specific implementation\r\n- Reference ${projectType || 'project'} tools and ecosystem\r\n- Include ${projectType || 'project'} considerations and constraints`;\r\n  }\r\n}\r",
        "File: src/services/analytics/semantic-similarity.service.ts\nDescription: Function definition: val1\nCode:\n      const val1 = embedding1[i] || 0;\r\n      const val2 = embedding2[i] || 0;\r\n      dotProduct += val1 * val2;\r\n      norm1 += val1 * val1;\r\n      norm2 += val2 * val2;\r\n    }\r\n\r\n    const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);\r\n    return magnitude === 0 ? 0 : dotProduct / magnitude;\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence in the similarity score\r\n   */\r\n  private calculateConfidence(text1: string, text2: string, similarity: number): number {\r\n    // Base confidence on text length and similarity score\r\n    const minLength = Math.min(text1.length, text2.length);\r\n    const maxLength = Math.max(text1.length, text2.length);\r\n    \r\n    // Longer texts give more confidence\r\n    const lengthConfidence = Math.min(1, minLength / 100);\r\n    \r\n    // Higher similarity gives more confidence\r\n    const similarityConfidence = similarity;\r\n    \r\n    // Combine factors\r\n    return (lengthConfidence * 0.3 + similarityConfidence * 0.7);\r\n  }\r\n\r\n  /**\r\n   * Extract intent from text (simplified)\r\n   */\r\n  private extractIntent(text: string): string {\r\n    // Simple intent extraction - remove common words and focus on key concepts\r\n    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'how', 'what', 'when', 'where', 'why', 'can', 'could', 'should', 'would', 'will', 'do', 'does', 'did']);\r\n    \r\n    return text\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 2 && !stopWords.has(word))\r\n      .join(' ');\r\n  }\r\n\r\n  /**\r\n   * Create fallback result when similarity calculation fails\r\n   */\r\n  private createFallbackResult(text1: string, text2: string, startTime?: number): SimilarityResult {\r\n    // Simple text-based similarity as fallback\r\n    const similarity = this.calculateTextSimilarity(text1, text2);\r\n    \r\n    return {\r",
        "File: src/services/analytics/semantic-similarity.service.ts\nDescription: Function definition: val2\nCode:\n      const val2 = embedding2[i] || 0;\r\n      dotProduct += val1 * val2;\r\n      norm1 += val1 * val1;\r\n      norm2 += val2 * val2;\r\n    }\r\n\r\n    const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);\r\n    return magnitude === 0 ? 0 : dotProduct / magnitude;\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence in the similarity score\r\n   */\r\n  private calculateConfidence(text1: string, text2: string, similarity: number): number {\r\n    // Base confidence on text length and similarity score\r\n    const minLength = Math.min(text1.length, text2.length);\r\n    const maxLength = Math.max(text1.length, text2.length);\r\n    \r\n    // Longer texts give more confidence\r\n    const lengthConfidence = Math.min(1, minLength / 100);\r\n    \r\n    // Higher similarity gives more confidence\r\n    const similarityConfidence = similarity;\r\n    \r\n    // Combine factors\r\n    return (lengthConfidence * 0.3 + similarityConfidence * 0.7);\r\n  }\r\n\r\n  /**\r\n   * Extract intent from text (simplified)\r\n   */\r\n  private extractIntent(text: string): string {\r\n    // Simple intent extraction - remove common words and focus on key concepts\r\n    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'how', 'what', 'when', 'where', 'why', 'can', 'could', 'should', 'would', 'will', 'do', 'does', 'did']);\r\n    \r\n    return text\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 2 && !stopWords.has(word))\r\n      .join(' ');\r\n  }\r\n\r\n  /**\r\n   * Create fallback result when similarity calculation fails\r\n   */\r\n  private createFallbackResult(text1: string, text2: string, startTime?: number): SimilarityResult {\r\n    // Simple text-based similarity as fallback\r\n    const similarity = this.calculateTextSimilarity(text1, text2);\r\n    \r\n    return {\r",
        "File: src/services/analytics/semantic-similarity.service.ts\nDescription: Function definition: stopWords\nCode:\n    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'how', 'what', 'when', 'where', 'why', 'can', 'could', 'should', 'would', 'will', 'do', 'does', 'did']);\r\n    \r\n    return text\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 2 && !stopWords.has(word))\r\n      .join(' ');\r\n  }\r\n\r\n  /**\r\n   * Create fallback result when similarity calculation fails\r\n   */\r\n  private createFallbackResult(text1: string, text2: string, startTime?: number): SimilarityResult {\r",
        "File: src/services/analytics/semantic-similarity.service.ts\nDescription: Class definition: SemanticSimilarityService\nCode:\nexport class SemanticSimilarityService {\r\n  private logger: Logger;\r\n  private openaiService: OpenAIService;\r\n  private config: SimilarityConfig;\r\n\r\n  constructor(logger: Logger, openaiService: OpenAIService, config?: Partial<SimilarityConfig>) {\r\n    this.logger = logger;\r\n    this.openaiService = openaiService;\r\n    this.config = {\r\n      enabled: true,\r\n      model: 'text-embedding-3-small',\r\n      threshold: {\r\n        high: 0.8,\r\n        medium: 0.6,\r\n        low: 0.4\r\n      },\r\n      maxTokens: 8000,\r\n      timeout: 10000,\r\n      ...config\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate semantic similarity between two texts\r\n   */\r\n  async calculateSimilarity(\r\n    text1: string,\r\n    text2: string,\r\n    context?: string\r\n  ): Promise<SimilarityResult> {\r\n    if (!this.config.enabled) {\r\n      return this.createFallbackResult(text1, text2);\r\n    }\r\n\r\n    const startTime = Date.now();\r\n\r\n    try {\r\n      this.logger.debug('Calculating semantic similarity', {\r\n        text1Length: text1.length,\r\n        text2Length: text2.length,\r\n        hasContext: !!context\r\n      });\r\n\r\n      // Get embeddings for both texts\r\n      const [embedding1, embedding2] = await Promise.all([\r\n        this.getEmbedding(text1),\r\n        this.getEmbedding(text2)\r\n      ]);\r\n\r\n      // Calculate cosine similarity\r\n      const similarity = this.calculateCosineSimilarity(embedding1, embedding2);\r\n      \r\n      // Calculate confidence based on text length and similarity\r\n      const confidence = this.calculateConfidence(text1, text2, similarity);\r\n\r\n      const result: SimilarityResult = {\r\n        score: similarity,\r\n        confidence,\r\n        method: 'embeddings',\r\n        metadata: {\r\n          processingTime: Date.now() - startTime,\r\n          tokenCount: Math.ceil((text1.length + text2.length) / 4),\r\n          model: this.config.model\r\n        }\r\n      };\r\n\r\n      this.logger.debug('Semantic similarity calculated', {\r\n        similarity: similarity.toFixed(3),\r\n        confidence: confidence.toFixed(3),\r\n        processingTime: result.metadata.processingTime\r\n      });\r\n\r\n      return result;\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Semantic similarity calculation failed, using fallback', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      \r\n      return this.createFallbackResult(text1, text2, startTime);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate prompt-response similarity\r\n   */\r\n  async calculatePromptResponseSimilarity(\r\n    originalPrompt: string,\r\n    enhancedPrompt: string,\r\n    context?: string\r\n  ): Promise<SimilarityResult> {\r\n    return this.calculateSimilarity(originalPrompt, enhancedPrompt, context);\r\n  }\r\n\r\n  /**\r\n   * Calculate intent preservation score\r\n   */\r\n  async calculateIntentPreservation(\r\n    originalPrompt: string,\r\n    enhancedPrompt: string,\r\n    context?: string\r\n  ): Promise<SimilarityResult> {\r\n    // For intent preservation, we focus on key concepts and intent\r\n    const intent1 = this.extractIntent(originalPrompt);\r\n    const intent2 = this.extractIntent(enhancedPrompt);\r\n    \r\n    return this.calculateSimilarity(intent1, intent2, context);\r\n  }\r\n\r\n  /**\r\n   * Get embedding for text using OpenAI\r\n   */\r\n  private async getEmbedding(text: string): Promise<number[]> {\r\n    try {\r\n      // Truncate text if too long\r\n      const truncatedText = text.length > this.config.maxTokens * 4 \r\n        ? text.substring(0, this.config.maxTokens * 4)\r\n        : text;\r\n\r\n      const response = await this.openaiService.createChatCompletion([\r\n        {\r\n          role: 'user',\r\n          content: `Generate an embedding for this text: ${truncatedText}`\r\n        }\r\n      ], {\r\n        model: this.config.model,\r\n        maxTokens: 1\r\n      });\r\n\r\n      // For now, return a mock embedding since we don't have direct embedding API access\r\n      // In a real implementation, you would use the embeddings API\r\n      return this.generateMockEmbedding(truncatedText);\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Failed to get embedding, using fallback', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      return this.generateMockEmbedding(text);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate a mock embedding for testing\r\n   */\r\n  private generateMockEmbedding(text: string): number[] {\r\n    // Simple hash-based mock embedding\r\n    const hash = this.simpleHash(text);\r\n    const embedding = new Array(1536).fill(0);\r\n    \r\n    // Distribute hash values across embedding dimensions\r\n    for (let i = 0; i < 1536; i++) {\r\n      embedding[i] = Math.sin(hash + i) * 0.1;\r\n    }\r\n    \r\n    return embedding;\r\n  }\r\n\r\n  /**\r\n   * Simple hash function for mock embeddings\r\n   */\r\n  private simpleHash(str: string): number {\r\n    let hash = 0;\r\n    for (let i = 0; i < str.length; i++) {\r\n      const char = str.charCodeAt(i);\r\n      hash = ((hash << 5) - hash) + char;\r\n      hash = hash & hash; // Convert to 32-bit integer\r\n    }\r\n    return Math.abs(hash);\r\n  }\r\n\r\n  /**\r\n   * Calculate cosine similarity between two embeddings\r\n   */\r\n  private calculateCosineSimilarity(embedding1: number[], embedding2: number[]): number {\r\n    if (embedding1.length !== embedding2.length) {\r\n      return 0;\r\n    }\r\n\r\n    let dotProduct = 0;\r\n    let norm1 = 0;\r\n    let norm2 = 0;\r\n\r\n    for (let i = 0; i < embedding1.length; i++) {\r\n      const val1 = embedding1[i] || 0;\r\n      const val2 = embedding2[i] || 0;\r\n      dotProduct += val1 * val2;\r\n      norm1 += val1 * val1;\r\n      norm2 += val2 * val2;\r\n    }\r\n\r\n    const magnitude = Math.sqrt(norm1) * Math.sqrt(norm2);\r\n    return magnitude === 0 ? 0 : dotProduct / magnitude;\r\n  }\r\n\r\n  /**\r\n   * Calculate confidence in the similarity score\r\n   */\r\n  private calculateConfidence(text1: string, text2: string, similarity: number): number {\r\n    // Base confidence on text length and similarity score\r\n    const minLength = Math.min(text1.length, text2.length);\r\n    const maxLength = Math.max(text1.length, text2.length);\r\n    \r\n    // Longer texts give more confidence\r\n    const lengthConfidence = Math.min(1, minLength / 100);\r\n    \r\n    // Higher similarity gives more confidence\r\n    const similarityConfidence = similarity;\r\n    \r\n    // Combine factors\r\n    return (lengthConfidence * 0.3 + similarityConfidence * 0.7);\r\n  }\r\n\r\n  /**\r\n   * Extract intent from text (simplified)\r\n   */\r\n  private extractIntent(text: string): string {\r\n    // Simple intent extraction - remove common words and focus on key concepts\r\n    const stopWords = new Set(['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were', 'how', 'what', 'when', 'where', 'why', 'can', 'could', 'should', 'would', 'will', 'do', 'does', 'did']);\r\n    \r\n    return text\r\n      .toLowerCase()\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 2 && !stopWords.has(word))\r\n      .join(' ');\r\n  }\r\n\r\n  /**\r\n   * Create fallback result when similarity calculation fails\r\n   */\r\n  private createFallbackResult(text1: string, text2: string, startTime?: number): SimilarityResult {\r\n    // Simple text-based similarity as fallback\r\n    const similarity = this.calculateTextSimilarity(text1, text2);\r\n    \r\n    return {\r\n      score: similarity,\r\n      confidence: 0.3, // Low confidence for fallback\r\n      method: 'fallback',\r\n      metadata: {\r\n        processingTime: startTime ? Date.now() - startTime : 0,\r\n        tokenCount: Math.ceil((text1.length + text2.length) / 4),\r\n        model: 'fallback'\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Calculate simple text-based similarity\r\n   */\r\n  private calculateTextSimilarity(text1: string, text2: string): number {\r\n    const words1 = new Set(text1.toLowerCase().split(/\\s+/));\r\n    const words2 = new Set(text2.toLowerCase().split(/\\s+/));\r\n    \r\n    const intersection = new Set([...words1].filter(x => words2.has(x)));\r\n    const union = new Set([...words1, ...words2]);\r\n    \r\n    return intersection.size / union.size;\r\n  }\r\n\r\n  /**\r\n   * Get similarity level based on score\r\n   */\r\n  getSimilarityLevel(score: number): 'high' | 'medium' | 'low' | 'none' {\r\n    if (score >= this.config.threshold.high) return 'high';\r\n    if (score >= this.config.threshold.medium) return 'medium';\r\n    if (score >= this.config.threshold.low) return 'low';\r\n    return 'none';\r\n  }\r\n\r\n  /**\r\n   * Format similarity result for display\r\n   */\r\n  formatSimilarityResult(result: SimilarityResult): string {\r\n    const level = this.getSimilarityLevel(result.score);\r\n    const percentage = (result.score * 100).toFixed(1);\r\n    const confidence = (result.confidence * 100).toFixed(1);\r\n    \r\n    return `${percentage}% similarity (${level}, ${confidence}% confidence)`;\r\n  }\r\n\r\n  /**\r\n   * Get service configuration\r\n   */\r\n  getConfig(): SimilarityConfig {\r\n    return { ...this.config };\r\n  }\r\n\r\n  /**\r\n   * Update service configuration\r\n   */\r\n  updateConfig(newConfig: Partial<SimilarityConfig>): void {\r\n    this.config = { ...this.config, ...newConfig };\r\n    this.logger.info('Semantic similarity configuration updated', this.config);\r\n  }\r\n}\r",
        "File: src/tools/enhance/prompt-analyzer.service.ts\nDescription: Function definition: simplePatterns\nCode:\n    const simplePatterns = [\r\n      /^(yes|no|ok|sure|maybe)\\s*$/i,\r\n      /^(yes|no)\\s+or\\s+(yes|no)/i,\r\n      /^(what|how|when|where|why)\\s+\\w+\\?$/i,\r\n      /^(is|are|was|were|do|does|did|can|could|will|would)\\s+\\w+/i,\r\n      /^what\\s+is\\s+\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\??$/i,  // Math questions like \"What is 2+2?\"\r\n      /^\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\??$/i,  // Direct math like \"2+2?\"\r\n      /^what\\s+is\\s+\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\s*\\??$/i,  // \"What is 2+2\" without question mark\r\n      /^how\\s+do\\s+i\\s+create\\s+a\\s+(\\w+)\\??$/i,  // Simple element creation questions\r\n      /^how\\s+to\\s+create\\s+a\\s+(\\w+)\\??$/i,  // Simple element creation questions\r\n      /^how\\s+do\\s+i\\s+make\\s+a\\s+(\\w+)\\??$/i  // Simple element creation questions\r\n    ];\r\n    \r\n    if (simplePatterns.some(pattern => pattern.test(prompt.trim()))) {\r\n      score += 2;\r\n      indicators.push('simple-question');\r\n    }\r",
        "File: src/tools/enhance/prompt-analyzer.service.ts\nDescription: Class definition: PromptAnalyzerService\nCode:\nexport class PromptAnalyzerService {\r\n  private logger: Logger;\r\n  private openaiService?: OpenAIService | undefined;\r\n\r\n  constructor(logger: Logger, openaiService?: OpenAIService | undefined) {\r\n    this.logger = logger;\r\n    this.openaiService = openaiService;\r\n  }\r\n\r\n  /**\r\n   * Analyze prompt complexity to determine appropriate response strategy\r\n   * Implements intelligent complexity detection with multiple indicators\r\n   */\r\n  analyzePromptComplexity(prompt: string): PromptComplexity {\r\n    const indicators: string[] = [];\r\n    let score = 0;\r\n    \r\n    // Length-based scoring\r\n    if (prompt.length < 20) {\r\n      score += 3;\r\n      indicators.push('very-short');\r\n    } else if (prompt.length < 50) {\r\n      score += 2;\r\n      indicators.push('short');\r\n    } else if (prompt.length > 200) {\r\n      score += 1;\r\n      indicators.push('long');\r\n    }\r\n    \r\n    // Simple question patterns\r\n    const simplePatterns = [\r\n      /^(yes|no|ok|sure|maybe)\\s*$/i,\r\n      /^(yes|no)\\s+or\\s+(yes|no)/i,\r\n      /^(what|how|when|where|why)\\s+\\w+\\?$/i,\r\n      /^(is|are|was|were|do|does|did|can|could|will|would)\\s+\\w+/i,\r\n      /^what\\s+is\\s+\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\??$/i,  // Math questions like \"What is 2+2?\"\r\n      /^\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\??$/i,  // Direct math like \"2+2?\"\r\n      /^what\\s+is\\s+\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\s*\\??$/i,  // \"What is 2+2\" without question mark\r\n      /^how\\s+do\\s+i\\s+create\\s+a\\s+(\\w+)\\??$/i,  // Simple element creation questions\r\n      /^how\\s+to\\s+create\\s+a\\s+(\\w+)\\??$/i,  // Simple element creation questions\r\n      /^how\\s+do\\s+i\\s+make\\s+a\\s+(\\w+)\\??$/i  // Simple element creation questions\r\n    ];\r\n    \r\n    if (simplePatterns.some(pattern => pattern.test(prompt.trim()))) {\r\n      score += 2;\r\n      indicators.push('simple-question');\r\n    }\r\n    \r\n    // Complex development patterns\r\n    const complexPatterns = [\r\n      /create|build|implement|develop/i,\r\n      /component|function|class|service/i,\r\n      /api|endpoint|database|schema/i,\r\n      /test|testing|debug|fix/i,\r\n      /deploy|production|staging/i\r\n    ];\r\n    \r\n    const complexMatches = complexPatterns.filter(pattern => pattern.test(prompt));\r\n    if (complexMatches.length > 0) {\r\n      score -= complexMatches.length;\r\n      indicators.push(...complexMatches.map(() => 'development-task'));\r\n    }\r\n    \r\n    // Framework-specific complexity\r\n    const frameworkKeywords = [\r\n      'react', 'vue', 'angular', 'typescript', 'javascript',\r\n      'node', 'express', 'next', 'nuxt', 'svelte'\r\n    ];\r\n    \r\n    const frameworkMatches = frameworkKeywords.filter(keyword => \r\n      prompt.toLowerCase().includes(keyword)\r\n    );\r\n    if (frameworkMatches.length > 0) {\r\n      score -= frameworkMatches.length * 0.5;\r\n      indicators.push(...frameworkMatches.map(() => 'framework-specific'));\r\n    }\r\n    \r\n    // Determine complexity level\r\n    let level: 'simple' | 'medium' | 'complex';\r\n    if (score >= 2) {\r\n      level = 'simple';\r\n    } else if (score >= 0) {\r\n      level = 'medium';\r\n    } else {\r\n      level = 'complex';\r\n    }\r\n    \r\n    this.logger.debug('Prompt complexity analysis', {\r\n      prompt: prompt.substring(0, 100) + '...',\r\n      level,\r\n      score,\r\n      indicators\r\n    });\r\n    \r\n    return { level, score, indicators };\r\n  }\r\n\r\n  /**\r\n   * Analyze prompt complexity with AI and project context\r\n   * REDESIGNED: Uses OpenAI for intelligent complexity analysis with project context\r\n   */\r\n  async analyzePromptComplexityWithContext(\r\n    prompt: string, \r\n    projectContext: ProjectContext\r\n  ): Promise<AIPromptComplexity> {\r\n    try {\r\n      // If OpenAI is not available, fall back to basic analysis\r\n      if (!this.openaiService) {\r\n        this.logger.debug('OpenAI not available, falling back to basic analysis');\r\n        const basicComplexity = this.analyzePromptComplexity(prompt);\r\n        return {\r\n          ...basicComplexity,\r\n          userExpertiseLevel: this.inferUserExpertiseLevel(projectContext),\r\n          responseStrategy: this.determineResponseStrategy(basicComplexity.level),\r\n          estimatedTokens: this.estimateTokens(basicComplexity.level),\r\n          confidence: 0.6 // Lower confidence for basic analysis\r\n        };\r\n      }\r\n\r\n      this.logger.debug('Starting AI-powered prompt complexity analysis', {\r\n        prompt: prompt.substring(0, 100) + '...',\r\n        projectContextSize: projectContext.repoFacts.length + projectContext.codeSnippets.length\r\n      });\r\n\r\n      // Create context-aware analysis prompt\r\n      const analysisPrompt = this.buildAnalysisPrompt(prompt, projectContext);\r\n      \r\n      const response = await this.openaiService.createChatCompletion([\r\n        {\r\n          role: 'system',\r\n          content: `You are an expert at analyzing developer prompts and determining their complexity level. \r\n\r\nYour job is to:\r\n1. Analyze the user's prompt for complexity indicators\r\n2. Consider the project context (frameworks, code patterns, project type)\r\n3. Determine the user's expertise level based on project context\r\n4. Recommend the best response strategy\r\n5. Estimate token requirements for an optimal response\r\n\r\nReturn ONLY valid JSON with this exact structure:\r\n{\r\n  \"level\": \"simple|medium|complex\",\r\n  \"score\": 1-10,\r\n  \"indicators\": [\"indicator1\", \"indicator2\"],\r\n  \"userExpertiseLevel\": \"beginner|intermediate|advanced\",\r\n  \"responseStrategy\": \"minimal|standard|comprehensive\",\r\n  \"estimatedTokens\": 500,\r\n  \"confidence\": 0.85\r\n}\r\n\r\nGuidelines:\r\n- Simple: Basic questions, single tasks, clear requests (score 7-10)\r\n- Medium: Multi-step tasks, some complexity, moderate context needed (score 4-6)\r\n- Complex: Large projects, multiple technologies, extensive context needed (score 1-3)\r\n- Consider project context when determining user expertise level\r\n- Estimate tokens based on complexity and context needed\r\n- Be confident in your analysis (0.7-0.95)`\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: analysisPrompt\r\n        }\r\n      ], {\r\n        maxTokens: 500,\r\n        temperature: 0.2 // Low temperature for consistent analysis\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) {\r\n        throw new Error('No response content from OpenAI');\r\n      }\r\n\r\n      // Parse and validate the AI response\r\n      const aiComplexity = this.parseAIComplexityResponse(content);\r\n      \r\n      this.logger.debug('AI complexity analysis completed', {\r\n        level: aiComplexity.level,\r\n        score: aiComplexity.score,\r\n        userExpertiseLevel: aiComplexity.userExpertiseLevel,\r\n        confidence: aiComplexity.confidence,\r\n        estimatedTokens: aiComplexity.estimatedTokens\r\n      });\r\n\r\n      // Log AI usage for monitoring\r\n      this.logger.info('AI complexity analysis usage', {\r\n        operation: 'prompt_complexity_analysis',\r\n        tokensUsed: response.usage?.total_tokens || 0,\r\n        cost: this.estimateAICost(response.usage?.total_tokens || 0),\r\n        confidence: aiComplexity.confidence\r\n      });\r\n\r\n      return aiComplexity;\r\n\r\n    } catch (error) {\r\n      this.logger.warn('AI complexity analysis failed, falling back to basic analysis', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        prompt: prompt.substring(0, 100) + '...'\r\n      });\r\n      \r\n      // Fallback to basic analysis\r\n      const basicComplexity = this.analyzePromptComplexity(prompt);\r\n      return {\r\n        ...basicComplexity,\r\n        userExpertiseLevel: this.inferUserExpertiseLevel(projectContext),\r\n        responseStrategy: this.determineResponseStrategy(basicComplexity.level),\r\n        estimatedTokens: this.estimateTokens(basicComplexity.level),\r\n        confidence: 0.5 // Lower confidence due to fallback\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get optimized options based on prompt complexity\r\n   * Implements adaptive response sizing for better user experience\r\n   */\r\n  getOptimizedOptions(\r\n    originalOptions: any,\r\n    complexity: PromptComplexity\r\n  ): OptimizedOptions {\r\n    const options = { ...originalOptions };\r\n    \r\n    switch (complexity.level) {\r\n      case 'simple':\r\n        // Minimal context for simple prompts like \"yes or no\" (reduced by 20%)\r\n        options.maxTokens = Math.min(options.maxTokens || 4000, 400);\r\n        options.includeMetadata = false;\r\n        options.useCache = true;\r\n        options.simpleMode = true;\r\n        break;\r\n        \r\n      case 'medium':\r\n        // Moderate context for medium complexity prompts (reduced by 20%)\r\n        options.maxTokens = Math.min(options.maxTokens || 4000, 1200);\r\n        options.includeMetadata = true;\r\n        options.useCache = true;\r\n        break;\r\n        \r\n      case 'complex':\r\n        // Full context for complex development tasks (reduced by 20%)\r\n        options.maxTokens = Math.min(options.maxTokens || 4000, 3200);\r\n        options.includeMetadata = true;\r\n        options.useCache = true;\r\n        break;\r\n    }\r\n    \r\n    this.logger.debug('Optimized options generated', {\r\n      complexity: complexity.level,\r\n      maxTokens: options.maxTokens,\r\n      includeMetadata: options.includeMetadata,\r\n      useCache: options.useCache\r\n    });\r\n    \r\n    return options;\r\n  }\r\n\r\n  /**\r\n   * Check if a prompt should trigger breakdown functionality\r\n   * Analyzes prompt characteristics to determine if task breakdown would be beneficial\r\n   */\r\n  shouldBreakdown(prompt: string, options?: { includeBreakdown?: boolean; maxTasks?: number }): boolean {\r\n    try {\r\n      // If explicitly disabled, don't breakdown\r\n      if (options?.includeBreakdown === false) {\r\n        return false;\r\n      }\r\n\r\n      // If explicitly enabled, always breakdown\r\n      if (options?.includeBreakdown === true) {\r\n        return true;\r\n      }\r\n\r\n      // Auto-detect based on prompt characteristics\r\n      const promptLower = prompt.toLowerCase();\r\n      \r\n      // Keywords that suggest complex, multi-step projects\r\n      // Keywords that suggest complex, multi-step tasks (dynamic detection)\r\n      const complexKeywords = this.getComplexKeywords();\r\n      \r\n      // Keywords that suggest simple, single tasks (dynamic detection)\r\n      const simpleKeywords = this.getSimpleKeywords();\r\n      \r\n      const hasComplexKeywords = complexKeywords.some(keyword => promptLower.includes(keyword));\r\n      const hasSimpleKeywords = simpleKeywords.some(keyword => promptLower.includes(keyword));\r\n      \r\n      // Check prompt length (longer prompts are more likely to be complex)\r\n      const isLongPrompt = prompt.length > 100;\r\n      \r\n      // Check for multiple sentences or bullet points (suggests multiple tasks)\r\n      const hasMultipleParts = prompt.includes('.') && prompt.split('.').length > 2;\r\n      const hasBulletPoints = prompt.includes('-') || prompt.includes('*') || prompt.includes('');\r\n      \r\n      // Decision logic\r\n      if (hasComplexKeywords && (isLongPrompt || hasMultipleParts || hasBulletPoints)) {\r\n        return true;\r\n      }\r\n      \r\n      if (hasSimpleKeywords && !isLongPrompt) {\r\n        return false;\r\n      }\r\n      \r\n      // Default to breakdown for medium-length prompts with project keywords\r\n      return isLongPrompt && (hasComplexKeywords || hasMultipleParts);\r\n      \r\n    } catch (error) {\r\n      this.logger.warn('Error detecting prompt complexity for breakdown', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        prompt: prompt.substring(0, 100) + '...'\r\n      });\r\n      return false;\r\n    }\r\n  }\r",
        "File: src/config/config.service.ts\nDescription: Class definition: ConfigService\nCode:\nexport class ConfigService {\r\n  private config: PromptMCPConfig;\r\n  private logger: Logger;\r\n\r\n  constructor() {\r\n    this.logger = new Logger('ConfigService');\r\n    this.loadMCPConfiguration();\r\n    this.config = this.loadConfig();\r\n    this.validateConfig();\r\n  }\r\n\r\n  private loadMCPConfiguration(): void {\r\n    try {\r\n      const mcpConfigPath = process.env.MCP_CONFIG_PATH || join(process.cwd(), 'mcp-config.json');\r\n      this.logger.info('Loading MCP configuration from', { path: mcpConfigPath });\r\n      \r\n      const mcpConfig = JSON.parse(readFileSync(mcpConfigPath, 'utf8'));\r\n      const promptmcpConfig = mcpConfig.mcpServers.promptmcp;\r\n      \r\n      // DEBUG: Print what we're loading\r\n      console.log(' [ConfigService] Loading MCP configuration:');\r\n      console.log('  MCP Config Path:', mcpConfigPath);\r\n      console.log('  PromptMCP Config:', promptmcpConfig);\r\n      console.log('  Environment variables before loading:', {\r\n        OPENAI_API_KEY: process.env.OPENAI_API_KEY ? `${process.env.OPENAI_API_KEY.substring(0, 20)}...` : 'NOT SET',\r\n        OPENAI_PROJECT_ID: process.env.OPENAI_PROJECT_ID || 'NOT SET',\r\n        CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY ? `${process.env.CONTEXT7_API_KEY.substring(0, 20)}...` : 'NOT SET'\r\n      });\r\n      \r\n      if (promptmcpConfig && promptmcpConfig.env) {\r\n        // Load API keys from MCP config into environment variables\r\n        if (promptmcpConfig.env.CONTEXT7_API_KEY) {\r\n          process.env.CONTEXT7_API_KEY = promptmcpConfig.env.CONTEXT7_API_KEY;\r\n          console.log('   Set CONTEXT7_API_KEY from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.OPENAI_API_KEY) {\r\n          process.env.OPENAI_API_KEY = promptmcpConfig.env.OPENAI_API_KEY;\r\n          console.log('   Set OPENAI_API_KEY from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.OPENAI_PROJECT_ID) {\r\n          process.env.OPENAI_PROJECT_ID = promptmcpConfig.env.OPENAI_PROJECT_ID;\r\n          console.log('   Set OPENAI_PROJECT_ID from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.CONTEXT7_ENABLED) {\r\n          process.env.CONTEXT7_ENABLED = promptmcpConfig.env.CONTEXT7_ENABLED;\r\n          console.log('   Set CONTEXT7_ENABLED from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.CONTEXT7_USE_HTTP_ONLY) {\r\n          process.env.CONTEXT7_USE_HTTP_ONLY = promptmcpConfig.env.CONTEXT7_USE_HTTP_ONLY;\r\n          console.log('   Set CONTEXT7_USE_HTTP_ONLY from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.CONTEXT7_DEBUG) {\r\n          process.env.CONTEXT7_DEBUG = promptmcpConfig.env.CONTEXT7_DEBUG;\r\n          this.logger.info('CONTEXT7_DEBUG environment variable set', { value: promptmcpConfig.env.CONTEXT7_DEBUG });\r\n          console.log('   Set CONTEXT7_DEBUG from MCP config');\r\n        }\r\n        \r\n        // DEBUG: Print environment variables after loading\r\n        console.log('  Environment variables after loading:', {\r\n          OPENAI_API_KEY: process.env.OPENAI_API_KEY ? `${process.env.OPENAI_API_KEY.substring(0, 20)}...` : 'NOT SET',\r\n          OPENAI_PROJECT_ID: process.env.OPENAI_PROJECT_ID || 'NOT SET',\r\n          CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY ? `${process.env.CONTEXT7_API_KEY.substring(0, 20)}...` : 'NOT SET'\r\n        });\r\n        \r\n        this.logger.info('MCP configuration loaded successfully', {\r\n          hasContext7Key: !!process.env.CONTEXT7_API_KEY,\r\n          hasOpenAIKey: !!process.env.OPENAI_API_KEY,\r\n          hasOpenAIProjectId: !!process.env.OPENAI_PROJECT_ID\r\n        });\r\n      } else {\r\n        this.logger.warn('No promptmcp configuration found in MCP config, falling back to environment variables');\r\n        this.loadEnvironmentVariables();\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to load MCP configuration, falling back to environment variables', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      this.loadEnvironmentVariables();\r\n    }\r\n  }\r\n\r\n  private loadEnvironmentVariables(): void {\r\n    // Load Context7 API key from environment or use default\r\n    if (!process.env.CONTEXT7_API_KEY) {\r\n      this.logger.warn('CONTEXT7_API_KEY not found in environment variables');\r\n    }\r\n    \r\n    // Set default Context7 enabled state if not provided\r\n    if (!process.env.CONTEXT7_ENABLED) {\r\n      process.env.CONTEXT7_ENABLED = 'true';\r\n    }\r\n    \r\n    if (!process.env.CONTEXT7_BASE_URL) {\r\n      process.env.CONTEXT7_BASE_URL = 'https://mcp.context7.com/mcp';\r\n    }\r\n\r\n    // Set OpenAI environment variables if not provided\r\n    if (!process.env.OPENAI_API_KEY) {\r\n      this.logger.warn('OPENAI_API_KEY not set - breakdown tool will not be available');\r\n    }\r\n    \r\n    if (!process.env.OPENAI_PROJECT_ID) {\r\n      this.logger.warn('OPENAI_PROJECT_ID not set - breakdown tool will not be available');\r\n    }\r\n  }\r\n\r\n  getConfig(): PromptMCPConfig {\r\n    return this.config;\r\n  }\r\n\r\n  get<K extends keyof PromptMCPConfig>(key: K): PromptMCPConfig[K] {\r\n    return this.config[key];\r\n  }\r\n\r\n  getWithDefault<K extends keyof PromptMCPConfig>(key: K, defaultValue: PromptMCPConfig[K]): PromptMCPConfig[K] {\r\n    return this.config[key] ?? defaultValue;\r\n  }\r\n\r\n  getEnv(key: string, defaultValue: string = ''): string {\r\n    return process.env[key] ?? defaultValue;\r\n  }\r\n\r\n  getNested<K extends keyof PromptMCPConfig, T extends keyof PromptMCPConfig[K]>(\r\n    section: K,\r\n    key: T\r\n  ): PromptMCPConfig[K][T] {\r\n    return this.config[section][key];\r\n  }\r\n\r\n  private loadConfig(): PromptMCPConfig {\r\n    const config: PromptMCPConfig = {\r\n      server: {\r\n        name: process.env.LOCALMCP_NAME || 'localmcp',\r\n        version: process.env.LOCALMCP_VERSION || '1.0.0',\r\n        port: parseInt(process.env.LOCALMCP_PORT || '3000', 10)\r\n      },\r\n      context7: {\r\n        enabled: process.env.CONTEXT7_ENABLED === 'true',\r\n        apiKey: process.env.CONTEXT7_API_KEY || undefined,\r\n        baseUrl: process.env.CONTEXT7_BASE_URL || 'https://api.context7.io',\r\n        cacheEnabled: process.env.CONTEXT7_CACHE_ENABLED !== 'false',\r\n        cacheTtl: parseInt(process.env.CONTEXT7_CACHE_TTL || '3600', 10),\r\n        useHttpOnly: process.env.CONTEXT7_USE_HTTP_ONLY === 'true',\r\n        checkCompatibility: process.env.CONTEXT7_CHECK_COMPATIBILITY !== 'false',\r\n        mcp: {\r\n          enabled: process.env.CONTEXT7_MCP_ENABLED === 'true',\r\n          serverUrl: process.env.CONTEXT7_MCP_URL || 'http://localhost:3001',\r\n          timeout: parseInt(process.env.CONTEXT7_MCP_TIMEOUT || '30000', 10)\r\n        }\r\n      },\r\n      database: {\r\n        type: (process.env.DATABASE_TYPE as 'sqlite' | 'qdrant') || 'sqlite',\r\n        path: process.env.DATABASE_PATH || './data/localmcp.db',\r\n        url: process.env.QDRANT_URL || undefined,\r\n        apiKey: process.env.QDRANT_API_KEY || undefined\r\n      },\r\n      vector: {\r\n        qdrant: {\r\n          url: process.env.QDRANT_URL || 'http://localhost:6333',\r\n          apiKey: process.env.QDRANT_API_KEY || undefined,\r\n          collections: {\r\n            documents: process.env.QDRANT_COLLECTION_DOCUMENTS || 'localmcp_documents',\r\n            lessons: process.env.QDRANT_COLLECTION_LESSONS || 'localmcp_lessons',\r\n            patterns: process.env.QDRANT_COLLECTION_PATTERNS || 'localmcp_patterns'\r\n          }\r\n        }\r\n      },\r\n      openai: {\r\n        apiKey: process.env.OPENAI_API_KEY || undefined,\r\n        projectId: process.env.OPENAI_PROJECT_ID || undefined,\r\n        model: process.env.OPENAI_MODEL || 'gpt-4',\r\n        maxTokens: parseInt(process.env.OPENAI_MAX_TOKENS || '4000', 10),\r\n        temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.3'),\r\n        timeout: parseInt(process.env.OPENAI_TIMEOUT || '60000', 10),\r\n        retries: parseInt(process.env.OPENAI_RETRIES || '3', 10)\r\n      },\r\n      playwright: {\r\n        mcp: {\r\n          enabled: process.env.PLAYWRIGHT_ENABLED === 'true',\r\n          baseUrl: process.env.PLAYWRIGHT_MCP_URL || 'http://localhost:8931',\r\n          timeout: parseInt(process.env.PLAYWRIGHT_TIMEOUT || '30000', 10)\r\n        }\r\n      },\r\n      cache: {\r\n        context7: {\r\n          maxMemoryEntries: parseInt(process.env.CACHE_MAX_MEMORY_ENTRIES || '1000', 10),\r\n          maxMemorySize: parseInt(process.env.CACHE_MAX_MEMORY_SIZE || '52428800', 10), // 50MB\r\n          defaultTtl: parseInt(process.env.CACHE_DEFAULT_TTL || '3600', 10), // 1 hour\r\n          maxTtl: parseInt(process.env.CACHE_MAX_TTL || '86400', 10), // 24 hours\r\n          cleanupInterval: parseInt(process.env.CACHE_CLEANUP_INTERVAL || '300', 10), // 5 minutes\r\n              enablePersistence: process.env.CACHE_ENABLE_PERSISTENCE !== 'false',\r\n              dbPath: process.env.CACHE_DB_PATH || './data/cache/context7.db'\r\n            }\r\n          },\r\n          admin: {\r\n            enabled: process.env.ADMIN_ENABLED === 'true',\r\n            port: parseInt(process.env.ADMIN_PORT || '3001', 10),\r\n            auth: process.env.ADMIN_USERNAME && process.env.ADMIN_PASSWORD ? {\r\n              username: process.env.ADMIN_USERNAME,\r\n              password: process.env.ADMIN_PASSWORD\r\n            } : undefined\r\n          },\r\n          logging: {\r\n            level: (process.env.LOG_LEVEL as 'debug' | 'info' | 'warn' | 'error') || 'info',\r\n            enableConsole: process.env.LOG_CONSOLE !== 'false',\r\n            enableFile: process.env.LOG_FILE === 'true',\r\n            filePath: process.env.LOG_FILE_PATH || './logs/localmcp.log'\r\n          },\r\n      tools: {\r\n        analyze: {\r\n          enabled: process.env.TOOL_ANALYZE_ENABLED !== 'false',\r\n          maxDepth: parseInt(process.env.TOOL_ANALYZE_MAX_DEPTH || '10', 10),\r\n          includeNodeModules: process.env.TOOL_ANALYZE_INCLUDE_NODE_MODULES === 'true'\r\n        },\r\n        create: {\r\n          enabled: process.env.TOOL_CREATE_ENABLED !== 'false',\r\n          defaultFramework: process.env.TOOL_CREATE_DEFAULT_FRAMEWORK || 'react',\r\n          includeTests: process.env.TOOL_CREATE_INCLUDE_TESTS === 'true'\r\n        },\r\n        fix: {\r\n          enabled: process.env.TOOL_FIX_ENABLED !== 'false',\r\n          autoApply: process.env.TOOL_FIX_AUTO_APPLY === 'true',\r\n          backupOriginal: process.env.TOOL_FIX_BACKUP_ORIGINAL !== 'false'\r\n        },\r\n        learn: {\r\n          enabled: process.env.TOOL_LEARN_ENABLED !== 'false',\r\n          storagePath: process.env.TOOL_LEARN_STORAGE_PATH || './data/lessons',\r\n          maxLessons: parseInt(process.env.TOOL_LEARN_MAX_LESSONS || '1000', 10)\r\n        }\r\n      },\r\n      frameworkDetection: {\r\n        enabled: process.env.FRAMEWORK_DETECTION_ENABLED !== 'false',\r\n        confidenceThreshold: parseFloat(process.env.FRAMEWORK_DETECTION_CONFIDENCE_THRESHOLD || '0.3'),\r\n        cacheEnabled: process.env.FRAMEWORK_DETECTION_CACHE_ENABLED !== 'false',\r\n        cacheTTL: parseInt(process.env.FRAMEWORK_DETECTION_CACHE_TTL || '86400', 10), // 24 hours\r\n        aiEnabled: process.env.FRAMEWORK_DETECTION_AI_ENABLED !== 'false',\r\n        patternDetectionEnabled: process.env.FRAMEWORK_DETECTION_PATTERN_ENABLED !== 'false',\r\n        projectContextEnabled: process.env.FRAMEWORK_DETECTION_PROJECT_ENABLED !== 'false',\r\n        maxLibrariesPerDetection: parseInt(process.env.FRAMEWORK_DETECTION_MAX_LIBRARIES || '5', 10),\r\n        aiTimeoutMs: parseInt(process.env.FRAMEWORK_DETECTION_AI_TIMEOUT || '5000', 10)\r\n      },\r\n      promptEnhancement: {\r\n        enabled: process.env.PROMPT_ENHANCEMENT_ENABLED === 'true',\r\n        defaultStrategy: (process.env.PROMPT_ENHANCEMENT_STRATEGY_TYPE as 'general' | 'framework-specific' | 'quality-focused' | 'project-aware') || 'general',\r\n        qualityThreshold: parseFloat(process.env.PROMPT_ENHANCEMENT_QUALITY_THRESHOLD || '0.8'),\r\n        maxTokens: parseInt(process.env.PROMPT_ENHANCEMENT_MAX_TOKENS || '2000', 10),\r\n        temperature: parseFloat(process.env.PROMPT_ENHANCEMENT_TEMPERATURE || '0.3'),\r\n        costLimit: parseFloat(process.env.PROMPT_ENHANCEMENT_COST_LIMIT || '10.0'),\r\n        rateLimit: parseInt(process.env.PROMPT_ENHANCEMENT_RATE_LIMIT || '100', 10),\r\n        fallbackEnabled: process.env.PROMPT_ENHANCEMENT_FALLBACK_ENABLED !== 'false',\r\n        optimization: {\r\n          tokenOptimization: {\r\n            contextTruncation: process.env.PROMPT_ENHANCEMENT_TOKEN_CONTEXT_TRUNCATION !== 'false',\r\n            smartSummarization: process.env.PROMPT_ENHANCEMENT_TOKEN_SMART_SUMMARIZATION !== 'false',\r\n            relevanceFiltering: process.env.PROMPT_ENHANCEMENT_TOKEN_RELEVANCE_FILTERING !== 'false',\r\n            priorityBasedSelection: process.env.PROMPT_ENHANCEMENT_TOKEN_PRIORITY_SELECTION !== 'false'\r\n          },\r\n          qualityOptimization: {\r\n            qualityScoring: process.env.PROMPT_ENHANCEMENT_QUALITY_SCORING !== 'false',\r\n            confidenceThresholds: process.env.PROMPT_ENHANCEMENT_QUALITY_CONFIDENCE_THRESHOLDS !== 'false',\r\n            validationChecks: process.env.PROMPT_ENHANCEMENT_QUALITY_VALIDATION_CHECKS !== 'false',\r\n            feedbackLoop: process.env.PROMPT_ENHANCEMENT_QUALITY_FEEDBACK_LOOP === 'true'\r\n          },\r\n          costOptimization: {\r\n            modelSelection: process.env.PROMPT_ENHANCEMENT_COST_MODEL_SELECTION !== 'false',\r\n            tokenBudgeting: process.env.PROMPT_ENHANCEMENT_COST_TOKEN_BUDGETING !== 'false',\r\n            cacheUtilization: process.env.PROMPT_ENHANCEMENT_COST_CACHE_UTILIZATION !== 'false',\r\n            batchProcessing: process.env.PROMPT_ENHANCEMENT_COST_BATCH_PROCESSING === 'true'\r\n          },\r\n          performanceOptimization: {\r\n            parallelProcessing: process.env.PROMPT_ENHANCEMENT_PERF_PARALLEL_PROCESSING !== 'false',\r\n            caching: process.env.PROMPT_ENHANCEMENT_PERF_CACHING !== 'false',\r\n            responseStreaming: process.env.PROMPT_ENHANCEMENT_PERF_RESPONSE_STREAMING === 'true',\r\n            loadBalancing: process.env.PROMPT_ENHANCEMENT_PERF_LOAD_BALANCING === 'true'\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.logger.info('Configuration loaded', {\r\n      server: config.server.name,\r\n      context7Enabled: config.context7.enabled,\r\n      databaseType: config.database.type,\r\n      logLevel: config.logging.level\r\n    });\r\n\r\n    return config;\r\n  }\r\n\r\n  private validateConfig(): void {\r\n    const errors: string[] = [];\r\n\r\n    // Validate server config\r\n    if (!this.config.server.name) {\r\n      errors.push('Server name is required');\r\n    }\r\n    if (this.config.server.port < 1 || this.config.server.port > 65535) {\r\n      errors.push('Server port must be between 1 and 65535');\r\n    }\r\n\r\n    // Validate Context7 config\r\n    if (this.config.context7.enabled && !this.config.context7.apiKey) {\r\n      errors.push('Context7 API key is required when Context7 is enabled');\r\n    }\r\n\r\n    // Validate database config\r\n    if (this.config.database.type === 'qdrant') {\r\n      if (!this.config.database.url) {\r\n        errors.push('Qdrant URL is required when using Qdrant database');\r\n      }\r\n    }\r\n\r\n    // Validate logging config\r\n    const validLogLevels = ['debug', 'info', 'warn', 'error'];\r\n    if (!validLogLevels.includes(this.config.logging.level)) {\r\n      errors.push(`Log level must be one of: ${validLogLevels.join(', ')}`);\r\n    }\r\n\r\n    // Validate tools config\r\n    if (this.config.tools.analyze.maxDepth < 1) {\r\n      errors.push('Analyze max depth must be at least 1');\r\n    }\r\n    if (this.config.tools.learn.maxLessons < 1) {\r\n      errors.push('Learn max lessons must be at least 1');\r\n    }\r\n\r\n    // Validate framework detection config\r\n    if (this.config.frameworkDetection.confidenceThreshold < 0 || this.config.frameworkDetection.confidenceThreshold > 1) {\r\n      errors.push('Framework detection confidence threshold must be between 0 and 1');\r\n    }\r\n    if (this.config.frameworkDetection.cacheTTL < 1) {\r\n      errors.push('Framework detection cache TTL must be at least 1 second');\r\n    }\r\n    if (this.config.frameworkDetection.maxLibrariesPerDetection < 1) {\r\n      errors.push('Framework detection max libraries must be at least 1');\r\n    }\r\n    if (this.config.frameworkDetection.aiTimeoutMs < 1000) {\r\n      errors.push('Framework detection AI timeout must be at least 1000ms');\r\n    }\r\n\r\n    // Validate prompt enhancement config\r\n    if (this.config.promptEnhancement.enabled) {\r\n      const validStrategies = ['general', 'framework-specific', 'quality-focused', 'project-aware'];\r\n      if (!validStrategies.includes(this.config.promptEnhancement.defaultStrategy)) {\r\n        errors.push(`Prompt enhancement default strategy must be one of: ${validStrategies.join(', ')}`);\r\n      }\r\n      if (this.config.promptEnhancement.qualityThreshold < 0 || this.config.promptEnhancement.qualityThreshold > 1) {\r\n        errors.push('Prompt enhancement quality threshold must be between 0 and 1');\r\n      }\r\n      if (this.config.promptEnhancement.maxTokens < 100 || this.config.promptEnhancement.maxTokens > 8000) {\r\n        errors.push('Prompt enhancement max tokens must be between 100 and 8000');\r\n      }\r\n      if (this.config.promptEnhancement.temperature < 0 || this.config.promptEnhancement.temperature > 2) {\r\n        errors.push('Prompt enhancement temperature must be between 0 and 2');\r\n      }\r\n      if (this.config.promptEnhancement.costLimit < 0) {\r\n        errors.push('Prompt enhancement cost limit must be non-negative');\r\n      }\r\n      if (this.config.promptEnhancement.rateLimit < 0) {\r\n        errors.push('Prompt enhancement rate limit must be non-negative');\r\n      }\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n      this.logger.error('Configuration validation failed', { errors });\r\n      throw new Error(`Configuration validation failed: ${errors.join(', ')}`);\r\n    }\r\n\r\n    this.logger.info('Configuration validation passed');\r\n  }\r\n\r\n  // Helper methods for common config access patterns\r\n  isContext7Enabled(): boolean {\r\n    return this.config.context7.enabled;\r\n  }\r\n\r\n  isToolEnabled(tool: keyof PromptMCPConfig['tools']): boolean {\r\n    return this.config.tools[tool].enabled;\r\n  }\r\n\r\n  getLogLevel(): 'debug' | 'info' | 'warn' | 'error' {\r\n    return this.config.logging.level;\r\n  }\r\n\r\n  getDatabaseConfig() {\r\n    return this.config.database;\r\n  }\r\n\r\n  getContext7Config() {\r\n    return this.config.context7;\r\n  }\r\n\r\n  getFrameworkDetectionConfig() {\r\n    return this.config.frameworkDetection;\r\n  }\r\n\r\n  getPromptEnhancementConfig() {\r\n    return this.config.promptEnhancement;\r\n  }\r\n\r\n  isPromptEnhancementEnabled(): boolean {\r\n    return this.config.promptEnhancement.enabled;\r\n  }\r\n}"
      ],
      "context7_docs": [
        "## /websites/react_dev Documentation:\n================\nCODE SNIPPETS\n================\nTITLE: Document 'use no memo' Directive Usage for React Best Practices\nDESCRIPTION: Emphasizes the importance of documenting the reason for using `\"use no memo\"` to ensure maintainability and understanding. It contrasts a well-documented example with one lacking explanation, promoting clear communication in code.\n\nSOURCE: https://react.dev/reference/react-compiler/directives/use-no-memo\n\nLANGUAGE: javascript\nCODE:\n```\n//  Good - clear explanation and tracking  \nfunction DataProcessor() {  \n  \"use no memo\"; // TODO: Remove after fixing rule of react violation  \n  // ...  \n}  \n  \n//  Bad - no explanation  \nfunction Mystery() {  \n  \"use no memo\";  \n  // ...  \n}\n```\n\n--------------------------------\n\nTITLE: Optimize custom React Hooks by memoizing returned functions with useCallback\nDESCRIPTION: When developing custom React Hooks, it's a best practice to wrap any functions that the hook returns with `useCallback`. This ensures that the functions maintain a stable reference across re-renders (provided their internal dependencies are stable), allowing consumers of your custom hook to optimize their own components more effectively.\n\nSOURCE: https://react.dev/reference/react/useCallback\n\nLANGUAGE: javascript\nCODE:\n```\nfunction useRouter() {  \n  const { dispatch } = useContext(RouterStateContext);  \n\n  const navigate = useCallback((url) => {  \n    dispatch({ type: 'navigate', url });  \n  }, [dispatch]);  \n\n  const goBack = useCallback(() => {  \n    dispatch({ type: 'back' });  \n  }, [dispatch]);  \n\n  return {  \n    navigate,  \n    goBack,  \n  };\n}\n\n```\n\n--------------------------------\n\nTITLE: Calculating Derived React State During Render (Best Practice)\nDESCRIPTION: This React component demonstrates the best practice for managing state derived from props. Instead of storing and resetting `selection`, it stores `selectedId` and calculates the `selection` object directly during rendering based on the `items` prop and `selectedId`. This approach simplifies the data flow, eliminates the need for state adjustments, and makes the component more robust and easier to debug, as state is always consistent with props.\n\nSOURCE: https://react.dev/learn/you-might-not-need-an-effect\n\nLANGUAGE: javascript\nCODE:\n```\nfunction List({ items }) {  \n  const [isReverse, setIsReverse] = useState(false);  \n  const [selectedId, setSelectedId] = useState(null);  \n  //  Best: Calculate everything during rendering  \n  const selection = items.find(item => item.id === selectedId) ?? null;  \n  // ...  \n}\n```\n\n--------------------------------\n\nTITLE: Documenting React Compiler Directive Usage\nDESCRIPTION: These JavaScript examples highlight the importance of documenting why a 'use no memo' directive is used. Good practice involves adding clear comments explaining the reason for the directive, aiding future maintenance and understanding, as opposed to leaving it unexplained.\n\nSOURCE: https://react.dev/reference/react-compiler/directives\n\nLANGUAGE: javascript\nCODE:\n```\n//  Good - clear explanation  \nfunction DataGrid() {  \n  \"use no memo\"; // TODO: Remove after fixing issue with dynamic row heights (JIRA-123)  \n  // Complex grid implementation  \n}  \n  \n//  Bad - no explanation  \nfunction Mystery() {  \n  \"use no memo\";  \n  // ...  \n}\n```\n\n--------------------------------\n\nTITLE: Correct React `useMemo` dependency arrays and compiler-optimized component\nDESCRIPTION: This snippet provides examples of proper dependency management for React `useMemo`, ensuring all necessary values are included for accurate memoization. It also shows an alternative approach where manual `useMemo` is removed entirely, allowing the React Compiler to automatically optimize the component's performance.\n\nSOURCE: https://react.dev/reference/eslint-plugin-react-hooks/lints/preserve-manual-memoization\n\nLANGUAGE: javascript\nCODE:\n```\n//  Complete dependencies  \nfunction Component({ data, filter }) {  \n  const filtered = useMemo(  \n    () => data.filter(filter),  \n    [data, filter] // All dependencies included  \n  );  \n  \n  return <List items={filtered} />;\n}  \n\n//  Or let the compiler handle it  \nfunction Component({ data, filter }) {  \n  // No manual memoization needed  \n  const filtered = data.filter(filter);\n  return <List items={filtered} />;\n}\n```\n\n--------------------------------\n\nTITLE: Enable React Compiler Rule in ESLint Configuration\nDESCRIPTION: Add this specific rule to your ESLint configuration to activate the `react-hooks/react-compiler` rule. This rule enforces best practices and flags issues related to the React Compiler's usage.\n\nSOURCE: https://react.dev/blog/2025/04/21/react-compiler-rc\n\nLANGUAGE: JavaScript\nCODE:\n```\n'react-hooks/react-compiler': 'error'\n```\n\n--------------------------------\n\nTITLE: Planning for Removal of Temporary React Compiler Opt-Out Directives\nDESCRIPTION: This JavaScript code demonstrates the best practice of treating 'use no memo' as a temporary workaround. It includes a TODO comment to track the removal of the directive once the underlying issue, such as an incompatible third-party library version, is resolved.\n\nSOURCE: https://react.dev/reference/react-compiler/directives\n\nLANGUAGE: javascript\nCODE:\n```\nfunction TemporaryWorkaround() {  \n  \"use no memo\"; // TODO: Remove after upgrading ThirdPartyLib to v2.0  \n  return <ThirdPartyComponent />;  \n}\n```"
      ]
    },
    "success": true,
    "todos": [],
    "frameworks_detected": [],
    "ai_enhancement": {
      "enabled": false,
      "strategy": "none",
      "quality_score": 0,
      "confidence_score": 0,
      "improvements": [],
      "recommendations": [],
      "processing_time": 0,
      "cost": 0
    }
  },
  "performance": {
    "originalTokens": 7,
    "enhancedTokens": 7,
    "tokenRatio": 1,
    "responseTime": 1919,
    "context7Used": false,
    "context7LibrariesResolved": 0
  },
  "quality": {
    "overall": 5,
    "details": {
      "frameworkAccuracy": "0%",
      "context7Accuracy": "0%",
      "htmlDocumentation": "Present",
      "contentQuality": "5/25"
    },
    "breakdown": {
      "performance": 2,
      "accuracy": 2,
      "content": 1
    }
  },
  "context": {
    "repoFacts": 16,
    "codeSnippets": 10,
    "frameworkDocs": 0,
    "projectDocs": 0,
    "context7Docs": 1
  },
  "libraries": [],
  "timestamp": "2025-09-25T23:13:29.834Z"
}