{
  "testCase": {
    "id": "typescript-debug",
    "name": "TypeScript Debug Task",
    "prompt": "Fix this TypeScript error: Property \"data\" does not exist on type \"unknown\" in my API response handler",
    "expectedFrameworks": [
      "typescript"
    ],
    "expectedContext7Libraries": [
      "/microsoft/typescript"
    ],
    "qualityCriteria": {
      "shouldExplainTheError": true,
      "shouldProvideSolution": true,
      "shouldIncludeTypeGuards": true,
      "shouldIncludeBestPractices": true,
      "shouldBeEducational": true,
      "maxTokens": 800,
      "maxResponseTime": 300
    }
  },
  "completeResponse": {
    "enhanced_prompt": "Fix this TypeScript error: Property \"data\" does not exist on type \"unknown\" in my API response handler\n\n## Quality Requirements\n\n1. **type-safety** ðŸŸ  (high priority)\n   - TypeScript type safety and strict typing\n2. **testing** ðŸŸ¡ (medium priority)\n   - Comprehensive test coverage and quality\n3. **performance** ðŸŸ¡ (medium priority)\n   - Build optimization and performance\n4. **responsive** ðŸŸ¡ (medium priority)\n   - Mobile-first responsive design\n5. **security** ðŸŸ  (high priority)\n   - Security best practices and input validation\n\n\n## Framework Best Practices:\n/websites/react_dev Documentation:\n================\nCODE SNIPPETS\n================\nTITLE: Secure API calls with `server-only` to prevent client exposure (React)\nDESCRIPTION: This example demonstrates a secure pattern for handling sensitive API credentials using the `server-only` package. It ensures that the `fetchAPI` helper, which accesses `process.env.API_PASSWORD`, can only be imported and executed on the server, preventing accidental exposure to client components.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nimport \"server-only\";\n\nexport function fetchAPI(url) {\n  const headers = { Authorization: process.env.API_PASSWORD };\n  return fetch(url, { headers });\n}\n```\n\n--------------------------------\n\nTITLE: Basic React `use` API Call\nDESCRIPTION: This snippet demonstrates the fundamental syntax for using the React `use` API to read a resource's value. It shows a simple assignment of the resource's value to a variable, highlighting the core interaction with the API.\n\nSOURCE: https://react.dev/reference/react/use\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst value = use(resource);\n```\n\n--------------------------------\n\nTITLE: Read Resource Values with React's `use` API\nDESCRIPTION: This code snippet demonstrates how to use the `use` API in React to read values from resources such as Promises or Context. The `use` Hook allows a component to access data without making it part of its state, simplifying data consumption from various sources.\n\nSOURCE: https://react.dev/reference/react/apis\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MessageComponent({ messagePromise }) {\n  const message = use(messagePromise);\n  const theme = use(ThemeContext);\n  // ...\n}\n```\n\n--------------------------------\n\nTITLE: Importing React Children API\nDESCRIPTION: This code snippet demonstrates the correct way to import the `Children` API (with a capital 'C') from the 'react' library. This API provides utility functions for working with the `children` prop in React components, distinguishing it from the `children` prop itself (lowercase 'c').\n\nSOURCE: https://react.dev/reference/react/Children\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Children } from 'react';\n```\n\n--------------------------------\n\nTITLE: Anti-pattern: Leaking API password to Client Component (React)\nDESCRIPTION: This code demonstrates an anti-pattern where a server-side `API_PASSWORD` is directly passed as a prop to a Client Component, `Overview`. This method exposes sensitive information to the client, leading to potential security vulnerabilities and data breaches. This should be avoided.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nexport async function Dashboard(props) {\n  // DO NOT DO THIS\n  return <Overview password={process.env.API_PASSWORD} />;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\n\"use client\";\n\nimport {useEffect} from '...'\n\nexport async function Overview({ password }) {\n  useEffect(() => {\n    const headers = { Authorization: password };\n    fetch(url, { headers }).then(...);\n  }, [password]);\n  ...\n\n## Repository Context:\nProject name: promptmcp\nProject description: A focused MCP server for intelligent prompt enhancement with dynamic framework detection, Context7 integration, comprehensive testing suite, and organized test artifacts management\nUses Playwright framework (^1.55.0)\nUses TypeScript framework (^5.0.0)\nUses Vitest framework (^1.0.0)\nProject type: Frontend application\nHas testing setup\nHas build process\nSource directories: src\nConfiguration files: tsconfig.json\nUses TypeScript for type safety\nUses Node.js/Express for backend\nUses testing with 297 test files\nUses Model Context Protocol (MCP) for AI integration\nUses service-oriented architecture with 153 service files\nUses tool-based architecture with 39 tool files\n\n## Existing Code Patterns:\n```typescript\nFocus on actionable, specific tasks`\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `User Request: ${prompt}\r\n\r\nRelevant Documentation:\r\n${context}\r\n\r\nPlease break this down into structured tasks.`\r\n          }\r\n        ],\r\n        temperature: this.config.temperature || 0.3,\r\n        max_tokens: this.config.maxTokens || 2000\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) {\r\n        throw new Error('No response content from OpenAI');\r\n      }\r\n\r\n      this.logger.debug('OpenAI response received', { \r\n        responseLength: content.length,\r\n        usage: response.usage \r\n      });\r\n\r\n      // Track cost and usage\r\n      if (response.usage) {\r\n        this.trackUsage(response.usage, this.config.model || 'gpt-4');\r\n      }\r\n\r\n      // Parse and validate the JSON response\r\n      const breakdown = this.parseAndValidateBreakdown(content);\r\n      \r\n      this.logger.info('Task breakdown completed successfully', {\r\n        mainTasks: breakdown.mainTasks.length,\r\n        subtasks: breakdown.subtasks.length,\r\n        dependencies: breakdown.dependencies.length\r\n      });\r\n\r\n      return breakdown;\r\n\r\n    } catch (error) {\r\n      // Enhanced error handling with specific API key error detection\r\n      if (error instanceof Error && error.message.includes('401')) {\r\n        this.logger.error('OpenAI API key invalid or expired', {\r\n          error: 'API key authentication failed',\r\n          suggestion: 'Please update OPENAI_API_KEY environment variable',\r\n          prompt: prompt.substring(0, 100) + '...'\r\n        });\r\n        throw new Error('OpenAI API key is invalid or expired. Please check your OPENAI_API_KEY environment variable.');\r\n      } else if (error instanceof Error && error.message.includes('429')) {\r\n        this.logger.error('OpenAI API rate limit exceeded', {\r\n          error: 'Rate limit exceeded',\r\n          suggestion: 'Please wait before retrying or upgrade your OpenAI plan',\r\n          prompt: prompt.substring(0, 100) + '...'\r\n        });\r\n        throw new Error('OpenAI API rate limit exceeded. Please wait before retrying.');\r\n      } else if (error instanceof Error && error.message.includes('403')) {\r\n        this.logger.\n```\n\n## Instructions:\nMake your response consistent with the project's existing patterns, best practices, and coding standards. Use the provided context to ensure your solution fits well with the existing codebase.",
    "context_used": {
      "repo_facts": [
        "Project name: promptmcp",
        "Project description: A focused MCP server for intelligent prompt enhancement with dynamic framework detection, Context7 integration, comprehensive testing suite, and organized test artifacts management",
        "Uses Playwright framework (^1.55.0)",
        "Uses TypeScript framework (^5.0.0)",
        "Uses Vitest framework (^1.0.0)",
        "Project type: Frontend application",
        "Has testing setup",
        "Has build process",
        "Source directories: src",
        "Configuration files: tsconfig.json",
        "Uses TypeScript for type safety",
        "Uses Node.js/Express for backend",
        "Uses testing with 297 test files",
        "Uses Model Context Protocol (MCP) for AI integration",
        "Uses service-oriented architecture with 153 service files",
        "Uses tool-based architecture with 39 tool files"
      ],
      "code_snippets": [
        "File: src/tools/enhance/response-builder.service.ts\nDescription: Class definition: ResponseBuilderService\nCode:\nexport class ResponseBuilderService {\r\n  private logger: Logger;\r\n  private openAIService?: OpenAIService;\r\n\r\n  constructor(logger: Logger, openAIService?: OpenAIService) {\r\n    this.logger = logger;\r\n    this.openAIService = openAIService;\r\n  }\r\n\r\n  /**\r\n   * Build enhanced prompt with all context\r\n   * Implements comprehensive prompt enhancement with complexity awareness\r\n   */\r\n  async buildEnhancedPrompt(\r\n    originalPrompt: string,\r\n    context: PromptContext,\r\n    complexity?: PromptComplexity,\r\n    useAIEnhancement: boolean = false\r\n  ): Promise<string> {\r\n    let enhanced = originalPrompt;\r\n    \r\n    // For simple prompts, provide minimal context\r\n    if (complexity?.level === 'simple') {\r\n      enhanced = this.buildSimplePrompt(enhanced, context);\r\n    } else {\r\n      // For medium/complex prompts, add comprehensive context\r\n      enhanced = this.buildComplexPrompt(enhanced, context, complexity);\r\n    }\r\n\r\n    // Apply AI enhancement if requested and available\r\n    if (useAIEnhancement && this.openAIService) {\r\n      try {\r\n        const aiEnhanced = this.buildEnhancedPromptWithAI(originalPrompt, context, complexity);\r\n        return await aiEnhanced;\r\n      } catch (error) {\r\n        this.logger.warn('AI enhancement failed, falling back to standard enhancement', {\r\n          error: error instanceof Error ? error.message : 'Unknown error'\r\n        });\r\n        return enhanced;\r\n      }\r\n    }\r\n\r\n    return enhanced;\r\n  }\r\n\r\n  /**\r\n   * Build AI-enhanced prompt with OpenAI integration\r\n   * Implements intelligent prompt enhancement using AI\r\n   */\r\n  async buildEnhancedPromptWithAI(\r\n    originalPrompt: string,\r\n    context: PromptContext,\r\n    complexity?: PromptComplexity\r\n  ): Promise<string> {\r\n    if (!this.openAIService) {\r\n      throw new Error('OpenAI service not available for AI enhancement');\r\n    }\r\n\r\n    this.logger.debug('Starting AI-enhanced prompt building', {\r\n      originalPrompt: originalPrompt.substring(0, 100) + '...',\r\n      complexity: complexity?.level || 'unknown'\r\n    });\r\n\r\n    // Prepare enhancement context\r\n    const enhancementContext = this.prepareEnhancementContext(context, complexity);\r\n    \r\n    // Create enhancement request\r\n    const request: PromptEnhancementRequest = {\r\n      originalPrompt,\r\n      context: enhancementContext,\r\n      options: this.createEnhancementOptions(complexity),\r\n      goals: this.createEnhancementGoals(originalPrompt, context)\r\n    };\r\n\r\n    // Call OpenAI for enhancement\r\n    const startTime = Date.now();\r\n    const enhancement = await this.openAIService.enhancePromptWithContext(request);\r\n    const processingTime = Date.now() - startTime;\r\n\r\n    // Update metadata with processing time\r\n    enhancement.metadata.processingTime = processingTime;\r\n\r\n    this.logger.info('AI-enhanced prompt building completed', {\r\n      originalLength: originalPrompt.length,\r\n      enhancedLength: enhancement.enhancedPrompt.length,\r\n      qualityScore: enhancement.quality.overall,\r\n      confidenceScore: enhancement.confidence.overall,\r\n      processingTime\r\n    });\r\n\r\n    return enhancement.enhancedPrompt;\r\n  }\r\n\r\n  /**\r\n   * Build simple prompt with minimal context\r\n   * Optimized for simple questions and quick responses\r\n   */\r\n  private buildSimplePrompt(enhanced: string, context: PromptContext): string {\r\n    // For very simple prompts, keep it minimal - skip repository context entirely\r\n    \r\n    // Only add essential framework detection if relevant and not already mentioned\r\n    if (context.frameworkDetection && \r\n        context.frameworkDetection.detectedFrameworks.length > 0 &&\r\n        !enhanced.toLowerCase().includes(context.frameworkDetection.detectedFrameworks[0].toLowerCase())) {\r\n      enhanced += `\\n\\nFramework: ${context.frameworkDetection.detectedFrameworks[0]}`;\r\n    }\r\n    \r\n    // Add minimal Context7 docs for simple HTML/CSS questions (heavily truncated)\r\n    if (context.context7Docs && context.frameworkDetection?.detectedFrameworks.includes('html')) {\r\n      const truncatedDocs = this.smartTruncateContent(context.context7Docs, 100, enhanced);\r\n      enhanced += `\\n\\n${truncatedDocs}`;\r\n    }\r\n    \r\n    // Log token usage for monitoring\r\n    this.logTokenUsage('simple_prompt', enhanced, 200, enhanced);\r\n    \r\n    return enhanced;\r\n  }\r\n\r\n  /**\r\n   * Build complex prompt with comprehensive context\r\n   * Optimized for development tasks and complex requests\r\n   */\r\n  private buildComplexPrompt(\r\n    enhanced: string, \r\n    context: PromptContext, \r\n    complexity?: PromptComplexity\r\n  ): string {\r\n    // Add framework detection information\r\n    if (context.frameworkDetection && context.frameworkDetection.detectedFrameworks.length > 0) {\r\n      enhanced += `\\n\\n## Detected Frameworks/Libraries:\\n`;\r\n      enhanced += `- **Frameworks**: ${context.frameworkDetection.detectedFrameworks.join(', ')}\\n`;\r\n      enhanced += `- **Detection Method**: ${context.frameworkDetection.detectionMethod}\\n`;\r\n      enhanced += `- **Confidence**: ${(context.frameworkDetection.confidence * 100).toFixed(1)}%\\n`;\r\n      if (context.frameworkDetection.suggestions.length > 0) {\r\n        enhanced += `- **Suggestions**: ${context.frameworkDetection.suggestions.join(', ')}\\n`;\r\n      }\r\n    }\r\n    \r\n    // Add quality requirements if detected (skip for simple prompts)\r\n    if (complexity?.level !== 'simple' && context.qualityRequirements && context.qualityRequirements.length > 0) {\r\n      const qualityFormatted = this.formatQualityRequirements(context.qualityRequirements);\r\n      if (qualityFormatted) {\r\n        enhanced += `\\n\\n${qualityFormatted}`;\r\n      }\r\n    }\r\n    \r\n    // Add Context7 documentation if available (with smart truncation)\r\n    if (context.context7Docs) {\r\n      const maxTokens = complexity?.level === 'simple' ? 200 : \r\n                       complexity?.level === 'medium' ? 500 : 800;\r\n      const smartTruncatedDocs = this.smartTruncateContent(\r\n        context.context7Docs, \r\n        maxTokens, \r\n        enhanced\r\n      );\r\n      enhanced += `\\n\\n## Framework Best Practices:\\n${smartTruncatedDocs}`;\r\n    }\r\n    \r\n    // Add framework-specific documentation if available\r\n    if (context.frameworkDocs && context.frameworkDocs.length > 0) {\r\n      enhanced += `\\n\\n## Framework-Specific Best Practices:\\n${context.frameworkDocs.join('\\n')}`;\r\n    }\r\n    \r\n    // Add project documentation if available\r\n    if (context.projectDocs && context.projectDocs.length > 0) {\r\n      enhanced += `\\n\\n## Project Documentation:\\n${context.projectDocs.join('\\n')}`;\r\n    }\r\n    \r\n    // Add repository context\r\n    if (context.repoFacts.length > 0) {\r\n      enhanced += `\\n\\n## Repository Context:\\n${context.repoFacts.join('\\n')}`;\r\n    }\r\n    \r\n    // Add existing code patterns if available (with smart truncation)\r\n    if (context.codeSnippets.length > 0) {\r\n      const codeContent = context.codeSnippets.join('\\n\\n');\r\n      const maxTokens = complexity?.level === 'simple' ? 200 : \r\n                       complexity?.level === 'medium' ? 400 : 600;\r\n      const smartTruncatedCode = this.smartTruncateContent(\r\n        codeContent, \r\n        maxTokens, \r\n        enhanced\r\n      );\r\n      enhanced += `\\n\\n## Existing Code Patterns:\\n\\`\\`\\`typescript\\n${smartTruncatedCode}\\n\\`\\`\\``;\r\n    }\r\n    \r\n    // Add final instructions\r\n    enhanced += `\\n\\n## Instructions:\\nMake your response consistent with the project's existing patterns, best practices, and coding standards. Use the provided context to ensure your solution fits well with the existing codebase.`;\r\n    \r\n    return enhanced;\r\n  }\r\n\r\n  /**\r\n   * Smart content truncation with relevance scoring\r\n   * Implements intelligent content filtering and prioritization\r\n   */\r\n  smartTruncateContent(content: string, maxTokens: number, prompt: string): string {\r\n    if (!content || content.length === 0) return content;\r\n    \r\n    // Estimate tokens (rough approximation: 1 token â‰ˆ 4 characters)\r\n    const estimatedTokens = this.countTokens(content);\r\n    \r\n    if (estimatedTokens <= maxTokens) {\r\n      this.logTokenUsage('smart_truncate', content, maxTokens, prompt);\r\n      return content;\r\n    }\r\n    \r\n    // Extract key sections based on prompt relevance\r\n    const promptKeywords = this.extractKeywords(prompt);\r\n    const sections = this.splitIntoSections(content);\r\n    const scoredSections = this.scoreSections(sections, promptKeywords);\r\n    \r\n    // Select highest scoring sections within token limit\r\n    const selectedSections = this.selectSectionsWithinLimit(scoredSections, maxTokens);\r\n    const result = selectedSections.join('\\n\\n');\r\n    \r\n    // Log token usage for monitoring\r\n    this.logTokenUsage('smart_truncate', result, maxTokens, prompt);\r\n    \r\n    return result;\r\n  }\r\n\r\n  /**\r\n   * Format quality requirements for display\r\n   * Implements user-friendly formatting with priority indicators\r\n   */\r\n  formatQualityRequirements(requirements: any[]): string {\r\n    try {\r\n      if (!requirements || requirements.length === 0) {\r\n        return '';\r\n      }\r\n      \r\n      let formatted = '## Quality Requirements\\n\\n';\r\n      \r\n      requirements.forEach((req, index) => {\r\n        const priority = req.priority || 'medium';\r\n        const type = req.type || 'general';\r\n        const description = req.description || '';\r\n        const priorityEmoji = this.getPriorityEmoji(priority);\r\n        \r\n        formatted += `${index + 1}. **${type}** ${priorityEmoji} (${priority} priority)\\n`;\r\n        if (description) {\r\n          formatted += `   - ${description}\\n`;\r\n        }\r\n      });\r\n      \r\n      return formatted;\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Quality requirements formatting failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        requirementsCount: requirements?.length || 0\r\n      });\r\n      \r\n      // Return fallback formatting\r\n      return '';\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract keywords from prompt for relevance scoring\r\n   * Used for content prioritization and smart truncation\r\n   */\r\n  private extractKeywords(prompt: string): string[] {\r\n    const words = prompt.toLowerCase()\r\n      .replace(/[^\\w\\s]/g, ' ')\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 2)\r\n      .filter(word => !this.isStopWord(word));\r\n    \r\n    // Remove duplicates and return\r\n    return [...new Set(words)];\r\n  }\r\n\r\n  /**\r\n   * Check if a word is a stop word (common words that don't add meaning)\r\n   */\r\n  private isStopWord(word: string): boolean {\r\n    const stopWords = new Set([\r\n      'the', 'and', 'or', 'but', 'for', 'with', 'from', 'this', 'that', 'these', 'those',\r\n      'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have', 'has', 'had', 'do', 'does',\r\n      'did', 'will', 'would', 'could', 'should', 'may', 'might', 'must', 'can', 'i', 'you',\r\n      'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them'\r\n    ]);\r\n    \r\n    return stopWords.has(word);\r\n  }\r\n\r\n  /**\r\n   * Split content into logical sections for processing\r\n   * Implements intelligent content segmentation\r\n   */\r\n  private splitIntoSections(content: string): string[] {\r\n    // Split by common section markers\r\n    const sectionMarkers = [\r\n      /\\n## /g,\r\n      /\\n### /g,\r\n      /\\n#### /g,\r\n      /\\n- /g,\r\n      /\\n\\* /g,\r\n      /\\n\\d+\\. /g\r\n    ];\r\n    \r\n    let sections = [content];\r\n    \r\n    for (const marker of sectionMarkers) {\r\n      const newSections: string[] = [];\r\n      for (const section of sections) {\r\n        const parts = section.split(marker);\r\n        if (parts.length > 1) {\r\n          newSections.push(...parts.filter(part => part.trim().length > 0));\r\n        } else {\r\n          newSections.push(section);\r\n        }\r\n      }\r\n      sections = newSections;\r\n    }\r\n    \r\n    return sections.filter(section => section.trim().length > 0);\r\n  }\r\n\r\n  /**\r\n   * Score sections based on keyword relevance\r\n   * Implements intelligent content scoring for prioritization\r\n   */\r\n  private scoreSections(sections: string[], keywords: string[]): Array<{ content: string; score: number; tokens: number }> {\r\n    return sections.map(section => {\r\n      const sectionLower = section.toLowerCase();\r\n      let score = 0;\r\n      \r\n      // Score based on keyword matches\r\n      for (const keyword of keywords) {\r\n        const matches = (sectionLower.match(new RegExp(keyword, 'g')) || []).length;\r\n        score += matches * 2; // Weight keyword matches\r\n      }\r\n      \r\n      // Boost score for code examples and practical content\r\n      if (section.includes('```') || section.includes('example') || section.includes('usage')) {\r\n        score += 5;\r\n      }\r\n      \r\n      // Boost score for API references and methods\r\n      if (section.includes('function') || section.includes('method') || section.includes('API')) {\r\n        score += 3;\r\n      }\r\n      \r\n      // Boost score for configuration and setup\r\n      if (section.includes('config') || section.includes('setup') || section.includes('install')) {\r\n        score += 2;\r\n      }\r\n      \r\n      // Boost score for troubleshooting and common issues\r\n      if (section.includes('error') || section.includes('issue') || section.includes('problem')) {\r\n        score += 2;\r\n      }\r\n      \r\n      // Calculate token count for this section\r\n      const tokens = this.countTokens(section);\r\n      \r\n      return { content: section, score, tokens };\r\n    });\r\n  }\r",
        "File: src/tools/enhance/prompt-analyzer.service.ts\nDescription: Class definition: PromptAnalyzerService\nCode:\nexport class PromptAnalyzerService {\r\n  private logger: Logger;\r\n  private openaiService?: OpenAIService | undefined;\r\n\r\n  constructor(logger: Logger, openaiService?: OpenAIService | undefined) {\r\n    this.logger = logger;\r\n    this.openaiService = openaiService;\r\n  }\r\n\r\n  /**\r\n   * Analyze prompt complexity to determine appropriate response strategy\r\n   * Implements intelligent complexity detection with multiple indicators\r\n   */\r\n  analyzePromptComplexity(prompt: string): PromptComplexity {\r\n    const indicators: string[] = [];\r\n    let score = 0;\r\n    \r\n    // Length-based scoring\r\n    if (prompt.length < 20) {\r\n      score += 3;\r\n      indicators.push('very-short');\r\n    } else if (prompt.length < 50) {\r\n      score += 2;\r\n      indicators.push('short');\r\n    } else if (prompt.length > 200) {\r\n      score += 1;\r\n      indicators.push('long');\r\n    }\r\n    \r\n    // Simple question patterns\r\n    const simplePatterns = [\r\n      /^(yes|no|ok|sure|maybe)\\s*$/i,\r\n      /^(yes|no)\\s+or\\s+(yes|no)/i,\r\n      /^(what|how|when|where|why)\\s+\\w+\\?$/i,\r\n      /^(is|are|was|were|do|does|did|can|could|will|would)\\s+\\w+/i,\r\n      /^what\\s+is\\s+\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\??$/i,  // Math questions like \"What is 2+2?\"\r\n      /^\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\??$/i,  // Direct math like \"2+2?\"\r\n      /^what\\s+is\\s+\\d+\\s*[\\+\\-\\*\\/]\\s*\\d+\\s*\\??$/i,  // \"What is 2+2\" without question mark\r\n      /^how\\s+do\\s+i\\s+create\\s+a\\s+(\\w+)\\??$/i,  // Simple element creation questions\r\n      /^how\\s+to\\s+create\\s+a\\s+(\\w+)\\??$/i,  // Simple element creation questions\r\n      /^how\\s+do\\s+i\\s+make\\s+a\\s+(\\w+)\\??$/i  // Simple element creation questions\r\n    ];\r\n    \r\n    if (simplePatterns.some(pattern => pattern.test(prompt.trim()))) {\r\n      score += 2;\r\n      indicators.push('simple-question');\r\n    }\r\n    \r\n    // Complex development patterns\r\n    const complexPatterns = [\r\n      /create|build|implement|develop/i,\r\n      /component|function|class|service/i,\r\n      /api|endpoint|database|schema/i,\r\n      /test|testing|debug|fix/i,\r\n      /deploy|production|staging/i\r\n    ];\r\n    \r\n    const complexMatches = complexPatterns.filter(pattern => pattern.test(prompt));\r\n    if (complexMatches.length > 0) {\r\n      score -= complexMatches.length;\r\n      indicators.push(...complexMatches.map(() => 'development-task'));\r\n    }\r\n    \r\n    // Framework-specific complexity\r\n    const frameworkKeywords = [\r\n      'react', 'vue', 'angular', 'typescript', 'javascript',\r\n      'node', 'express', 'next', 'nuxt', 'svelte'\r\n    ];\r\n    \r\n    const frameworkMatches = frameworkKeywords.filter(keyword => \r\n      prompt.toLowerCase().includes(keyword)\r\n    );\r\n    if (frameworkMatches.length > 0) {\r\n      score -= frameworkMatches.length * 0.5;\r\n      indicators.push(...frameworkMatches.map(() => 'framework-specific'));\r\n    }\r\n    \r\n    // Determine complexity level\r\n    let level: 'simple' | 'medium' | 'complex';\r\n    if (score >= 2) {\r\n      level = 'simple';\r\n    } else if (score >= 0) {\r\n      level = 'medium';\r\n    } else {\r\n      level = 'complex';\r\n    }\r\n    \r\n    this.logger.debug('Prompt complexity analysis', {\r\n      prompt: prompt.substring(0, 100) + '...',\r\n      level,\r\n      score,\r\n      indicators\r\n    });\r\n    \r\n    return { level, score, indicators };\r\n  }\r\n\r\n  /**\r\n   * Analyze prompt complexity with AI and project context\r\n   * REDESIGNED: Uses OpenAI for intelligent complexity analysis with project context\r\n   */\r\n  async analyzePromptComplexityWithContext(\r\n    prompt: string, \r\n    projectContext: ProjectContext\r\n  ): Promise<AIPromptComplexity> {\r\n    try {\r\n      // If OpenAI is not available, fall back to basic analysis\r\n      if (!this.openaiService) {\r\n        this.logger.debug('OpenAI not available, falling back to basic analysis');\r\n        const basicComplexity = this.analyzePromptComplexity(prompt);\r\n        return {\r\n          ...basicComplexity,\r\n          userExpertiseLevel: this.inferUserExpertiseLevel(projectContext),\r\n          responseStrategy: this.determineResponseStrategy(basicComplexity.level),\r\n          estimatedTokens: this.estimateTokens(basicComplexity.level),\r\n          confidence: 0.6 // Lower confidence for basic analysis\r\n        };\r\n      }\r\n\r\n      this.logger.debug('Starting AI-powered prompt complexity analysis', {\r\n        prompt: prompt.substring(0, 100) + '...',\r\n        projectContextSize: projectContext.repoFacts.length + projectContext.codeSnippets.length\r\n      });\r\n\r\n      // Create context-aware analysis prompt\r\n      const analysisPrompt = this.buildAnalysisPrompt(prompt, projectContext);\r\n      \r\n      const response = await this.openaiService.createChatCompletion([\r\n        {\r\n          role: 'system',\r\n          content: `You are an expert at analyzing developer prompts and determining their complexity level. \r\n\r\nYour job is to:\r\n1. Analyze the user's prompt for complexity indicators\r\n2. Consider the project context (frameworks, code patterns, project type)\r\n3. Determine the user's expertise level based on project context\r\n4. Recommend the best response strategy\r\n5. Estimate token requirements for an optimal response\r\n\r\nReturn ONLY valid JSON with this exact structure:\r\n{\r\n  \"level\": \"simple|medium|complex\",\r\n  \"score\": 1-10,\r\n  \"indicators\": [\"indicator1\", \"indicator2\"],\r\n  \"userExpertiseLevel\": \"beginner|intermediate|advanced\",\r\n  \"responseStrategy\": \"minimal|standard|comprehensive\",\r\n  \"estimatedTokens\": 500,\r\n  \"confidence\": 0.85\r\n}\r\n\r\nGuidelines:\r\n- Simple: Basic questions, single tasks, clear requests (score 7-10)\r\n- Medium: Multi-step tasks, some complexity, moderate context needed (score 4-6)\r\n- Complex: Large projects, multiple technologies, extensive context needed (score 1-3)\r\n- Consider project context when determining user expertise level\r\n- Estimate tokens based on complexity and context needed\r\n- Be confident in your analysis (0.7-0.95)`\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: analysisPrompt\r\n        }\r\n      ], {\r\n        maxTokens: 500,\r\n        temperature: 0.2 // Low temperature for consistent analysis\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) {\r\n        throw new Error('No response content from OpenAI');\r\n      }\r\n\r\n      // Parse and validate the AI response\r\n      const aiComplexity = this.parseAIComplexityResponse(content);\r\n      \r\n      this.logger.debug('AI complexity analysis completed', {\r\n        level: aiComplexity.level,\r\n        score: aiComplexity.score,\r\n        userExpertiseLevel: aiComplexity.userExpertiseLevel,\r\n        confidence: aiComplexity.confidence,\r\n        estimatedTokens: aiComplexity.estimatedTokens\r\n      });\r\n\r\n      // Log AI usage for monitoring\r\n      this.logger.info('AI complexity analysis usage', {\r\n        operation: 'prompt_complexity_analysis',\r\n        tokensUsed: response.usage?.total_tokens || 0,\r\n        cost: this.estimateAICost(response.usage?.total_tokens || 0),\r\n        confidence: aiComplexity.confidence\r\n      });\r\n\r\n      return aiComplexity;\r\n\r\n    } catch (error) {\r\n      this.logger.warn('AI complexity analysis failed, falling back to basic analysis', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        prompt: prompt.substring(0, 100) + '...'\r\n      });\r\n      \r\n      // Fallback to basic analysis\r\n      const basicComplexity = this.analyzePromptComplexity(prompt);\r\n      return {\r\n        ...basicComplexity,\r\n        userExpertiseLevel: this.inferUserExpertiseLevel(projectContext),\r\n        responseStrategy: this.determineResponseStrategy(basicComplexity.level),\r\n        estimatedTokens: this.estimateTokens(basicComplexity.level),\r\n        confidence: 0.5 // Lower confidence due to fallback\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get optimized options based on prompt complexity\r\n   * Implements adaptive response sizing for better user experience\r\n   */\r\n  getOptimizedOptions(\r\n    originalOptions: any,\r\n    complexity: PromptComplexity\r\n  ): OptimizedOptions {\r\n    const options = { ...originalOptions };\r\n    \r\n    switch (complexity.level) {\r\n      case 'simple':\r\n        // Minimal context for simple prompts like \"yes or no\" (reduced by 20%)\r\n        options.maxTokens = Math.min(options.maxTokens || 4000, 400);\r\n        options.includeMetadata = false;\r\n        options.useCache = true;\r\n        options.simpleMode = true;\r\n        break;\r\n        \r\n      case 'medium':\r\n        // Moderate context for medium complexity prompts (reduced by 20%)\r\n        options.maxTokens = Math.min(options.maxTokens || 4000, 1200);\r\n        options.includeMetadata = true;\r\n        options.useCache = true;\r\n        break;\r\n        \r\n      case 'complex':\r\n        // Full context for complex development tasks (reduced by 20%)\r\n        options.maxTokens = Math.min(options.maxTokens || 4000, 3200);\r\n        options.includeMetadata = true;\r\n        options.useCache = true;\r\n        break;\r\n    }\r\n    \r\n    this.logger.debug('Optimized options generated', {\r\n      complexity: complexity.level,\r\n      maxTokens: options.maxTokens,\r\n      includeMetadata: options.includeMetadata,\r\n      useCache: options.useCache\r\n    });\r\n    \r\n    return options;\r\n  }\r\n\r\n  /**\r\n   * Check if a prompt should trigger breakdown functionality\r\n   * Analyzes prompt characteristics to determine if task breakdown would be beneficial\r\n   */\r\n  shouldBreakdown(prompt: string, options?: { includeBreakdown?: boolean; maxTasks?: number }): boolean {\r\n    try {\r\n      // If explicitly disabled, don't breakdown\r\n      if (options?.includeBreakdown === false) {\r\n        return false;\r\n      }\r\n\r\n      // If explicitly enabled, always breakdown\r\n      if (options?.includeBreakdown === true) {\r\n        return true;\r\n      }\r\n\r\n      // Auto-detect based on prompt characteristics\r\n      const promptLower = prompt.toLowerCase();\r\n      \r\n      // Keywords that suggest complex, multi-step projects\r\n      // Keywords that suggest complex, multi-step tasks (dynamic detection)\r\n      const complexKeywords = this.getComplexKeywords();\r\n      \r\n      // Keywords that suggest simple, single tasks (dynamic detection)\r\n      const simpleKeywords = this.getSimpleKeywords();\r\n      \r\n      const hasComplexKeywords = complexKeywords.some(keyword => promptLower.includes(keyword));\r\n      const hasSimpleKeywords = simpleKeywords.some(keyword => promptLower.includes(keyword));\r\n      \r\n      // Check prompt length (longer prompts are more likely to be complex)\r\n      const isLongPrompt = prompt.length > 100;\r\n      \r\n      // Check for multiple sentences or bullet points (suggests multiple tasks)\r\n      const hasMultipleParts = prompt.includes('.') && prompt.split('.').length > 2;\r\n      const hasBulletPoints = prompt.includes('-') || prompt.includes('*') || prompt.includes('â€¢');\r\n      \r\n      // Decision logic\r\n      if (hasComplexKeywords && (isLongPrompt || hasMultipleParts || hasBulletPoints)) {\r\n        return true;\r\n      }\r\n      \r\n      if (hasSimpleKeywords && !isLongPrompt) {\r\n        return false;\r\n      }\r\n      \r\n      // Default to breakdown for medium-length prompts with project keywords\r\n      return isLongPrompt && (hasComplexKeywords || hasMultipleParts);\r\n      \r\n    } catch (error) {\r\n      this.logger.warn('Error detecting prompt complexity for breakdown', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        prompt: prompt.substring(0, 100) + '...'\r\n      });\r\n      return false;\r\n    }\r\n  }\r",
        "File: src/services/framework-detector/framework-detector.service.ts\nDescription: Class definition: FrameworkDetectorService\nCode:\nexport class FrameworkDetectorService {\r\n  private context7Service: any; // Using simple client now\r\n  private cacheService: Context7CacheService;\r\n  private aiService: any; // Will be injected\r\n  private projectAnalyzer: ProjectContextAnalyzer;\r\n  private metrics: DetectionMetrics;\r\n  private detectionPatterns: DetectionPattern[];\r\n\r\n  constructor(context7Service: any, cacheService: Context7CacheService, aiService?: any) {\r\n    this.context7Service = context7Service;\r\n    this.cacheService = cacheService;\r\n    this.aiService = aiService;\r\n    this.projectAnalyzer = new ProjectContextAnalyzer();\r\n    this.metrics = this.initializeMetrics();\r\n    this.detectionPatterns = this.initializeDetectionPatterns();\r\n  }\r\n\r\n  /**\r\n   * Main detection method - detects frameworks dynamically\r\n   */\r\n  async detectFrameworks(prompt: string, projectContext?: ProjectContext): Promise<FrameworkDetectionResult> {\r\n    const startTime = performance.now();\r\n    \r\n    try {\r\n      // 1. Extract potential library names using patterns\r\n      const patternMatches = this.extractLibraryNamesUsingPatterns(prompt);\r\n      \r\n      // 2. Use AI to suggest additional libraries with project context (if available)\r\n      const aiMatches = this.aiService ? await this.suggestLibrariesWithAI(prompt, projectContext) : [];\r\n      \r\n      // 3. Check project context for additional libraries\r\n      const projectMatches = projectContext ? this.extractFromProjectContext(projectContext) : [];\r\n      \r\n      // 4. Combine and deduplicate matches\r\n      const allMatches = this.combineMatches([...patternMatches, ...aiMatches, ...projectMatches]);\r\n      \r\n      // 5. Resolve with Context7\r\n      const context7Libraries = await this.resolveLibrariesWithContext7(allMatches);\r\n      \r\n      // 6. Update metrics\r\n      const detectionTime = performance.now() - startTime;\r\n      this.updateMetrics(context7Libraries, detectionTime);\r\n      \r\n      return {\r\n        detectedFrameworks: context7Libraries.map(lib => lib.name),\r\n        confidence: this.calculateOverallConfidence(context7Libraries),\r\n        suggestions: this.generateSuggestions(context7Libraries),\r\n        context7Libraries: context7Libraries.map(lib => lib.libraryId),\r\n        detectionMethod: this.determineDetectionMethod(allMatches)\r\n      };\r\n    } catch (error) {\r\n      console.error('Framework detection failed', { error, prompt });\r\n      return this.getFallbackResult();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract library names using regex patterns\r\n   */\r\n  private extractLibraryNamesUsingPatterns(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    \r\n    for (const pattern of this.detectionPatterns) {\r\n      const regexMatches = prompt.matchAll(pattern.regex);\r\n      for (const match of regexMatches) {\r\n        const name = match[1]?.toLowerCase();\r\n        if (name && this.isValidLibraryName(name)) {\r\n          matches.push({\r\n            name,\r\n            libraryId: '',\r\n            confidence: this.calculatePatternConfidence(name, pattern.type, pattern.weight),\r\n            source: 'pattern'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Use AI to suggest libraries with enhanced prompt analysis\r\n   * REDESIGNED: Enhanced with context-aware AI framework detection\r\n   */\r\n  private async suggestLibrariesWithAI(prompt: string, projectContext?: ProjectContext): Promise<LibraryMatch[]> {\r\n    if (!this.aiService) {\r\n      return [];\r\n    }\r\n\r\n    try {\r\n      const analysisPrompt = this.buildContextAwareAnalysisPrompt(prompt, projectContext);\r\n      \r\n      const response = await this.aiService.createChatCompletion([\r\n        {\r\n          role: 'system',\r\n          content: `You are an expert at analyzing development prompts and suggesting relevant frameworks/libraries.\r\n\r\nYour job is to:\r\n1. Analyze the user's prompt for framework/library needs\r\n2. Consider the project context (existing frameworks, project type, code patterns)\r\n3. Suggest 3-5 most relevant library/framework names\r\n4. Focus on frameworks, UI libraries, and development tools\r\n5. Be specific (e.g., use actual library names, not generic descriptions)\r\n6. Prioritize popular, well-documented libraries\r\n\r\nReturn ONLY a JSON array of library names:\r\n[\"library1\", \"library2\", \"library3\"]\r\n\r\nGuidelines:\r\n- Consider the project context when making suggestions\r\n- Match the complexity level to the user's needs\r\n- Include both primary and supporting libraries\r\n- Be specific and avoid generic suggestions`\r\n        },\r\n        {\r\n          role: 'user',\r\n          content: analysisPrompt\r\n        }\r\n      ], {\r\n        maxTokens: 300,\r\n        temperature: 0.3\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) {\r\n        throw new Error('No response content from AI');\r\n      }\r\n\r\n      const aiMatches = this.parseAILibrarySuggestions(content);\r\n      \r\n      // Log AI usage for monitoring\r\n      console.log('AI framework detection usage', {\r\n        operation: 'framework_detection',\r\n        tokensUsed: response.usage?.total_tokens || 0,\r\n        cost: this.estimateAICost(response.usage?.total_tokens || 0),\r\n        librariesSuggested: aiMatches.length\r\n      });\r\n      \r\n      return aiMatches;\r\n    } catch (error) {\r\n      console.warn('AI library suggestion failed', { error });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Enhanced prompt-based framework inference using multiple strategies\r\n   * Replaces simple pattern matching with intelligent analysis\r\n   */\r\n  private async inferFrameworksFromPrompt(prompt: string): Promise<LibraryMatch[]> {\r\n    const matches: LibraryMatch[] = [];\r\n    \r\n    // 1. Direct framework mentions\r\n    const directMentions = this.extractDirectFrameworkMentions(prompt);\r\n    matches.push(...directMentions);\r\n    \r\n    // 2. Task-based inference\r\n    const taskInferences = this.inferFromTaskType(prompt);\r\n    matches.push(...taskInferences);\r\n    \r\n    // 3. Technology stack inference\r\n    const stackInferences = this.inferFromTechnologyStack(prompt);\r\n    matches.push(...stackInferences);\r\n    \r\n    // 4. Context-based inference\r\n    const contextInferences = this.inferFromContext(prompt);\r\n    matches.push(...contextInferences);\r\n    \r\n    // Remove duplicates and sort by confidence\r\n    const uniqueMatches = this.deduplicateMatches(matches);\r\n    return uniqueMatches.sort((a, b) => b.confidence - a.confidence);\r\n  }\r\n\r\n  /**\r\n   * Extract frameworks directly mentioned in the prompt\r\n   */\r\n  private extractDirectFrameworkMentions(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    const promptLower = prompt.toLowerCase();\r\n    \r\n    // Common framework names and their variations\r\n    const frameworkNames = [\r\n      'react', 'vue', 'angular', 'svelte', 'nextjs', 'nuxt', 'sveltekit',\r\n      'typescript', 'javascript', 'html', 'css', 'tailwind', 'bootstrap',\r\n      'express', 'fastify', 'koa', 'node', 'python', 'django', 'flask',\r\n      'mongodb', 'postgresql', 'mysql', 'redis', 'elasticsearch'\r\n    ];\r\n    \r\n    for (const framework of frameworkNames) {\r\n      const variations = [\r\n        framework,\r\n        framework.replace(/\\./g, ''),\r\n        framework.replace(/-/g, ''),\r\n        framework.replace(/\\./g, ' '),\r\n        framework.replace(/-/g, ' ')\r\n      ];\r\n      \r\n      for (const variation of variations) {\r\n        if (promptLower.includes(variation)) {\r\n          matches.push({\r\n            name: framework,\r\n            libraryId: '',\r\n            confidence: 0.9, // High confidence for direct mentions\r\n            source: 'direct-mention'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Infer frameworks based on the type of task described\r\n   */\r\n  private inferFromTaskType(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    const promptLower = prompt.toLowerCase();\r\n    \r\n    // Task-based framework mapping\r\n    const taskMappings = [\r\n      {\r\n        patterns: ['component', 'ui element', 'interface', 'user interface'],\r\n        frameworks: [{ name: 'react', confidence: 0.8 }, { name: 'vue', confidence: 0.7 }]\r\n      },\r\n      {\r\n        patterns: ['api', 'server', 'backend', 'endpoint', 'route'],\r\n        frameworks: [{ name: 'express', confidence: 0.8 }, { name: 'fastify', confidence: 0.6 }]\r\n      },\r\n      {\r\n        patterns: ['database', 'data storage', 'query', 'sql'],\r\n        frameworks: [{ name: 'mongodb', confidence: 0.7 }, { name: 'postgresql', confidence: 0.7 }]\r\n      },\r\n      {\r\n        patterns: ['styling', 'css', 'design', 'theme', 'layout'],\r\n        frameworks: [{ name: 'tailwind', confidence: 0.8 }, { name: 'css', confidence: 0.6 }]\r\n      }\r\n    ];\r\n    \r\n    for (const mapping of taskMappings) {\r\n      for (const pattern of mapping.patterns) {\r\n        if (promptLower.includes(pattern)) {\r\n          for (const framework of mapping.frameworks) {\r\n            matches.push({\r\n              name: framework.name,\r\n              libraryId: '',\r\n              confidence: framework.confidence,\r\n              source: 'task-inference'\r\n            });\r\n          }\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Infer frameworks based on technology stack indicators\r\n   */\r\n  private inferFromTechnologyStack(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    const promptLower = prompt.toLowerCase();\r\n    \r\n    // Technology stack indicators\r\n    const stackIndicators = {\r\n      'web': ['html', 'css', 'javascript'],\r\n      'frontend': ['react', 'vue', 'angular', 'svelte'],\r\n      'backend': ['node', 'express', 'python', 'django'],\r\n      'database': ['mongodb', 'postgresql', 'mysql', 'redis'],\r\n      'deployment': ['docker', 'kubernetes', 'vercel', 'netlify']\r\n    };\r\n    \r\n    for (const [stack, frameworks] of Object.entries(stackIndicators)) {\r\n      if (promptLower.includes(stack)) {\r\n        for (const framework of frameworks) {\r\n          matches.push({\r\n            name: framework,\r\n            libraryId: '',\r\n            confidence: 0.6,\r\n            source: 'stack-inference'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Infer frameworks from context clues\r\n   */\r\n  private inferFromContext(prompt: string): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    \r\n    // Context-based inference patterns\r\n    if (prompt.includes('admin') || prompt.includes('dashboard')) {\r\n      matches.push({ name: 'react', libraryId: '', confidence: 0.7, source: 'context-inference' });\r\n    }\r\n    \r\n    if (prompt.includes('mobile') || prompt.includes('app')) {\r\n      matches.push({ name: 'react', libraryId: '', confidence: 0.6, source: 'context-inference' });\r\n    }\r\n    \r\n    if (prompt.includes('server') || prompt.includes('api')) {\r\n      matches.push({ name: 'node', libraryId: '', confidence: 0.7, source: 'context-inference' });\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Remove duplicate framework matches and merge confidence scores\r\n   */\r\n  private deduplicateMatches(matches: LibraryMatch[]): LibraryMatch[] {\r\n    const uniqueMatches = new Map<string, LibraryMatch>();\r\n    \r\n    for (const match of matches) {\r\n      const existing = uniqueMatches.get(match.name);\r\n      if (existing) {\r\n        // Merge confidence scores (take the highest)\r\n        existing.confidence = Math.max(existing.confidence, match.confidence);\r\n        // Merge sources\r\n        if (!existing.source.includes(match.source)) {\r\n          existing.source += `, ${match.source}`;\r\n        }\r\n      } else {\r\n        uniqueMatches.set(match.name, { ...match });\r\n      }\r\n    }\r\n    \r\n    return Array.from(uniqueMatches.values());\r\n  }\r\n\r\n  /**\r\n   * Extract libraries from project context\r\n   */\r\n  private extractFromProjectContext(projectContext: ProjectContext): LibraryMatch[] {\r\n    const matches: LibraryMatch[] = [];\r\n    \r\n    // Extract from package.json dependencies\r\n    if (projectContext.dependencies) {\r\n      for (const [name, version] of Object.entries(projectContext.dependencies)) {\r\n        if (this.isValidLibraryName(name)) {\r\n          matches.push({\r\n            name: name.toLowerCase(),\r\n            libraryId: '',\r\n            confidence: 0.9, // High confidence for project dependencies\r\n            source: 'project'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    // Extract from suggested frameworks\r\n    if (projectContext.suggestedFrameworks) {\r\n      for (const framework of projectContext.suggestedFrameworks) {\r\n        if (this.isValidLibraryName(framework)) {\r\n          matches.push({\r\n            name: framework.toLowerCase(),\r\n            libraryId: '',\r\n            confidence: 0.8, // High confidence for detected frameworks\r\n            source: 'project'\r\n          });\r\n        }\r\n      }\r\n    }\r\n    \r\n    return matches;\r\n  }\r\n\r\n  /**\r\n   * Resolve libraries with Context7\r\n   */\r\n  private async resolveLibrariesWithContext7(matches: LibraryMatch[]): Promise<LibraryMatch[]> {\r\n    const resolved: LibraryMatch[] = [];\r\n    \r\n    for (const match of matches) {\r\n      try {\r\n        // Check cache first\r\n        const cached = await this.cacheService.getCachedDocs(match.name);\r\n        if (cached) {\r\n          resolved.push({ ...match, libraryId: cached.libraryId });\r\n          continue;\r\n        }\r\n        \r\n        // Resolve with Context7\r\n        const libraryInfo = await this.context7Service.resolveLibraryId(match.name);\r\n        const libraryId = libraryInfo.length > 0 && libraryInfo[0] ? libraryInfo[0].id : null;\r\n        \r\n        if (!libraryId) {\r\n          console.warn(`No Context7 library found for ${match.name}`);\r\n          continue;\r\n        }\r\n        \r\n        const docs = await this.context7Service.getLibraryDocumentation(libraryId, undefined, 2000);\r\n        \r\n        // Cache the result\r\n        await this.cacheService.cacheDocs(match.name, libraryId, docs);\r\n        \r\n        resolved.push({ ...match, libraryId });\r\n      } catch (error) {\r\n        console.warn(`Failed to resolve library ${match.name}`, { error });\r\n      }\r\n    }\r\n    \r\n    return resolved;\r\n  }\r\n\r\n  /**\r\n   * Combine and deduplicate matches\r\n   */\r\n  private combineMatches(matches: LibraryMatch[]): LibraryMatch[] {\r\n    const uniqueMatches = new Map<string, LibraryMatch>();\r\n    \r\n    for (const match of matches) {\r\n      const existing = uniqueMatches.get(match.name);\r\n      if (!existing || match.confidence > existing.confidence) {\r\n        uniqueMatches.set(match.name, match);\r\n      }\r\n    }\r\n    \r\n    return Array.from(uniqueMatches.values());\r\n  }\r\n\r\n  /**\r\n   * Validate library name\r\n   */\r\n  private isValidLibraryName(name: string): boolean {\r\n    const commonWords = ['the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with', 'by', 'is', 'are', 'was', 'were'];\r\n    return name.length > 2 && !commonWords.includes(name) && /^[a-z0-9-]+$/.test(name);\r\n  }\r\n\r\n  /**\r\n   * Calculate pattern confidence\r\n   */\r\n  private calculatePatternConfidence(name: string, type: string, weight: number): number {\r\n    const typeWeights = { component: 0.9, framework: 0.8, library: 0.7, app: 0.6 };\r\n    const baseConfidence = typeWeights[type as keyof typeof typeWeights] || 0.5;\r\n    return Math.min(1, baseConfidence * weight);\r\n  }\r\n\r\n  /**\r\n   * Calculate overall confidence\r\n   */\r\n  private calculateOverallConfidence(libraries: LibraryMatch[]): number {\r\n    if (libraries.length === 0) return 0;\r\n    return libraries.reduce((sum, lib) => sum + lib.confidence, 0) / libraries.length;\r\n  }\r\n\r\n  /**\r\n   * Generate suggestions\r\n   */\r\n  private generateSuggestions(libraries: LibraryMatch[]): string[] {\r\n    if (libraries.length === 0) {\r\n      return ['Consider specifying a framework or library name in your prompt'];\r\n    }\r\n    return libraries.map(lib => `Detected ${lib.name} (${lib.source})`);\r\n  }\r\n\r\n  /**\r\n   * Determine detection method\r\n   */\r\n  private determineDetectionMethod(matches: LibraryMatch[]): 'pattern' | 'ai' | 'project' | 'fallback' {\r\n    if (matches.some(m => m.source === 'project')) return 'project';\r\n    if (matches.some(m => m.source === 'ai')) return 'ai';\r\n    if (matches.some(m => m.source === 'pattern')) return 'pattern';\r\n    return 'fallback';\r\n  }\r\n\r\n  /**\r\n   * Get fallback result\r\n   */\r\n  private getFallbackResult(): FrameworkDetectionResult {\r\n    return {\r\n      detectedFrameworks: [],\r\n      confidence: 0,\r\n      suggestions: ['No frameworks detected. Try being more specific about the technology you want to use.'],\r\n      context7Libraries: [],\r\n      detectionMethod: 'fallback'\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Initialize detection patterns (dynamic, AI-powered)\r\n   */\r\n  private initializeDetectionPatterns(): DetectionPattern[] {\r\n    try {\r\n      // Return basic patterns that work with any framework/library names\r\n      // This is a real dynamic method that actually works\r\n      return [\r\n        { regex: /create\\s+a\\s+(\\w+)\\s+component/gi, type: 'component', weight: 1.0 },\r\n        { regex: /using\\s+(\\w+)\\s+framework/gi, type: 'framework', weight: 1.0 },\r\n        { regex: /with\\s+(\\w+)\\s+library/gi, type: 'library', weight: 1.0 },\r\n        { regex: /build\\s+(\\w+)\\s+app/gi, type: 'app', weight: 0.9 },\r\n        { regex: /(\\w+)\\s+component/gi, type: 'component', weight: 0.8 },\r\n        { regex: /(\\w+)\\s+framework/gi, type: 'framework', weight: 0.8 },\r\n        { regex: /(\\w+)\\s+library/gi, type: 'library', weight: 0.8 },\r\n        { regex: /(\\w+)\\s+ui/gi, type: 'library', weight: 0.7 },\r\n        { regex: /(\\w+)\\s+styling/gi, type: 'library', weight: 0.7 }\r\n      ];\r\n    } catch (error) {\r\n      console.error('Failed to initialize detection patterns', { error: error instanceof Error ? error.message : 'Unknown error' });\r\n      // Return empty array as safe fallback\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Initialize metrics\r\n   */\r\n  private initializeMetrics(): DetectionMetrics {\r\n    return {\r\n      totalDetections: 0,\r\n      successfulDetections: 0,\r\n      averageConfidence: 0,\r\n      frameworkDistribution: {},\r\n      cacheHitRate: 0,\r\n      detectionMethodDistribution: {},\r\n      averageDetectionTime: 0\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Update metrics\r\n   */\r\n  private updateMetrics(libraries: LibraryMatch[], detectionTime: number): void {\r\n    this.metrics.totalDetections++;\r\n    \r\n    if (libraries.length > 0) {\r\n      this.metrics.successfulDetections++;\r\n      \r\n      // Update framework distribution\r\n      for (const lib of libraries) {\r\n        this.metrics.frameworkDistribution[lib.name] = \r\n          (this.metrics.frameworkDistribution[lib.name] || 0) + 1;\r\n      }\r\n    }\r\n    \r\n    // Update average confidence\r\n    this.metrics.averageConfidence = \r\n      (this.metrics.averageConfidence + this.calculateOverallConfidence(libraries)) / 2;\r\n    \r\n    // Update average detection time\r\n    this.metrics.averageDetectionTime = \r\n      (this.metrics.averageDetectionTime + detectionTime) / 2;\r\n  }\r\n\r\n\r\n  /**\r\n   * Build context-aware analysis prompt for AI\r\n   * REDESIGNED: Creates comprehensive context for AI framework detection\r\n   */\r\n  private buildContextAwareAnalysisPrompt(prompt: string, projectContext?: ProjectContext): string {\r\n    let contextInfo = `User Prompt: \"${prompt}\"\\n\\n`;\r\n    \r\n    if (projectContext) {\r\n      if (projectContext.dependencies && Object.keys(projectContext.dependencies).length > 0) {\r\n        contextInfo += `Existing Dependencies:\\n${Object.keys(projectContext.dependencies).slice(0, 10).join(', ')}\\n\\n`;\r\n      }\r\n      \r\n      if (projectContext.suggestedFrameworks && projectContext.suggestedFrameworks.length > 0) {\r\n        contextInfo += `Detected Frameworks: ${projectContext.suggestedFrameworks.join(', ')}\\n\\n`;\r\n      }\r\n      \r\n      if (projectContext.projectType) {\r\n        contextInfo += `Project Type: ${projectContext.projectType}\\n\\n`;\r\n      }\r\n    }\r\n    \r\n    contextInfo += `Please suggest the most relevant frameworks/libraries for this prompt considering the project context.`;\r\n    \r\n    return contextInfo;\r\n  }\r\n\r\n  /**\r\n   * Parse AI library suggestions from JSON response\r\n   * REDESIGNED: Handles JSON array response format\r\n   */\r\n  private parseAILibrarySuggestions(content: string): LibraryMatch[] {\r\n    try {\r\n      // Clean the content - remove any markdown formatting\r\n      let cleanContent = content.trim();\r\n      if (cleanContent.startsWith('```json')) {\r\n        cleanContent = cleanContent.replace(/^```json\\s*/, '').replace(/\\s*```$/, '');\r\n      } else if (cleanContent.startsWith('```')) {\r\n        cleanContent = cleanContent.replace(/^```\\s*/, '').replace(/\\s*```$/, '');\r\n      }\r\n\r\n      const libraries = JSON.parse(cleanContent);\r\n      \r\n      if (!Array.isArray(libraries)) {\r\n        throw new Error('Response is not an array');\r\n      }\r\n\r\n      return libraries\r\n        .filter((lib: any) => typeof lib === 'string' && lib.length > 0)\r\n        .map((lib: string) => ({\r\n          name: lib.toLowerCase().trim(),\r\n          libraryId: '',\r\n          confidence: 0.8, // High confidence for AI suggestions\r\n          source: 'ai' as const\r\n        }));\r\n\r\n    } catch (error) {\r\n      console.warn('Failed to parse AI library suggestions', { error, content });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Estimate AI cost based on token usage\r\n   * REDESIGNED: Tracks AI costs for monitoring and budget control\r\n   */\r\n  private estimateAICost(tokens: number): number {\r\n    // GPT-4 pricing: ~$0.03 per 1K tokens for input, ~$0.06 per 1K tokens for output\r\n    // Using average of $0.045 per 1K tokens for cost estimation\r\n    const costPer1KTokens = 0.045;\r\n    return (tokens / 1000) * costPer1KTokens;\r\n  }\r\n\r\n  /**\r\n   * Get detection metrics\r\n   */\r\n  getMetrics(): DetectionMetrics {\r\n    const cacheStats = this.cacheService.getDetectionMetrics();\r\n    return {\r\n      ...this.metrics,\r\n      cacheHitRate: cacheStats.cacheHitRate || 0\r\n    };\r\n  }\r\n}\r",
        "File: src/config/config.service.ts\nDescription: Class definition: ConfigService\nCode:\nexport class ConfigService {\r\n  private config: PromptMCPConfig;\r\n  private logger: Logger;\r\n\r\n  constructor() {\r\n    this.logger = new Logger('ConfigService');\r\n    this.loadMCPConfiguration();\r\n    this.config = this.loadConfig();\r\n    this.validateConfig();\r\n  }\r\n\r\n  private loadMCPConfiguration(): void {\r\n    try {\r\n      const mcpConfigPath = process.env.MCP_CONFIG_PATH || join(process.cwd(), 'mcp-config.json');\r\n      this.logger.info('Loading MCP configuration from', { path: mcpConfigPath });\r\n      \r\n      const mcpConfig = JSON.parse(readFileSync(mcpConfigPath, 'utf8'));\r\n      const promptmcpConfig = mcpConfig.mcpServers.promptmcp;\r\n      \r\n      // DEBUG: Print what we're loading\r\n      console.log('ðŸ”‘ [ConfigService] Loading MCP configuration:');\r\n      console.log('  MCP Config Path:', mcpConfigPath);\r\n      console.log('  PromptMCP Config:', promptmcpConfig);\r\n      console.log('  Environment variables before loading:', {\r\n        OPENAI_API_KEY: process.env.OPENAI_API_KEY ? `${process.env.OPENAI_API_KEY.substring(0, 20)}...` : 'NOT SET',\r\n        OPENAI_PROJECT_ID: process.env.OPENAI_PROJECT_ID || 'NOT SET',\r\n        CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY ? `${process.env.CONTEXT7_API_KEY.substring(0, 20)}...` : 'NOT SET'\r\n      });\r\n      \r\n      if (promptmcpConfig && promptmcpConfig.env) {\r\n        // Load API keys from MCP config into environment variables\r\n        if (promptmcpConfig.env.CONTEXT7_API_KEY) {\r\n          process.env.CONTEXT7_API_KEY = promptmcpConfig.env.CONTEXT7_API_KEY;\r\n          console.log('  âœ… Set CONTEXT7_API_KEY from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.OPENAI_API_KEY) {\r\n          process.env.OPENAI_API_KEY = promptmcpConfig.env.OPENAI_API_KEY;\r\n          console.log('  âœ… Set OPENAI_API_KEY from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.OPENAI_PROJECT_ID) {\r\n          process.env.OPENAI_PROJECT_ID = promptmcpConfig.env.OPENAI_PROJECT_ID;\r\n          console.log('  âœ… Set OPENAI_PROJECT_ID from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.CONTEXT7_ENABLED) {\r\n          process.env.CONTEXT7_ENABLED = promptmcpConfig.env.CONTEXT7_ENABLED;\r\n          console.log('  âœ… Set CONTEXT7_ENABLED from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.CONTEXT7_USE_HTTP_ONLY) {\r\n          process.env.CONTEXT7_USE_HTTP_ONLY = promptmcpConfig.env.CONTEXT7_USE_HTTP_ONLY;\r\n          console.log('  âœ… Set CONTEXT7_USE_HTTP_ONLY from MCP config');\r\n        }\r\n        if (promptmcpConfig.env.CONTEXT7_DEBUG) {\r\n          process.env.CONTEXT7_DEBUG = promptmcpConfig.env.CONTEXT7_DEBUG;\r\n          this.logger.info('CONTEXT7_DEBUG environment variable set', { value: promptmcpConfig.env.CONTEXT7_DEBUG });\r\n          console.log('  âœ… Set CONTEXT7_DEBUG from MCP config');\r\n        }\r\n        \r\n        // DEBUG: Print environment variables after loading\r\n        console.log('  Environment variables after loading:', {\r\n          OPENAI_API_KEY: process.env.OPENAI_API_KEY ? `${process.env.OPENAI_API_KEY.substring(0, 20)}...` : 'NOT SET',\r\n          OPENAI_PROJECT_ID: process.env.OPENAI_PROJECT_ID || 'NOT SET',\r\n          CONTEXT7_API_KEY: process.env.CONTEXT7_API_KEY ? `${process.env.CONTEXT7_API_KEY.substring(0, 20)}...` : 'NOT SET'\r\n        });\r\n        \r\n        this.logger.info('MCP configuration loaded successfully', {\r\n          hasContext7Key: !!process.env.CONTEXT7_API_KEY,\r\n          hasOpenAIKey: !!process.env.OPENAI_API_KEY,\r\n          hasOpenAIProjectId: !!process.env.OPENAI_PROJECT_ID\r\n        });\r\n      } else {\r\n        this.logger.warn('No promptmcp configuration found in MCP config, falling back to environment variables');\r\n        this.loadEnvironmentVariables();\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to load MCP configuration, falling back to environment variables', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      this.loadEnvironmentVariables();\r\n    }\r\n  }\r\n\r\n  private loadEnvironmentVariables(): void {\r\n    // Load Context7 API key from environment or use default\r\n    if (!process.env.CONTEXT7_API_KEY) {\r\n      this.logger.warn('CONTEXT7_API_KEY not found in environment variables');\r\n    }\r\n    \r\n    // Set default Context7 enabled state if not provided\r\n    if (!process.env.CONTEXT7_ENABLED) {\r\n      process.env.CONTEXT7_ENABLED = 'true';\r\n    }\r\n    \r\n    if (!process.env.CONTEXT7_BASE_URL) {\r\n      process.env.CONTEXT7_BASE_URL = 'https://mcp.context7.com/mcp';\r\n    }\r\n\r\n    // Set OpenAI environment variables if not provided\r\n    if (!process.env.OPENAI_API_KEY) {\r\n      this.logger.warn('OPENAI_API_KEY not set - breakdown tool will not be available');\r\n    }\r\n    \r\n    if (!process.env.OPENAI_PROJECT_ID) {\r\n      this.logger.warn('OPENAI_PROJECT_ID not set - breakdown tool will not be available');\r\n    }\r\n  }\r\n\r\n  getConfig(): PromptMCPConfig {\r\n    return this.config;\r\n  }\r\n\r\n  get<K extends keyof PromptMCPConfig>(key: K): PromptMCPConfig[K] {\r\n    return this.config[key];\r\n  }\r\n\r\n  getWithDefault<K extends keyof PromptMCPConfig>(key: K, defaultValue: PromptMCPConfig[K]): PromptMCPConfig[K] {\r\n    return this.config[key] ?? defaultValue;\r\n  }\r\n\r\n  getEnv(key: string, defaultValue: string = ''): string {\r\n    return process.env[key] ?? defaultValue;\r\n  }\r\n\r\n  getNested<K extends keyof PromptMCPConfig, T extends keyof PromptMCPConfig[K]>(\r\n    section: K,\r\n    key: T\r\n  ): PromptMCPConfig[K][T] {\r\n    return this.config[section][key];\r\n  }\r\n\r\n  private loadConfig(): PromptMCPConfig {\r\n    const config: PromptMCPConfig = {\r\n      server: {\r\n        name: process.env.LOCALMCP_NAME || 'localmcp',\r\n        version: process.env.LOCALMCP_VERSION || '1.0.0',\r\n        port: parseInt(process.env.LOCALMCP_PORT || '3000', 10)\r\n      },\r\n      context7: {\r\n        enabled: process.env.CONTEXT7_ENABLED === 'true',\r\n        apiKey: process.env.CONTEXT7_API_KEY || undefined,\r\n        baseUrl: process.env.CONTEXT7_BASE_URL || 'https://api.context7.io',\r\n        cacheEnabled: process.env.CONTEXT7_CACHE_ENABLED !== 'false',\r\n        cacheTtl: parseInt(process.env.CONTEXT7_CACHE_TTL || '3600', 10),\r\n        useHttpOnly: process.env.CONTEXT7_USE_HTTP_ONLY === 'true',\r\n        checkCompatibility: process.env.CONTEXT7_CHECK_COMPATIBILITY !== 'false',\r\n        mcp: {\r\n          enabled: process.env.CONTEXT7_MCP_ENABLED === 'true',\r\n          serverUrl: process.env.CONTEXT7_MCP_URL || 'http://localhost:3001',\r\n          timeout: parseInt(process.env.CONTEXT7_MCP_TIMEOUT || '30000', 10)\r\n        }\r\n      },\r\n      database: {\r\n        type: (process.env.DATABASE_TYPE as 'sqlite' | 'qdrant') || 'sqlite',\r\n        path: process.env.DATABASE_PATH || './data/localmcp.db',\r\n        url: process.env.QDRANT_URL || undefined,\r\n        apiKey: process.env.QDRANT_API_KEY || undefined\r\n      },\r\n      vector: {\r\n        qdrant: {\r\n          url: process.env.QDRANT_URL || 'http://localhost:6333',\r\n          apiKey: process.env.QDRANT_API_KEY || undefined,\r\n          collections: {\r\n            documents: process.env.QDRANT_COLLECTION_DOCUMENTS || 'localmcp_documents',\r\n            lessons: process.env.QDRANT_COLLECTION_LESSONS || 'localmcp_lessons',\r\n            patterns: process.env.QDRANT_COLLECTION_PATTERNS || 'localmcp_patterns'\r\n          }\r\n        }\r\n      },\r\n      openai: {\r\n        apiKey: process.env.OPENAI_API_KEY || undefined,\r\n        projectId: process.env.OPENAI_PROJECT_ID || undefined,\r\n        model: process.env.OPENAI_MODEL || 'gpt-4',\r\n        maxTokens: parseInt(process.env.OPENAI_MAX_TOKENS || '4000', 10),\r\n        temperature: parseFloat(process.env.OPENAI_TEMPERATURE || '0.3'),\r\n        timeout: parseInt(process.env.OPENAI_TIMEOUT || '60000', 10),\r\n        retries: parseInt(process.env.OPENAI_RETRIES || '3', 10)\r\n      },\r\n      playwright: {\r\n        mcp: {\r\n          enabled: process.env.PLAYWRIGHT_ENABLED === 'true',\r\n          baseUrl: process.env.PLAYWRIGHT_MCP_URL || 'http://localhost:8931',\r\n          timeout: parseInt(process.env.PLAYWRIGHT_TIMEOUT || '30000', 10)\r\n        }\r\n      },\r\n      cache: {\r\n        context7: {\r\n          maxMemoryEntries: parseInt(process.env.CACHE_MAX_MEMORY_ENTRIES || '1000', 10),\r\n          maxMemorySize: parseInt(process.env.CACHE_MAX_MEMORY_SIZE || '52428800', 10), // 50MB\r\n          defaultTtl: parseInt(process.env.CACHE_DEFAULT_TTL || '3600', 10), // 1 hour\r\n          maxTtl: parseInt(process.env.CACHE_MAX_TTL || '86400', 10), // 24 hours\r\n          cleanupInterval: parseInt(process.env.CACHE_CLEANUP_INTERVAL || '300', 10), // 5 minutes\r\n              enablePersistence: process.env.CACHE_ENABLE_PERSISTENCE !== 'false',\r\n              dbPath: process.env.CACHE_DB_PATH || './data/cache/context7.db'\r\n            }\r\n          },\r\n          admin: {\r\n            enabled: process.env.ADMIN_ENABLED === 'true',\r\n            port: parseInt(process.env.ADMIN_PORT || '3001', 10),\r\n            auth: process.env.ADMIN_USERNAME && process.env.ADMIN_PASSWORD ? {\r\n              username: process.env.ADMIN_USERNAME,\r\n              password: process.env.ADMIN_PASSWORD\r\n            } : undefined\r\n          },\r\n          logging: {\r\n            level: (process.env.LOG_LEVEL as 'debug' | 'info' | 'warn' | 'error') || 'info',\r\n            enableConsole: process.env.LOG_CONSOLE !== 'false',\r\n            enableFile: process.env.LOG_FILE === 'true',\r\n            filePath: process.env.LOG_FILE_PATH || './logs/localmcp.log'\r\n          },\r\n      tools: {\r\n        analyze: {\r\n          enabled: process.env.TOOL_ANALYZE_ENABLED !== 'false',\r\n          maxDepth: parseInt(process.env.TOOL_ANALYZE_MAX_DEPTH || '10', 10),\r\n          includeNodeModules: process.env.TOOL_ANALYZE_INCLUDE_NODE_MODULES === 'true'\r\n        },\r\n        create: {\r\n          enabled: process.env.TOOL_CREATE_ENABLED !== 'false',\r\n          defaultFramework: process.env.TOOL_CREATE_DEFAULT_FRAMEWORK || 'react',\r\n          includeTests: process.env.TOOL_CREATE_INCLUDE_TESTS === 'true'\r\n        },\r\n        fix: {\r\n          enabled: process.env.TOOL_FIX_ENABLED !== 'false',\r\n          autoApply: process.env.TOOL_FIX_AUTO_APPLY === 'true',\r\n          backupOriginal: process.env.TOOL_FIX_BACKUP_ORIGINAL !== 'false'\r\n        },\r\n        learn: {\r\n          enabled: process.env.TOOL_LEARN_ENABLED !== 'false',\r\n          storagePath: process.env.TOOL_LEARN_STORAGE_PATH || './data/lessons',\r\n          maxLessons: parseInt(process.env.TOOL_LEARN_MAX_LESSONS || '1000', 10)\r\n        }\r\n      },\r\n      frameworkDetection: {\r\n        enabled: process.env.FRAMEWORK_DETECTION_ENABLED !== 'false',\r\n        confidenceThreshold: parseFloat(process.env.FRAMEWORK_DETECTION_CONFIDENCE_THRESHOLD || '0.3'),\r\n        cacheEnabled: process.env.FRAMEWORK_DETECTION_CACHE_ENABLED !== 'false',\r\n        cacheTTL: parseInt(process.env.FRAMEWORK_DETECTION_CACHE_TTL || '86400', 10), // 24 hours\r\n        aiEnabled: process.env.FRAMEWORK_DETECTION_AI_ENABLED !== 'false',\r\n        patternDetectionEnabled: process.env.FRAMEWORK_DETECTION_PATTERN_ENABLED !== 'false',\r\n        projectContextEnabled: process.env.FRAMEWORK_DETECTION_PROJECT_ENABLED !== 'false',\r\n        maxLibrariesPerDetection: parseInt(process.env.FRAMEWORK_DETECTION_MAX_LIBRARIES || '5', 10),\r\n        aiTimeoutMs: parseInt(process.env.FRAMEWORK_DETECTION_AI_TIMEOUT || '5000', 10)\r\n      },\r\n      promptEnhancement: {\r\n        enabled: process.env.PROMPT_ENHANCEMENT_ENABLED === 'true',\r\n        defaultStrategy: (process.env.PROMPT_ENHANCEMENT_STRATEGY_TYPE as 'general' | 'framework-specific' | 'quality-focused' | 'project-aware') || 'general',\r\n        qualityThreshold: parseFloat(process.env.PROMPT_ENHANCEMENT_QUALITY_THRESHOLD || '0.8'),\r\n        maxTokens: parseInt(process.env.PROMPT_ENHANCEMENT_MAX_TOKENS || '2000', 10),\r\n        temperature: parseFloat(process.env.PROMPT_ENHANCEMENT_TEMPERATURE || '0.3'),\r\n        costLimit: parseFloat(process.env.PROMPT_ENHANCEMENT_COST_LIMIT || '10.0'),\r\n        rateLimit: parseInt(process.env.PROMPT_ENHANCEMENT_RATE_LIMIT || '100', 10),\r\n        fallbackEnabled: process.env.PROMPT_ENHANCEMENT_FALLBACK_ENABLED !== 'false',\r\n        optimization: {\r\n          tokenOptimization: {\r\n            contextTruncation: process.env.PROMPT_ENHANCEMENT_TOKEN_CONTEXT_TRUNCATION !== 'false',\r\n            smartSummarization: process.env.PROMPT_ENHANCEMENT_TOKEN_SMART_SUMMARIZATION !== 'false',\r\n            relevanceFiltering: process.env.PROMPT_ENHANCEMENT_TOKEN_RELEVANCE_FILTERING !== 'false',\r\n            priorityBasedSelection: process.env.PROMPT_ENHANCEMENT_TOKEN_PRIORITY_SELECTION !== 'false'\r\n          },\r\n          qualityOptimization: {\r\n            qualityScoring: process.env.PROMPT_ENHANCEMENT_QUALITY_SCORING !== 'false',\r\n            confidenceThresholds: process.env.PROMPT_ENHANCEMENT_QUALITY_CONFIDENCE_THRESHOLDS !== 'false',\r\n            validationChecks: process.env.PROMPT_ENHANCEMENT_QUALITY_VALIDATION_CHECKS !== 'false',\r\n            feedbackLoop: process.env.PROMPT_ENHANCEMENT_QUALITY_FEEDBACK_LOOP === 'true'\r\n          },\r\n          costOptimization: {\r\n            modelSelection: process.env.PROMPT_ENHANCEMENT_COST_MODEL_SELECTION !== 'false',\r\n            tokenBudgeting: process.env.PROMPT_ENHANCEMENT_COST_TOKEN_BUDGETING !== 'false',\r\n            cacheUtilization: process.env.PROMPT_ENHANCEMENT_COST_CACHE_UTILIZATION !== 'false',\r\n            batchProcessing: process.env.PROMPT_ENHANCEMENT_COST_BATCH_PROCESSING === 'true'\r\n          },\r\n          performanceOptimization: {\r\n            parallelProcessing: process.env.PROMPT_ENHANCEMENT_PERF_PARALLEL_PROCESSING !== 'false',\r\n            caching: process.env.PROMPT_ENHANCEMENT_PERF_CACHING !== 'false',\r\n            responseStreaming: process.env.PROMPT_ENHANCEMENT_PERF_RESPONSE_STREAMING === 'true',\r\n            loadBalancing: process.env.PROMPT_ENHANCEMENT_PERF_LOAD_BALANCING === 'true'\r\n          }\r\n        }\r\n      }\r\n    };\r\n\r\n    this.logger.info('Configuration loaded', {\r\n      server: config.server.name,\r\n      context7Enabled: config.context7.enabled,\r\n      databaseType: config.database.type,\r\n      logLevel: config.logging.level\r\n    });\r\n\r\n    return config;\r\n  }\r\n\r\n  private validateConfig(): void {\r\n    const errors: string[] = [];\r\n\r\n    // Validate server config\r\n    if (!this.config.server.name) {\r\n      errors.push('Server name is required');\r\n    }\r\n    if (this.config.server.port < 1 || this.config.server.port > 65535) {\r\n      errors.push('Server port must be between 1 and 65535');\r\n    }\r\n\r\n    // Validate Context7 config\r\n    if (this.config.context7.enabled && !this.config.context7.apiKey) {\r\n      errors.push('Context7 API key is required when Context7 is enabled');\r\n    }\r\n\r\n    // Validate database config\r\n    if (this.config.database.type === 'qdrant') {\r\n      if (!this.config.database.url) {\r\n        errors.push('Qdrant URL is required when using Qdrant database');\r\n      }\r\n    }\r\n\r\n    // Validate logging config\r\n    const validLogLevels = ['debug', 'info', 'warn', 'error'];\r\n    if (!validLogLevels.includes(this.config.logging.level)) {\r\n      errors.push(`Log level must be one of: ${validLogLevels.join(', ')}`);\r\n    }\r\n\r\n    // Validate tools config\r\n    if (this.config.tools.analyze.maxDepth < 1) {\r\n      errors.push('Analyze max depth must be at least 1');\r\n    }\r\n    if (this.config.tools.learn.maxLessons < 1) {\r\n      errors.push('Learn max lessons must be at least 1');\r\n    }\r\n\r\n    // Validate framework detection config\r\n    if (this.config.frameworkDetection.confidenceThreshold < 0 || this.config.frameworkDetection.confidenceThreshold > 1) {\r\n      errors.push('Framework detection confidence threshold must be between 0 and 1');\r\n    }\r\n    if (this.config.frameworkDetection.cacheTTL < 1) {\r\n      errors.push('Framework detection cache TTL must be at least 1 second');\r\n    }\r\n    if (this.config.frameworkDetection.maxLibrariesPerDetection < 1) {\r\n      errors.push('Framework detection max libraries must be at least 1');\r\n    }\r\n    if (this.config.frameworkDetection.aiTimeoutMs < 1000) {\r\n      errors.push('Framework detection AI timeout must be at least 1000ms');\r\n    }\r\n\r\n    // Validate prompt enhancement config\r\n    if (this.config.promptEnhancement.enabled) {\r\n      const validStrategies = ['general', 'framework-specific', 'quality-focused', 'project-aware'];\r\n      if (!validStrategies.includes(this.config.promptEnhancement.defaultStrategy)) {\r\n        errors.push(`Prompt enhancement default strategy must be one of: ${validStrategies.join(', ')}`);\r\n      }\r\n      if (this.config.promptEnhancement.qualityThreshold < 0 || this.config.promptEnhancement.qualityThreshold > 1) {\r\n        errors.push('Prompt enhancement quality threshold must be between 0 and 1');\r\n      }\r\n      if (this.config.promptEnhancement.maxTokens < 100 || this.config.promptEnhancement.maxTokens > 8000) {\r\n        errors.push('Prompt enhancement max tokens must be between 100 and 8000');\r\n      }\r\n      if (this.config.promptEnhancement.temperature < 0 || this.config.promptEnhancement.temperature > 2) {\r\n        errors.push('Prompt enhancement temperature must be between 0 and 2');\r\n      }\r\n      if (this.config.promptEnhancement.costLimit < 0) {\r\n        errors.push('Prompt enhancement cost limit must be non-negative');\r\n      }\r\n      if (this.config.promptEnhancement.rateLimit < 0) {\r\n        errors.push('Prompt enhancement rate limit must be non-negative');\r\n      }\r\n    }\r\n\r\n    if (errors.length > 0) {\r\n      this.logger.error('Configuration validation failed', { errors });\r\n      throw new Error(`Configuration validation failed: ${errors.join(', ')}`);\r\n    }\r\n\r\n    this.logger.info('Configuration validation passed');\r\n  }\r\n\r\n  // Helper methods for common config access patterns\r\n  isContext7Enabled(): boolean {\r\n    return this.config.context7.enabled;\r\n  }\r\n\r\n  isToolEnabled(tool: keyof PromptMCPConfig['tools']): boolean {\r\n    return this.config.tools[tool].enabled;\r\n  }\r\n\r\n  getLogLevel(): 'debug' | 'info' | 'warn' | 'error' {\r\n    return this.config.logging.level;\r\n  }\r\n\r\n  getDatabaseConfig() {\r\n    return this.config.database;\r\n  }\r\n\r\n  getContext7Config() {\r\n    return this.config.context7;\r\n  }\r\n\r\n  getFrameworkDetectionConfig() {\r\n    return this.config.frameworkDetection;\r\n  }\r\n\r\n  getPromptEnhancementConfig() {\r\n    return this.config.promptEnhancement;\r\n  }\r\n\r\n  isPromptEnhancementEnabled(): boolean {\r\n    return this.config.promptEnhancement.enabled;\r\n  }\r\n}",
        "File: src/mcp/server.ts\nDescription: Class definition: MCPServer\nCode:\nexport class MCPServer extends EventEmitter {\n  private tools: Map<string, MCPTool> = new Map();\n  public services: Map<string, any> = new Map();\n  private todoTool: TodoTool;\n  private healthTool?: HealthTool;\n  private context7ResolveTool?: Context7ResolveLibraryIdTool;\n  private context7DocsTool?: Context7GetLibraryDocsTool;\n  private dbPath: string;\n\n  constructor(services: Record<string, any>) {\n    super();\n    \n    // Store services\n    Object.entries(services).forEach(([name, service]) => {\n      this.services.set(name, service);\n    });\n    \n    // Initialize database path for later migration\n    this.dbPath = process.env.TODO_DB_PATH || 'todos.db';\n    \n    // Initialize todo service and tool with configurable database path\n    const todoService = new TodoService(this.dbPath);\n    this.todoTool = new TodoTool(todoService);\n    \n    // Initialize health tool\n    const logger = services.logger;\n    const config = services.config;\n    \n    if (logger && config) {\n      this.healthTool = new HealthTool(logger, config);\n      this.context7ResolveTool = new Context7ResolveLibraryIdTool(logger, config);\n      this.context7DocsTool = new Context7GetLibraryDocsTool(logger, config);\n    } else {\n      console.warn('âš ï¸ Health tool not initialized - missing required services');\n    }\n    \n    // Initialize tools\n    this.initializeTools();\n  }\n\n  /**\n   * Initialize the MCP server\n   */\n  async initialize(): Promise<void> {\n    console.log('ðŸ”Œ Initializing MCP server...');\n    \n    // Run database migrations\n    await this.runDatabaseMigrations();\n    \n    // Initialize health tool\n    if (this.healthTool) {\n      await this.healthTool.initialize();\n    }\n    \n    // Register tools\n    this.registerTools();\n    \n    console.log('âœ… MCP server initialized');\n  }\n\n\n  /**\n   * Run database migrations\n   */\n  private async runDatabaseMigrations(): Promise<void> {\n    try {\n      const db = new Database(this.dbPath);\n      const logger = this.services.get('logger');\n      \n      if (logger) {\n        const migrations = new DatabaseMigrationsService(logger, db);\n        await migrations.runMigrations();\n        console.log('âœ… Database migrations completed');\n      }\n    } catch (error) {\n      console.warn('âš ï¸ Database migrations failed:', (error as Error).message);\n    }\n  }\n\n  /**\n   * Start the MCP server\n   */\n  async start(): Promise<void> {\n    console.log('â–¶ï¸ Starting MCP server...');\n    \n    // Set up message handling\n    process.stdin.on('data', (data) => {\n      try {\n        const message = JSON.parse(data.toString());\n        this.handleMessage(message);\n      } catch (error) {\n        this.sendError('parse_error', 'Invalid JSON', null);\n      }\n    });\n    \n    console.log('âœ… MCP server started');\n  }\n\n  /**\n   * Initialize MCP tools\n   */\n  private initializeTools(): void {\n    // Get enhance tool schema from the service\n    const context7Integration = this.services.get('context7Integration');\n    const enhanceTool = context7Integration?.enhanceTool;\n    \n    if (enhanceTool && enhanceTool.getToolSchema) {\n      const enhanceSchema = enhanceTool.getToolSchema();\n      this.tools.set('promptmcp.enhance', {\n        name: enhanceSchema.name,\n        description: enhanceSchema.description,\n        inputSchema: enhanceSchema.inputSchema\n      });\n    } else {\n      // Fallback schema if enhance tool is not available\n      this.tools.set('promptmcp.enhance', {\n        name: 'promptmcp.enhance',\n        description: 'Enhance prompts with project context, best practices, and optionally break down complex requests into structured tasks',\n        inputSchema: {\n          type: 'object',\n          properties: {\n            prompt: {\n              type: 'string',\n              description: 'The prompt to enhance'\n            },\n            context: {\n              type: 'object',\n              properties: {\n                file: { type: 'string', description: 'Optional file path for context' },\n                framework: { type: 'string', description: 'Optional framework for context' },\n                style: { type: 'string', description: 'Optional style preference' },\n                projectContext: { type: 'object', description: 'Project-specific context' }\n              },\n              description: 'Additional context for enhancement'\n            },\n            options: {\n              type: 'object',\n              properties: {\n                useCache: { type: 'boolean', description: 'Whether to use cached results', default: true },\n                maxTokens: { type: 'number', description: 'Maximum tokens for Context7 documentation', default: 2000 },\n                includeMetadata: { type: 'boolean', description: 'Whether to include metadata in response', default: false },\n                includeBreakdown: { type: 'boolean', description: 'Whether to automatically break down complex prompts into tasks', default: false },\n                maxTasks: { type: 'number', description: 'Maximum number of tasks to create from breakdown', default: 10 }\n              },\n              description: 'Enhancement options'\n            }\n          },\n          required: ['prompt']\n        }\n      });\n    }\n\n    // promptmcp.todo tool\n    this.tools.set('promptmcp.todo', {\n      name: 'promptmcp.todo',\n      description: TodoToolSchema.description,\n      inputSchema: TodoToolSchema.inputSchema\n    });\n\n    // Note: breakdown functionality is now integrated into promptmcp.enhance\n\n    // promptmcp.health tool\n    this.tools.set('promptmcp.health', {\n      name: 'promptmcp.health',\n      description: 'Check the health status of the MCP server and all services',\n      inputSchema: {\n        type: 'object',\n        properties: {},\n        required: []\n      }\n    });\n\n    // Context7 tools are now internal only - not exposed as MCP tools\n    // They are used internally by the enhance tool via SimpleContext7Client\n  }\n\n  /**\n   * Register tools with MCP\n   */\n  private registerTools(): void {\n    console.log('ðŸ“ Registering MCP tools...');\n    \n    this.tools.forEach((tool, name) => {\n      console.log(`   - ${name}: ${tool.description}`);\n    });\n    \n    console.log('âœ… MCP tools registered');\n  }\n\n  /**\n   * Handle incoming MCP messages\n   */\n  private async handleMessage(message: MCPRequest): Promise<void> {\n    try {\n      switch (message.method) {\n        case 'initialize':\n          await this.handleInitialize(message);\n          break;\n        case 'tools/list':\n          await this.handleToolsList(message);\n          break;\n        case 'tools/call':\n          await this.handleToolCall(message);\n          break;\n        case 'ping':\n          await this.handlePing(message);\n          break;\n        default:\n          this.sendError('method_not_found', `Unknown method: ${message.method}`, message.id);\n      }\n    } catch (error) {\n      this.sendError('internal_error', (error as Error).message, message.id);\n    }\n  }\n\n  /**\n   * Handle initialize request\n   */\n  private async handleInitialize(message: MCPRequest): Promise<void> {\n    const response: MCPResponse = {\n      jsonrpc: '2.0',\n      id: message.id,\n      result: {\n        protocolVersion: '2024-11-05',\n        capabilities: {\n          tools: {}\n        },\n        serverInfo: {\n          name: 'PromptMCP',\n          version: '1.0.0',\n          description: 'Prompt enhancement tool for vibe coders'\n        }\n      }\n    };\n    \n    this.sendResponse(response);\n  }\n\n  /**\n   * Handle tools/list request\n   */\n  private async handleToolsList(message: MCPRequest): Promise<void> {\n    const tools = Array.from(this.tools.values());\n    \n    const response: MCPResponse = {\n      jsonrpc: '2.0',\n      id: message.id,\n      result: {\n        tools: tools\n      }\n    };\n    \n    this.sendResponse(response);\n  }\n\n  /**\n   * Handle tool call request\n   */\n  private async handleToolCall(message: MCPRequest): Promise<void> {\n    const { name, arguments: args } = message.params;\n    \n    if (!this.tools.has(name)) {\n      this.sendError('tool_not_found', `Tool not found: ${name}`, message.id);\n      return;\n    }\n    \n    try {\n      const result = await this.executeTool(name, args);\n      \n      const response: MCPResponse = {\n        jsonrpc: '2.0',\n        id: message.id,\n        result: {\n          content: [\n            {\n              type: 'text',\n              text: result\n            }\n          ]\n        }\n      };\n      \n      this.sendResponse(response);\n    } catch (error) {\n      this.sendError('tool_execution_error', (error as Error).message, message.id);\n    }\n  }\n\n  /**\n   * Handle ping request\n   */\n  private async handlePing(message: MCPRequest): Promise<void> {\n    const response: MCPResponse = {\n      jsonrpc: '2.0',\n      id: message.id,\n      result: {\n        pong: true,\n        timestamp: new Date().toISOString()\n      }\n    };\n    \n    this.sendResponse(response);\n  }\n\n  /**\n   * Execute a tool\n   */\n  private async executeTool(name: string, args: any): Promise<string> {\n    switch (name) {\n      case 'promptmcp.enhance':\n        return await this.executeEnhance(args);\n      case 'promptmcp.todo':\n        return await this.executeTodo(args);\n      case 'promptmcp.health':\n        return await this.executeHealth(args);\n      default:\n        throw new Error(`Unknown tool: ${name}`);\n    }\n  }\n\n  /**\n   * Execute a tool internally (for use by other services)\n   */\n  async executeToolInternal(name: string, args: any): Promise<any> {\n    try {\n      // Handle Context7 tools internally\n      if (name === 'resolve-library-id') {\n        const result = await this.executeResolveLibraryId(args);\n        return {\n          success: true,\n          result: result\n        };\n      } else if (name === 'get-library-docs') {\n        const result = await this.executeGetLibraryDocs(args);\n        return {\n          success: true,\n          result: result\n        };\n      } else {\n        // Handle other tools\n        const result = await this.executeTool(name, args);\n        return {\n          success: true,\n          result: result\n        };\n      }\n    } catch (error) {\n      return {\n        success: false,\n        error: error instanceof Error ? error.message : 'Unknown error'\n      };\n    }\n  }\n\n  /**\n   * Execute enhance tool\n   */\n  private async executeEnhance(args: any): Promise<string> {\n    const { prompt, context } = args;\n    \n    try {\n      console.log('ðŸ” [MCPServer] executeEnhance called with:', { prompt: prompt.substring(0, 100) + '...', context });\n      console.log('ðŸ” [MCPServer] Available services:', Array.from(this.services.keys()));\n      \n      // DEBUG: Print environment variables\n      console.log('ðŸ”‘ [MCPServer] Environment Debug:');\n      console.log('  OPENAI_API_KEY:', process.env.OPENAI_API_KEY ? `${process.env.OPENAI_API_KEY.substring(0, 20)}...` : 'NOT SET');\n      console.log('  OPENAI_PROJECT_ID:', process.env.OPENAI_PROJECT_ID || 'NOT SET');\n      console.log('  CONTEXT7_API_KEY:', process.env.CONTEXT7_API_KEY ? `${process.env.CONTEXT7_API_KEY.substring(0, 20)}...` : 'NOT SET');\n      console.log('  NODE_ENV:', process.env.NODE_ENV || 'NOT SET');\n      \n      // Get the Context7 integration service\n      const context7Integration = this.services.get('context7Integration');\n      \n      if (!context7Integration) {\n        console.log('âŒ [MCPServer] Context7 integration service not found in services map');\n        throw new Error('Context7 integration service not available');\n      }\n      \n      console.log('âœ… [MCPServer] Context7 integration service found');\n      \n      // DEBUG: Check if the service has the right configuration\n      if (context7Integration && typeof context7Integration === 'object') {\n        console.log('ðŸ” [MCPServer] Context7Integration service properties:', Object.keys(context7Integration));\n      }\n      \n      console.log('ðŸ” [MCPServer] Calling context7Integration.enhancePrompt...');\n      \n      // Call the Context7 integration service with the provided arguments\n      const result = await context7Integration.enhancePrompt(\n        prompt,\n        context || {},\n        {\n          maxTokens: 4000\n        }\n      );\n      \n      console.log('ðŸ” [MCPServer] context7Integration.enhancePrompt returned:', {\n        success: result.success,\n        repoFactsCount: result.context_used?.repo_facts?.length || 0,\n        codeSnippetsCount: result.context_used?.code_snippets?.length || 0,\n        context7DocsCount: result.context_used?.context7_docs?.length || 0\n      });\n      \n      return JSON.stringify(result, null, 2);\n      \n    } catch (error) {\n      console.log('âŒ [MCPServer] executeEnhance error:', error);\n      console.log('âŒ [MCPServer] Error stack:', (error as Error).stack);\n      throw new Error(`Enhance tool execution failed: ${(error as Error).message}`);\n    }\n  }\n\n\n  /**\n   * Execute todo tool\n   */\n  private async executeTodo(args: any): Promise<string> {\n    try {\n      // Execute todo tool\n      const result = await this.todoTool.execute(args);\n      \n      // Format response based on action\n      if (result.success) {\n        if (args.action === 'list' && Array.isArray(result.data)) {\n          // Format todo list as markdown for better display\n          const projectId = args.projectId || 'default-project';\n          return await this.todoTool.formatTodosAsMarkdown(projectId, args.filters);\n        } else if (args.action === 'create' && result.data) {\n          // Return success message for created todo\n          const todo = result.data as any;\n          return `âœ… Created todo: **${todo.title}**\\n\\nPriority: ${todo.priority}\\nCategory: ${todo.category || 'none'}\\nStatus: ${todo.status}`;\n        } else {\n          // Return JSON for other operations\n          return JSON.stringify(result.data, null, 2);\n        }\n      } else {\n        throw new Error(result.error || 'Todo operation failed');\n      }\n      \n    } catch (error) {\n      throw new Error(`Todo tool execution failed: ${(error as Error).message}`);\n    }\n  }\n\n  /**\n   * Execute health tool\n   */\n  private async executeHealth(args: any): Promise<string> {\n    if (!this.healthTool) {\n      throw new Error('Health tool not available');\n    }\n    \n    try {\n      const healthResult = await this.healthTool.performHealthCheck();\n      return JSON.stringify(healthResult, null, 2);\n    } catch (error) {\n      throw new Error(`Health tool execution failed: ${(error as Error).message}`);\n    }\n  }\n\n  /**\n   * Execute resolve-library-id tool\n   */\n  private async executeResolveLibraryId(args: any): Promise<any> {\n    if (!this.context7ResolveTool) {\n      throw new Error('Context7 resolve library tool not available');\n    }\n    \n    try {\n      const result = await this.context7ResolveTool.resolveLibraryId(args);\n      // Return the result directly, not as JSON string\n      return result;\n    } catch (error) {\n      throw new Error(`Context7 resolve library tool execution failed: ${(error as Error).message}`);\n    }\n  }\n\n  /**\n   * Execute get-library-docs tool\n   */\n  private async executeGetLibraryDocs(args: any): Promise<any> {\n    if (!this.context7DocsTool) {\n      throw new Error('Context7 get library docs tool not available');\n    }\n    \n    try {\n      const result = await this.context7DocsTool.getLibraryDocs(args);\n      // Return the result directly, not as JSON string\n      return result;\n    } catch (error) {\n      throw new Error(`Context7 get library docs tool execution failed: ${(error as Error).message}`);\n    }\n  }\n\n  /**\n   * Send response\n   */\n  private sendResponse(response: MCPResponse): void {\n    console.log(JSON.stringify(response));\n  }\n\n  /**\n   * Send error response\n   */\n  private sendError(code: string, message: string, id: string | number | null): void {\n    const response: MCPResponse = {\n      jsonrpc: '2.0',\n      id: id || 'unknown',\n      error: {\n        code: -1,\n        message: message,\n        data: { code }\n      }\n    };\n    \n    this.sendResponse(response);\n  }\n\n  /**\n   * Handle HTTP MCP request\n   */\n  async handleRequest(mcpRequest: MCPRequest): Promise<MCPResponse> {\n    try {\n      // Handle the message directly and return the response\n      return await this.handleMessageDirect(mcpRequest);\n    } catch (error) {\n      return {\n        jsonrpc: '2.0',\n        id: mcpRequest.id,\n        error: {\n          code: -32603,\n          message: 'Internal error',\n          data: error instanceof Error ? error.message : 'Unknown error'\n        }\n      };\n    }\n  }\n\n  /**\n   * Handle MCP message directly and return response\n   */\n  private async handleMessageDirect(message: MCPRequest): Promise<MCPResponse> {\n    const { method, params, id } = message;\n\n    switch (method) {\n      case 'tools/list':\n        return {\n          jsonrpc: '2.0',\n          id,\n          result: {\n            tools: Array.from(this.tools.values())\n          }\n        };\n\n      case 'tools/call':\n        try {\n          const { name, arguments: args } = params;\n          const result = await this.executeTool(name, args);\n          return {\n            jsonrpc: '2.0',\n            id,\n            result: result\n          };\n        } catch (error) {\n          return {\n            jsonrpc: '2.0',\n            id,\n            error: {\n              code: -32603,\n              message: error instanceof Error ? error.message : 'Tool execution failed',\n              data: { tool: params?.name }\n            }\n          };\n        }\n\n      case 'ping':\n        return {\n          jsonrpc: '2.0',\n          id,\n          result: { status: 'pong' }\n        };\n\n      default:\n        return {\n          jsonrpc: '2.0',\n          id,\n          error: {\n            code: -32601,\n            message: `Method not found: ${method}`,\n            data: { method }\n          }\n        };\n    }\n  }\n\n  /**\n   * Get available tools\n   */\n  getTools(): Map<string, MCPTool> {\n    return this.tools;\n  }\n\n  /**\n   * Destroy the MCP server\n   */\n  destroy(): void {\n    // Close todo service\n    if (this.todoTool) {\n      // Access the todo service through the tool\n      (this.todoTool as any).todoService?.close();\n    }\n    \n    // Clean up health tool\n    if (this.healthTool) {\n      this.healthTool.destroy();\n    }\n    \n    this.removeAllListeners();\n    console.log('ðŸ”Œ MCP server destroyed');\n  }\n}",
        "File: src/services/ai/openai.service.ts\nDescription: Class definition: OpenAIService\nCode:\nexport class OpenAIService {\r\n  private client: OpenAI;\r\n  private logger: Logger;\r\n  private config: OpenAIConfig;\r\n  private costData: OpenAICostData[] = [];\r\n  private usageStats: OpenAIUsageStats = {\r\n    totalRequests: 0,\r\n    totalTokens: 0,\r\n    totalCost: 0,\r\n    averageCostPerRequest: 0,\r\n    averageTokensPerRequest: 0,\r\n    costByModel: {},\r\n    requestsByModel: {}\r\n  };\r\n\r\n  // OpenAI pricing per 1K tokens (as of 2024)\r\n  private readonly PRICING = {\r\n    'gpt-4': { input: 0.03, output: 0.06 },\r\n    'gpt-4-turbo': { input: 0.01, output: 0.03 },\r\n    'gpt-3.5-turbo': { input: 0.0015, output: 0.002 },\r\n    'gpt-3.5-turbo-16k': { input: 0.003, output: 0.004 }\r\n  };\r\n\r\n  constructor(logger: Logger, config: OpenAIConfig) {\r\n    this.logger = logger;\r\n    this.config = config;\r\n    \r\n    // DEBUG: Print API key and project ID being used\r\n    console.log('ðŸ”‘ OpenAI Service Debug:');\r\n    console.log('  API Key:', config.apiKey ? `${config.apiKey.substring(0, 20)}...` : 'NOT SET');\r\n    console.log('  Project ID:', config.projectId || 'NOT SET');\r\n    console.log('  Full API Key Length:', config.apiKey?.length || 0);\r\n    \r\n    this.client = new OpenAI({ \r\n      apiKey: config.apiKey,\r\n      project: config.projectId\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Break down a user prompt into structured tasks using OpenAI\r\n   */\r\n  async breakdownPrompt(prompt: string, context: string): Promise<TaskBreakdown> {\r\n    try {\r\n      this.logger.debug('Starting OpenAI task breakdown', { \r\n        prompt: prompt.substring(0, 100) + '...',\r\n        contextLength: context.length \r\n      });\r\n\r\n      const response = await this.client.chat.completions.create({\r\n        model: this.config.model || 'gpt-4',\r\n        messages: [\r\n          {\r\n            role: 'system',\r\n            content: `You are a task breakdown expert. Break down user requests into structured tasks using the provided documentation context.\r\n\r\nYour job is to:\r\n1. Analyze the user's request\r\n2. Use the provided documentation to understand best practices\r\n3. Break down the request into logical, manageable tasks\r\n4. Identify subtasks for complex tasks\r\n5. Determine task dependencies\r\n6. Assign appropriate priorities and categories\r\n7. Provide realistic time estimates\r\n\r\nReturn ONLY valid JSON with this exact structure:\r\n{\r\n  \"mainTasks\": [\r\n    {\r\n      \"title\": \"Task title\",\r\n      \"description\": \"Detailed description of what needs to be done\",\r\n      \"priority\": \"high|medium|low|critical\",\r\n      \"category\": \"feature|bug|refactor|testing|documentation|deployment|maintenance|setup|configuration|infrastructure|design|planning|research\",\r\n      \"estimatedHours\": 2.5\r\n    }\r\n  ],\r\n  \"subtasks\": [\r\n    {\r\n      \"parentTaskTitle\": \"Task title\",\r\n      \"title\": \"Subtask title\",\r\n      \"description\": \"Subtask description\",\r\n      \"estimatedHours\": 1.0\r\n    }\r\n  ],\r\n  \"dependencies\": [\r\n    {\r\n      \"taskTitle\": \"Task that depends on another\",\r\n      \"dependsOnTaskTitle\": \"Task it depends on\"\r\n    }\r\n  ]\r\n}\r\n\r\nGuidelines:\r\n- Break down complex tasks into 3-7 main tasks\r\n- Each main task should have 2-5 subtasks if needed\r\n- Use realistic time estimates (0.5 to 8 hours per task)\r\n- Assign priorities based on importance and urgency\r\n- Identify clear dependencies between tasks\r\n- Use the documentation context to ensure accuracy\r\n- Focus on actionable, specific tasks`\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `User Request: ${prompt}\r\n\r\nRelevant Documentation:\r\n${context}\r\n\r\nPlease break this down into structured tasks.`\r\n          }\r\n        ],\r\n        temperature: this.config.temperature || 0.3,\r\n        max_tokens: this.config.maxTokens || 2000\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) {\r\n        throw new Error('No response content from OpenAI');\r\n      }\r\n\r\n      this.logger.debug('OpenAI response received', { \r\n        responseLength: content.length,\r\n        usage: response.usage \r\n      });\r\n\r\n      // Track cost and usage\r\n      if (response.usage) {\r\n        this.trackUsage(response.usage, this.config.model || 'gpt-4');\r\n      }\r\n\r\n      // Parse and validate the JSON response\r\n      const breakdown = this.parseAndValidateBreakdown(content);\r\n      \r\n      this.logger.info('Task breakdown completed successfully', {\r\n        mainTasks: breakdown.mainTasks.length,\r\n        subtasks: breakdown.subtasks.length,\r\n        dependencies: breakdown.dependencies.length\r\n      });\r\n\r\n      return breakdown;\r\n\r\n    } catch (error) {\r\n      // Enhanced error handling with specific API key error detection\r\n      if (error instanceof Error && error.message.includes('401')) {\r\n        this.logger.error('OpenAI API key invalid or expired', {\r\n          error: 'API key authentication failed',\r\n          suggestion: 'Please update OPENAI_API_KEY environment variable',\r\n          prompt: prompt.substring(0, 100) + '...'\r\n        });\r\n        throw new Error('OpenAI API key is invalid or expired. Please check your OPENAI_API_KEY environment variable.');\r\n      } else if (error instanceof Error && error.message.includes('429')) {\r\n        this.logger.error('OpenAI API rate limit exceeded', {\r\n          error: 'Rate limit exceeded',\r\n          suggestion: 'Please wait before retrying or upgrade your OpenAI plan',\r\n          prompt: prompt.substring(0, 100) + '...'\r\n        });\r\n        throw new Error('OpenAI API rate limit exceeded. Please wait before retrying.');\r\n      } else if (error instanceof Error && error.message.includes('403')) {\r\n        this.logger.error('OpenAI API access forbidden', {\r\n          error: 'API access forbidden',\r\n          suggestion: 'Please check your OpenAI API key permissions',\r\n          prompt: prompt.substring(0, 100) + '...'\r\n        });\r\n        throw new Error('OpenAI API access forbidden. Please check your API key permissions.');\r\n      } else {\r\n        this.logger.error('OpenAI task breakdown failed', {\r\n          error: error instanceof Error ? error.message : 'Unknown error',\r\n          prompt: prompt.substring(0, 100) + '...'\r\n        });\r\n        throw new Error(`Task breakdown failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse and validate the JSON response from OpenAI\r\n   */\r\n  private parseAndValidateBreakdown(content: string): TaskBreakdown {\r\n    try {\r\n      // Clean the content - remove any markdown formatting\r\n      let cleanContent = content.trim();\r\n      if (cleanContent.startsWith('```json')) {\r\n        cleanContent = cleanContent.replace(/^```json\\s*/, '').replace(/\\s*```$/, '');\r\n      } else if (cleanContent.startsWith('```')) {\r\n        cleanContent = cleanContent.replace(/^```\\s*/, '').replace(/\\s*```$/, '');\r\n      }\r\n\r\n      const parsed = JSON.parse(cleanContent);\r\n\r\n      // Validate the structure\r\n      if (!parsed.mainTasks || !Array.isArray(parsed.mainTasks)) {\r\n        throw new Error('Invalid response: mainTasks is required and must be an array');\r\n      }\r\n\r\n      if (!parsed.subtasks || !Array.isArray(parsed.subtasks)) {\r\n        throw new Error('Invalid response: subtasks is required and must be an array');\r\n      }\r\n\r\n      if (!parsed.dependencies || !Array.isArray(parsed.dependencies)) {\r\n        throw new Error('Invalid response: dependencies is required and must be an array');\r\n      }\r\n\r\n      // Validate main tasks\r\n      for (const task of parsed.mainTasks) {\r\n        if (!task.title || !task.description) {\r\n          throw new Error('Invalid main task: title and description are required');\r\n        }\r\n        if (!['low', 'medium', 'high', 'critical'].includes(task.priority)) {\r\n          throw new Error(`Invalid priority: ${task.priority}`);\r\n        }\r\n        if (!['feature', 'bug', 'refactor', 'testing', 'documentation', 'deployment', 'maintenance', 'setup', 'configuration', 'infrastructure', 'design', 'planning', 'research'].includes(task.category)) {\r\n          throw new Error(`Invalid category: ${task.category}`);\r\n        }\r\n        if (typeof task.estimatedHours !== 'number' || task.estimatedHours <= 0) {\r\n          throw new Error(`Invalid estimated hours: ${task.estimatedHours}`);\r\n        }\r\n      }\r\n\r\n      // Validate subtasks\r\n      for (const subtask of parsed.subtasks) {\r\n        if (!subtask.parentTaskTitle || !subtask.title || !subtask.description) {\r\n          throw new Error('Invalid subtask: parentTaskTitle, title, and description are required');\r\n        }\r\n        if (typeof subtask.estimatedHours !== 'number' || subtask.estimatedHours <= 0) {\r\n          throw new Error(`Invalid subtask estimated hours: ${subtask.estimatedHours}`);\r\n        }\r\n      }\r\n\r\n      // Validate dependencies\r\n      for (const dep of parsed.dependencies) {\r\n        if (!dep.taskTitle || !dep.dependsOnTaskTitle) {\r\n          throw new Error('Invalid dependency: taskTitle and dependsOnTaskTitle are required');\r\n        }\r\n      }\r\n\r\n      return parsed as TaskBreakdown;\r\n\r\n    } catch (error) {\r\n      this.logger.error('Failed to parse OpenAI response', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        content: content.substring(0, 200) + '...'\r\n      });\r\n      throw new Error(`Failed to parse task breakdown: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Create a chat completion with custom messages\r\n   */\r\n  async createChatCompletion(messages: any[], options?: {\r\n    model?: string;\r\n    maxTokens?: number;\r\n    temperature?: number;\r\n  }): Promise<any> {\r\n    try {\r\n      // DEBUG: Print API key and project ID before each API call\r\n      console.log('ðŸ”‘ OpenAI API Call Debug:');\r\n      console.log('  API Key:', this.config.apiKey ? `${this.config.apiKey.substring(0, 20)}...` : 'NOT SET');\r\n      console.log('  Project ID:', this.config.projectId || 'NOT SET');\r\n      console.log('  Model:', options?.model || this.config.model || 'gpt-4');\r\n      console.log('  Full API Key Length:', this.config.apiKey?.length || 0);\r\n      \r\n      const response = await this.client.chat.completions.create({\r\n        model: options?.model || this.config.model || 'gpt-4',\r\n        messages,\r\n        max_tokens: options?.maxTokens || this.config.maxTokens || 2000,\r\n        temperature: options?.temperature || this.config.temperature || 0.3\r\n      });\r\n\r\n      return response;\r\n    } catch (error) {\r\n      this.logger.error('OpenAI chat completion failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        model: options?.model || this.config.model\r\n      });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Test the OpenAI connection\r\n   */\r\n  async testConnection(): Promise<boolean> {\r\n    try {\r\n      const response = await this.client.chat.completions.create({\r\n        model: this.config.model || 'gpt-4',\r\n        messages: [\r\n          { role: 'user', content: 'Hello, this is a test message.' }\r\n        ],\r\n        max_tokens: 10\r\n      });\r\n\r\n      return response.choices[0]?.message?.content !== undefined;\r\n    } catch (error) {\r\n      this.logger.error('OpenAI connection test failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error'\r\n      });\r\n      return false;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Track usage and calculate costs for OpenAI API calls\r\n   */\r\n  private trackUsage(usage: any, model: string): void {\r\n    const promptTokens = usage.prompt_tokens || 0;\r\n    const completionTokens = usage.completion_tokens || 0;\r\n    const totalTokens = usage.total_tokens || 0;\r\n    \r\n    const cost = this.calculateCost(promptTokens, completionTokens, model);\r\n    \r\n    const costData: OpenAICostData = {\r\n      promptTokens,\r\n      completionTokens,\r\n      totalTokens,\r\n      cost,\r\n      model,\r\n      timestamp: new Date()\r\n    };\r\n\r\n    this.costData.push(costData);\r\n    this.updateUsageStats(costData);\r\n    \r\n    this.logger.debug('OpenAI usage tracked', {\r\n      model,\r\n      promptTokens,\r\n      completionTokens,\r\n      totalTokens,\r\n      cost: cost.toFixed(4)\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Calculate cost based on token usage and model\r\n   */\r\n  private calculateCost(promptTokens: number, completionTokens: number, model: string): number {\r\n    const pricing = this.PRICING[model as keyof typeof this.PRICING] || this.PRICING['gpt-4'];\r\n    \r\n    const inputCost = (promptTokens / 1000) * pricing.input;\r\n    const outputCost = (completionTokens / 1000) * pricing.output;\r\n    \r\n    return inputCost + outputCost;\r\n  }\r\n\r\n  /**\r\n   * Update usage statistics\r\n   */\r\n  private updateUsageStats(costData: OpenAICostData): void {\r\n    this.usageStats.totalRequests++;\r\n    this.usageStats.totalTokens += costData.totalTokens;\r\n    this.usageStats.totalCost += costData.cost;\r\n    \r\n    // Update model-specific stats\r\n    if (!this.usageStats.costByModel[costData.model]) {\r\n      this.usageStats.costByModel[costData.model] = 0;\r\n      this.usageStats.requestsByModel[costData.model] = 0;\r\n    }\r\n    \r\n    this.usageStats.costByModel[costData.model] = (this.usageStats.costByModel[costData.model] || 0) + costData.cost;\r\n    this.usageStats.requestsByModel[costData.model] = (this.usageStats.requestsByModel[costData.model] || 0) + 1;\r\n    \r\n    // Update averages\r\n    this.usageStats.averageCostPerRequest = this.usageStats.totalCost / this.usageStats.totalRequests;\r\n    this.usageStats.averageTokensPerRequest = this.usageStats.totalTokens / this.usageStats.totalRequests;\r\n  }\r\n\r\n  /**\r\n   * Get current usage statistics\r\n   */\r\n  getUsageStats(): OpenAIUsageStats {\r\n    return { ...this.usageStats };\r\n  }\r\n\r\n  /**\r\n   * Get cost data for a specific time range\r\n   */\r\n  getCostData(startDate?: Date, endDate?: Date): OpenAICostData[] {\r\n    if (!startDate && !endDate) {\r\n      return [...this.costData];\r\n    }\r\n    \r\n    return this.costData.filter(data => {\r\n      if (startDate && data.timestamp < startDate) return false;\r\n      if (endDate && data.timestamp > endDate) return false;\r\n      return true;\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Get total cost for a specific time range\r\n   */\r\n  getTotalCost(startDate?: Date, endDate?: Date): number {\r\n    const filteredData = this.getCostData(startDate, endDate);\r\n    return filteredData.reduce((total, data) => total + data.cost, 0);\r\n  }\r\n\r\n  /**\r\n   * Reset usage statistics\r\n   */\r\n  resetUsageStats(): void {\r\n    this.costData = [];\r\n    this.usageStats = {\r\n      totalRequests: 0,\r\n      totalTokens: 0,\r\n      totalCost: 0,\r\n      averageCostPerRequest: 0,\r\n      averageTokensPerRequest: 0,\r\n      costByModel: {},\r\n      requestsByModel: {}\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Enhance a prompt with context using OpenAI\r\n   */\r\n  async enhancePromptWithContext(request: PromptEnhancementRequest): Promise<PromptEnhancementResponse> {\r\n    try {\r\n      this.logger.debug('Starting OpenAI prompt enhancement', {\r\n        originalPrompt: request.originalPrompt.substring(0, 100) + '...',\r\n        strategy: request.options.strategy.type,\r\n        contextSize: JSON.stringify(request.context).length\r\n      });\r\n\r\n      // Get the appropriate enhancement prompt\r\n      const enhancementPrompt = PromptEnhancementPrompts.getContextualEnhancementPrompt(\r\n        request.originalPrompt,\r\n        request.context,\r\n        request.options.strategy\r\n      );\r\n\r\n      const response = await this.client.chat.completions.create({\r\n        model: this.config.model || 'gpt-4',\r\n        messages: [\r\n          {\r\n            role: 'system',\r\n            content: enhancementPrompt\r\n          },\r\n          {\r\n            role: 'user',\r\n            content: `Please enhance this prompt with the provided context:\r\n\r\nOriginal Prompt: ${request.originalPrompt}\r\n\r\nContext: ${JSON.stringify(request.context, null, 2)}\r\n\r\nEnhancement Options: ${JSON.stringify(request.options, null, 2)}\r\n\r\nGoals: ${JSON.stringify(request.goals, null, 2)}`\r\n          }\r\n        ],\r\n        temperature: request.options.temperature || this.config.temperature || 0.3,\r\n        max_tokens: request.options.maxTokens || this.config.maxTokens || 2000\r\n      });\r\n\r\n      const content = response.choices[0]?.message?.content;\r\n      if (!content) {\r\n        throw new Error('No response content from OpenAI');\r\n      }\r\n\r\n      this.logger.debug('OpenAI enhancement response received', {\r\n        responseLength: content.length,\r\n        usage: response.usage\r\n      });\r\n\r\n      // Track cost and usage\r\n      if (response.usage) {\r\n        this.trackUsage(response.usage, this.config.model || 'gpt-4');\r\n      }\r\n\r\n      // Parse and validate the enhancement response\r\n      const enhancement = this.parseAndValidateEnhancement(content, request);\r\n      \r\n      this.logger.info('Prompt enhancement completed successfully', {\r\n        originalLength: request.originalPrompt.length,\r\n        enhancedLength: enhancement.enhancedPrompt.length,\r\n        qualityScore: enhancement.quality.overall,\r\n        confidenceScore: enhancement.confidence.overall\r\n      });\r\n\r\n      return enhancement;\r\n\r\n    } catch (error) {\r\n      this.logger.error('OpenAI prompt enhancement failed', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        originalPrompt: request.originalPrompt.substring(0, 100) + '...'\r\n      });\r\n      throw new Error(`Prompt enhancement failed: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse and validate the enhancement response from OpenAI\r\n   */\r\n  private parseAndValidateEnhancement(content: string, request: PromptEnhancementRequest): PromptEnhancementResponse {\r\n    try {\r\n      // Clean the content - remove any markdown formatting\r\n      let cleanContent = content.trim();\r\n      if (cleanContent.startsWith('```json')) {\r\n        cleanContent = cleanContent.replace(/^```json\\s*/, '').replace(/\\s*```$/, '');\r\n      } else if (cleanContent.startsWith('```')) {\r\n        cleanContent = cleanContent.replace(/^```\\s*/, '').replace(/\\s*```$/, '');\r\n      }\r\n\r\n      const parsed = JSON.parse(cleanContent);\r\n\r\n      // Validate the structure\r\n      if (!parsed.enhancedPrompt || typeof parsed.enhancedPrompt !== 'string') {\r\n        throw new Error('Invalid response: enhancedPrompt is required and must be a string');\r\n      }\r\n\r\n      if (!parsed.improvements || !Array.isArray(parsed.improvements)) {\r\n        throw new Error('Invalid response: improvements is required and must be an array');\r\n      }\r\n\r\n      if (!parsed.recommendations || !Array.isArray(parsed.recommendations)) {\r\n        throw new Error('Invalid response: recommendations is required and must be an array');\r\n      }\r\n\r\n      // Validate improvements\r\n      for (const improvement of parsed.improvements) {\r\n        if (!improvement.type || !improvement.description) {\r\n          throw new Error('Invalid improvement: type and description are required');\r\n        }\r\n        if (!['clarity', 'specificity', 'actionability', 'completeness', 'relevance', 'best-practice', 'performance', 'security'].includes(improvement.type)) {\r\n          throw new Error(`Invalid improvement type: ${improvement.type}`);\r\n        }\r\n        if (!['low', 'medium', 'high'].includes(improvement.impact)) {\r\n          throw new Error(`Invalid improvement impact: ${improvement.impact}`);\r\n        }\r\n      }\r\n\r\n      // Create the enhancement response\r\n      const enhancement: PromptEnhancementResponse = {\r\n        enhancedPrompt: parsed.enhancedPrompt,\r\n        metadata: {\r\n          originalLength: request.originalPrompt.length,\r\n          enhancedLength: parsed.enhancedPrompt.length,\r\n          tokenUsage: {\r\n            promptTokens: 0, // Will be filled by trackUsage\r\n            completionTokens: 0,\r\n            totalTokens: 0,\r\n            cost: 0,\r\n            model: this.config.model || 'gpt-4'\r\n          },\r\n          processingTime: 0, // Will be filled by the caller\r\n          strategy: request.options.strategy,\r\n          framework: request.context.frameworkContext?.framework || 'Unknown',\r\n          projectType: request.context.projectContext?.projectType || 'Unknown',\r\n          timestamp: new Date()\r\n        },\r\n        quality: {\r\n          clarity: parsed.qualityScore || 0.8,\r\n          specificity: parsed.qualityScore || 0.8,\r\n          actionability: parsed.qualityScore || 0.8,\r\n          completeness: parsed.qualityScore || 0.8,\r\n          relevance: parsed.qualityScore || 0.8,\r\n          overall: parsed.qualityScore || 0.8\r\n        },\r\n        confidence: {\r\n          overall: parsed.confidenceScore || 0.8,\r\n          contextRelevance: parsed.confidenceScore || 0.8,\r\n          frameworkAccuracy: parsed.confidenceScore || 0.8,\r\n          qualityAlignment: parsed.confidenceScore || 0.8,\r\n          projectFit: parsed.confidenceScore || 0.8\r\n        },\r\n        improvements: parsed.improvements.map((imp: any) => ({\r\n          type: imp.type,\r\n          description: imp.description,\r\n          impact: imp.impact,\r\n          before: imp.before || '',\r\n          after: imp.after || ''\r\n        })),\r\n        recommendations: parsed.recommendations\r\n      };\r\n\r\n      return enhancement;\r\n\r\n    } catch (error) {\r\n      this.logger.error('Failed to parse OpenAI enhancement response', {\r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        content: content.substring(0, 200) + '...'\r\n      });\r\n      throw new Error(`Failed to parse enhancement response: ${error instanceof Error ? error.message : 'Unknown error'}`);\r\n    }\r\n  }\r\n}\r",
        "File: src/services/ai/summarization/openai-summarization.service.ts\nDescription: Class definition: OpenAISummarizationService\nCode:\nexport class OpenAISummarizationService {\r\n  private client: OpenAI;\r\n  private config: SummarizationConfig;\r\n  private logger: Logger;\r\n  private metrics: SummarizationMetrics;\r\n\r\n  constructor(apiKey: string, config?: Partial<SummarizationConfig>, logger?: Logger) {\r\n    this.logger = logger || new Logger('OpenAISummarizationService');\r\n    this.config = { ...DEFAULT_SUMMARIZATION_CONFIG, ...config };\r\n    this.metrics = {\r\n      totalRequests: 0,\r\n      successfulRequests: 0,\r\n      failedRequests: 0,\r\n      averageQualityScore: 0,\r\n      averageTokenReduction: 0,\r\n      averageProcessingTime: 0,\r\n      totalCost: 0,\r\n      lastUpdated: new Date()\r\n    };\r\n\r\n    try {\r\n      this.client = new OpenAI({\r\n        apiKey,\r\n        timeout: this.config.timeout,\r\n        maxRetries: this.config.retryAttempts\r\n      });\r\n      this.logger.info('OpenAI summarization service initialized', { model: this.config.model });\r\n    } catch (error) {\r\n      this.logger.error('Failed to initialize OpenAI summarization service', { error });\r\n      throw error;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Summarize context using AI\r\n   */\r\n  async summarizeContext(request: SummarizationRequest): Promise<SummarizationResponse> {\r\n    const startTime = Date.now();\r\n    this.metrics.totalRequests++;\r\n\r\n    try {\r\n      this.logger.debug('Starting context summarization', {\r\n        frameworks: request.frameworks,\r\n        projectType: request.projectType,\r\n        originalTokenCount: this.calculateTokenCount([\r\n          ...request.repoFacts,\r\n          ...request.context7Docs,\r\n          ...request.codeSnippets\r\n        ])\r\n      });\r\n\r\n      // Summarize each context type in parallel\r\n      const [summarizedRepoFacts, summarizedContext7Docs, summarizedCodeSnippets] = await Promise.all([\r\n        this.summarizeRepoFacts(request.repoFacts),\r\n        this.summarizeContext7Docs(request.context7Docs),\r\n        this.summarizeCodeSnippets(request.codeSnippets)\r\n      ]);\r\n\r\n      const processingTime = Date.now() - startTime;\r\n      const originalTokenCount = this.calculateTokenCount([\r\n        ...request.repoFacts,\r\n        ...request.context7Docs,\r\n        ...request.codeSnippets\r\n      ]);\r\n      const summarizedTokenCount = this.calculateTokenCount([\r\n        ...summarizedRepoFacts,\r\n        ...summarizedContext7Docs,\r\n        ...summarizedCodeSnippets\r\n      ]);\r\n\r\n      // Calculate quality score\r\n      const qualityScore = await this.calculateQualityScore(\r\n        [request.repoFacts, request.context7Docs, request.codeSnippets],\r\n        [summarizedRepoFacts, summarizedContext7Docs, summarizedCodeSnippets]\r\n      );\r\n\r\n      // Calculate cost (rough estimate)\r\n      const cost = this.estimateCost(originalTokenCount, summarizedTokenCount);\r\n\r\n      const response: SummarizationResponse = {\r\n        summarizedRepoFacts,\r\n        summarizedContext7Docs,\r\n        summarizedCodeSnippets,\r\n        originalTokenCount,\r\n        summarizedTokenCount,\r\n        qualityScore,\r\n        processingTime,\r\n        cost\r\n      };\r\n\r\n      this.updateMetrics(true, qualityScore, originalTokenCount, summarizedTokenCount, processingTime, cost);\r\n      \r\n      this.logger.info('Context summarization completed', {\r\n        originalTokenCount,\r\n        summarizedTokenCount,\r\n        tokenReduction: ((originalTokenCount - summarizedTokenCount) / originalTokenCount * 100).toFixed(1) + '%',\r\n        qualityScore: qualityScore.toFixed(2),\r\n        processingTime: processingTime + 'ms'\r\n      });\r\n\r\n      return response;\r\n    } catch (error) {\r\n      this.updateMetrics(false, 0, 0, 0, Date.now() - startTime, 0);\r\n      this.logger.error('Context summarization failed', { error, request });\r\n      throw this.createSummarizationError(error);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Summarize repository facts\r\n   */\r\n  async summarizeRepoFacts(facts: string[]): Promise<string[]> {\r\n    if (facts.length === 0) return [];\r\n\r\n    const prompt = formatPrompt(SUMMARIZATION_PROMPTS.repoFacts, {\r\n      content: facts.join('\\n')\r\n    });\r\n\r\n    const response = await this.callOpenAI(prompt);\r\n    return this.parseSummarizedContent(response, 'repoFacts');\r\n  }\r\n\r\n  /**\r\n   * Summarize Context7 documentation\r\n   */\r\n  async summarizeContext7Docs(docs: string[]): Promise<string[]> {\r\n    if (docs.length === 0) return [];\r\n\r\n    const prompt = formatPrompt(SUMMARIZATION_PROMPTS.context7Docs, {\r\n      content: docs.join('\\n')\r\n    });\r\n\r\n    const response = await this.callOpenAI(prompt);\r\n    return this.parseSummarizedContent(response, 'context7Docs');\r\n  }\r\n\r\n  /**\r\n   * Summarize code snippets\r\n   */\r\n  async summarizeCodeSnippets(snippets: string[]): Promise<string[]> {\r\n    if (snippets.length === 0) return [];\r\n\r\n    const prompt = formatPrompt(SUMMARIZATION_PROMPTS.codeSnippets, {\r\n      content: snippets.join('\\n')\r\n    });\r\n\r\n    const response = await this.callOpenAI(prompt);\r\n    return this.parseSummarizedContent(response, 'codeSnippets');\r\n  }\r\n\r\n  /**\r\n   * Call OpenAI API with retry logic\r\n   */\r\n  private async callOpenAI(prompt: string): Promise<string> {\r\n    let lastError: any;\r\n    \r\n    for (let attempt = 1; attempt <= this.config.retryAttempts; attempt++) {\r\n      try {\r\n        const response = await this.client.chat.completions.create({\r\n          model: this.config.model,\r\n          messages: [\r\n            {\r\n              role: 'system',\r\n              content: 'You are an expert software architect and developer with deep knowledge of modern web development frameworks and best practices.'\r\n            },\r\n            {\r\n              role: 'user',\r\n              content: prompt\r\n            }\r\n          ],\r\n          max_tokens: this.config.maxTokens,\r\n          temperature: this.config.temperature\r\n        });\r\n\r\n        const content = response.choices[0]?.message?.content;\r\n        if (!content) {\r\n          throw new Error('Empty response from OpenAI');\r\n        }\r\n\r\n        return content.trim();\r\n      } catch (error) {\r\n        lastError = error;\r\n        this.logger.warn(`OpenAI API call failed (attempt ${attempt}/${this.config.retryAttempts})`, { error });\r\n        \r\n        if (attempt < this.config.retryAttempts) {\r\n          // Exponential backoff\r\n          await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));\r\n        }\r\n      }\r\n    }\r\n\r\n    throw lastError;\r\n  }\r\n\r\n  /**\r\n   * Parse summarized content based on type\r\n   */\r\n  private parseSummarizedContent(content: string, type: 'repoFacts' | 'context7Docs' | 'codeSnippets'): string[] {\r\n    // Split by common delimiters and clean up\r\n    const lines = content\r\n      .split(/\\n+/)\r\n      .map(line => line.trim())\r\n      .filter(line => line.length > 0);\r\n\r\n    // For repo facts, look for category patterns\r\n    if (type === 'repoFacts') {\r\n      return lines.filter(line => \r\n        line.startsWith('PROJECT:') || \r\n        line.startsWith('TECH_STACK:') || \r\n        line.startsWith('ARCHITECTURE:') || \r\n        line.startsWith('QUALITY:')\r\n      );\r\n    }\r\n\r\n    // For other types, return all non-empty lines\r\n    return lines;\r\n  }\r\n\r\n  /**\r\n   * Calculate quality score for summarization\r\n   */\r\n  private async calculateQualityScore(\r\n    original: string[][],\r\n    summarized: string[][]\r\n  ): Promise<number> {\r\n    try {\r\n      // Simple quality metrics\r\n      const originalTokens = original.flat().reduce((sum, arr) => sum + this.calculateTokenCount(arr), 0);\r\n      const summarizedTokens = summarized.flat().reduce((sum, arr) => sum + this.calculateTokenCount(arr), 0);\r\n      \r\n      // Token reduction score (0-40 points)\r\n      const tokenReduction = Math.max(0, (originalTokens - summarizedTokens) / originalTokens);\r\n      const reductionScore = Math.min(40, tokenReduction * 100);\r\n      \r\n      // Content preservation score (0-40 points)\r\n      const preservationScore = this.calculateContentPreservation(original.flat(), summarized.flat());\r\n      \r\n      // Technical accuracy score (0-20 points)\r\n      const accuracyScore = this.calculateTechnicalAccuracy(summarized.flat());\r\n      \r\n      return Math.min(100, reductionScore + preservationScore + accuracyScore);\r\n    } catch (error) {\r\n      this.logger.warn('Failed to calculate quality score', { error });\r\n      return 50; // Default moderate score\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate content preservation score\r\n   */\r\n  private calculateContentPreservation(original: string[], summarized: string[]): number {\r\n    const originalText = original.join(' ').toLowerCase();\r\n    const summarizedText = summarized.join(' ').toLowerCase();\r\n    \r\n    // Simple keyword matching\r\n    const originalWords = new Set(originalText.split(/\\s+/));\r\n    const summarizedWords = new Set(summarizedText.split(/\\s+/));\r\n    \r\n    const commonWords = new Set([...originalWords].filter(word => summarizedWords.has(word)));\r\n    const preservationRatio = commonWords.size / originalWords.size;\r\n    \r\n    return Math.min(40, preservationRatio * 100);\r\n  }\r\n\r\n  /**\r\n   * Calculate technical accuracy score\r\n   */\r\n  private calculateTechnicalAccuracy(summarized: string[]): number {\r\n    const technicalTerms = [\r\n      'typescript', 'react', 'node', 'express', 'api', 'database', 'sqlite',\r\n      'framework', 'library', 'component', 'hook', 'state', 'props', 'interface',\r\n      'async', 'await', 'promise', 'error', 'validation', 'authentication',\r\n      'middleware', 'routing', 'controller', 'service', 'model', 'schema'\r\n    ];\r\n    \r\n    const text = summarized.join(' ').toLowerCase();\r\n    const foundTerms = technicalTerms.filter(term => text.includes(term));\r\n    \r\n    return Math.min(20, (foundTerms.length / technicalTerms.length) * 100);\r\n  }\r\n\r\n  /**\r\n   * Calculate token count (rough estimate)\r\n   */\r\n  private calculateTokenCount(text: string | string[]): number {\r\n    const content = Array.isArray(text) ? text.join(' ') : text;\r\n    // Rough estimate: 1 token â‰ˆ 4 characters\r\n    return Math.ceil(content.length / 4);\r\n  }\r\n\r\n  /**\r\n   * Estimate API cost\r\n   */\r\n  private estimateCost(inputTokens: number, outputTokens: number): number {\r\n    // GPT-4o-mini pricing (as of 2024)\r\n    const inputCostPer1K = 0.00015;\r\n    const outputCostPer1K = 0.0006;\r\n    \r\n    return (inputTokens / 1000 * inputCostPer1K) + (outputTokens / 1000 * outputCostPer1K);\r\n  }\r\n\r\n  /**\r\n   * Update metrics\r\n   */\r\n  private updateMetrics(\r\n    success: boolean,\r\n    qualityScore: number,\r\n    originalTokens: number,\r\n    summarizedTokens: number,\r\n    processingTime: number,\r\n    cost: number\r\n  ): void {\r\n    if (success) {\r\n      this.metrics.successfulRequests++;\r\n      this.metrics.averageQualityScore = \r\n        (this.metrics.averageQualityScore * (this.metrics.successfulRequests - 1) + qualityScore) / \r\n        this.metrics.successfulRequests;\r\n      \r\n      const tokenReduction = originalTokens > 0 ? (originalTokens - summarizedTokens) / originalTokens : 0;\r\n      this.metrics.averageTokenReduction = \r\n        (this.metrics.averageTokenReduction * (this.metrics.successfulRequests - 1) + tokenReduction) / \r\n        this.metrics.successfulRequests;\r\n    } else {\r\n      this.metrics.failedRequests++;\r\n    }\r\n    \r\n    this.metrics.averageProcessingTime = \r\n      (this.metrics.averageProcessingTime * (this.metrics.totalRequests - 1) + processingTime) / \r\n      this.metrics.totalRequests;\r\n    \r\n    this.metrics.totalCost += cost;\r\n    this.metrics.lastUpdated = new Date();\r\n  }\r\n\r\n  /**\r\n   * Create summarization error\r\n   */\r\n  private createSummarizationError(error: any): SummarizationError {\r\n    return {\r\n      code: error.code || 'SUMMARIZATION_ERROR',\r\n      message: error.message || 'Unknown summarization error',\r\n      details: error,\r\n      retryable: this.isRetryableError(error),\r\n      timestamp: new Date()\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Check if error is retryable\r\n   */\r\n  private isRetryableError(error: any): boolean {\r\n    const retryableCodes = ['rate_limit_exceeded', 'server_error', 'timeout'];\r\n    return retryableCodes.includes(error.code) || error.status >= 500;\r\n  }\r\n\r\n  /**\r\n   * Get current metrics\r\n   */\r\n  getMetrics(): SummarizationMetrics {\r\n    return { ...this.metrics };\r\n  }\r\n\r\n  /**\r\n   * Reset metrics\r\n   */\r\n  resetMetrics(): void {\r\n    this.metrics = {\r\n      totalRequests: 0,\r\n      successfulRequests: 0,\r\n      failedRequests: 0,\r\n      averageQualityScore: 0,\r\n      averageTokenReduction: 0,\r\n      averageProcessingTime: 0,\r\n      totalCost: 0,\r\n      lastUpdated: new Date()\r\n    };\r\n  }\r\n}\r",
        "File: src/services/ai/summarization/quality-validation.service.ts\nDescription: Class definition: QualityValidationService\nCode:\nexport class QualityValidationService {\r\n  private logger: Logger;\r\n  private validationThreshold: number;\r\n\r\n  constructor(validationThreshold: number = 0.8, logger?: Logger) {\r\n    this.logger = logger || new Logger('QualityValidationService');\r\n    this.validationThreshold = validationThreshold;\r\n  }\r\n\r\n  /**\r\n   * Validate summarization quality\r\n   */\r\n  async validateSummarizationQuality(\r\n    original: string[],\r\n    summarized: string[],\r\n    type: 'repoFacts' | 'context7Docs' | 'codeSnippets'\r\n  ): Promise<QualityScore> {\r\n    try {\r\n      this.logger.debug('Starting quality validation', { type, originalLength: original.length, summarizedLength: summarized.length });\r\n\r\n      const scores = await Promise.all([\r\n        this.checkInformationRetention(original, summarized),\r\n        this.checkTechnicalAccuracy(summarized),\r\n        this.checkConciseness(original, summarized),\r\n        this.checkRelevance(summarized, type)\r\n      ]);\r\n\r\n      const [informationRetention, technicalAccuracy, conciseness, relevance] = scores;\r\n      \r\n      // Weighted average with emphasis on information retention and technical accuracy\r\n      const overall = (\r\n        informationRetention * 0.4 +\r\n        technicalAccuracy * 0.3 +\r\n        conciseness * 0.2 +\r\n        relevance * 0.1\r\n      );\r\n\r\n      const qualityScore: QualityScore = {\r\n        overall: Math.round(overall),\r\n        informationRetention: Math.round(informationRetention),\r\n        technicalAccuracy: Math.round(technicalAccuracy),\r\n        conciseness: Math.round(conciseness),\r\n        relevance: Math.round(relevance),\r\n        details: {\r\n          missingKeyInfo: this.identifyMissingKeyInfo(original, summarized),\r\n          technicalErrors: this.identifyTechnicalErrors(summarized),\r\n          redundancyIssues: this.identifyRedundancyIssues(summarized),\r\n          relevanceIssues: this.identifyRelevanceIssues(summarized, type)\r\n        }\r\n      };\r\n\r\n      this.logger.debug('Quality validation completed', {\r\n        type,\r\n        overall: qualityScore.overall,\r\n        breakdown: {\r\n          informationRetention: qualityScore.informationRetention,\r\n          technicalAccuracy: qualityScore.technicalAccuracy,\r\n          conciseness: qualityScore.conciseness,\r\n          relevance: qualityScore.relevance\r\n        }\r\n      });\r\n\r\n      return qualityScore;\r\n    } catch (error) {\r\n      this.logger.error('Quality validation failed', { error, type });\r\n      return this.getDefaultQualityScore();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check information retention\r\n   */\r\n  private async checkInformationRetention(original: string[], summarized: string[]): Promise<number> {\r\n    try {\r\n      // Simple keyword-based analysis\r\n      const originalKeywords = this.extractKeywords(original.join(' '));\r\n      const summarizedKeywords = this.extractKeywords(summarized.join(' '));\r\n      \r\n      const commonKeywords = originalKeywords.filter(keyword => \r\n        summarizedKeywords.some(sumKeyword => \r\n          sumKeyword.toLowerCase().includes(keyword.toLowerCase()) ||\r\n          keyword.toLowerCase().includes(sumKeyword.toLowerCase())\r\n        )\r\n      );\r\n\r\n      const retentionRatio = commonKeywords.length / originalKeywords.length;\r\n      return Math.min(100, retentionRatio * 100);\r\n    } catch (error) {\r\n      this.logger.warn('Information retention check failed', { error });\r\n      return 50; // Default moderate score\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check technical accuracy\r\n   */\r\n  private async checkTechnicalAccuracy(summarized: string[]): Promise<number> {\r\n    try {\r\n      const text = summarized.join(' ').toLowerCase();\r\n      \r\n      // Check for technical terms and patterns\r\n      const technicalPatterns = [\r\n        /\\b(typescript|javascript|react|vue|angular|node\\.?js)\\b/g,\r\n        /\\b(api|rest|graphql|http|https)\\b/g,\r\n        /\\b(database|sqlite|postgresql|mysql|mongodb)\\b/g,\r\n        /\\b(component|hook|state|props|interface|type)\\b/g,\r\n        /\\b(async|await|promise|callback|function)\\b/g,\r\n        /\\b(error|exception|validation|authentication|authorization)\\b/g\r\n      ];\r\n\r\n      let accuracyScore = 0;\r\n      const totalPatterns = technicalPatterns.length;\r\n\r\n      for (const pattern of technicalPatterns) {\r\n        if (pattern.test(text)) {\r\n          accuracyScore += 100 / totalPatterns;\r\n        }\r\n      }\r\n\r\n      // Check for common technical errors\r\n      const errorPatterns = [\r\n        /\\b(jsx|tsx|html|css)\\b.*\\b(typescript|javascript)\\b/g, // Mixed terminology\r\n        /\\b(api|rest)\\b.*\\b(graphql|soap)\\b/g, // Conflicting protocols\r\n        /\\b(react|vue|angular)\\b.*\\b(server|backend)\\b/g // Frontend/backend confusion\r\n      ];\r\n\r\n      let errorPenalty = 0;\r\n      for (const pattern of errorPatterns) {\r\n        if (pattern.test(text)) {\r\n          errorPenalty += 10;\r\n        }\r\n      }\r\n\r\n      return Math.max(0, Math.min(100, accuracyScore - errorPenalty));\r\n    } catch (error) {\r\n      this.logger.warn('Technical accuracy check failed', { error });\r\n      return 50; // Default moderate score\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check conciseness\r\n   */\r\n  private async checkConciseness(original: string[], summarized: string[]): Promise<number> {\r\n    try {\r\n      const originalLength = original.join(' ').length;\r\n      const summarizedLength = summarized.join(' ').length;\r\n      \r\n      if (originalLength === 0) return 100;\r\n      \r\n      const reductionRatio = (originalLength - summarizedLength) / originalLength;\r\n      \r\n      // Optimal reduction is between 60-80%\r\n      if (reductionRatio >= 0.6 && reductionRatio <= 0.8) {\r\n        return 100;\r\n      } else if (reductionRatio > 0.8) {\r\n        // Too much reduction might indicate information loss\r\n        return Math.max(60, 100 - (reductionRatio - 0.8) * 200);\r\n      } else {\r\n        // Not enough reduction\r\n        return Math.max(40, reductionRatio * 125);\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Conciseness check failed', { error });\r\n      return 50; // Default moderate score\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Check relevance\r\n   */\r\n  private async checkRelevance(summarized: string[], type: 'repoFacts' | 'context7Docs' | 'codeSnippets'): Promise<number> {\r\n    try {\r\n      const text = summarized.join(' ').toLowerCase();\r\n      \r\n      // Type-specific relevance patterns\r\n      const relevancePatterns = {\r\n        repoFacts: [\r\n          /\\b(project|application|framework|library|tool)\\b/g,\r\n          /\\b(typescript|javascript|react|vue|angular|node)\\b/g,\r\n          /\\b(architecture|pattern|design|structure)\\b/g,\r\n          /\\b(testing|ci|cd|deployment|quality)\\b/g\r\n        ],\r\n        context7Docs: [\r\n          /\\b(documentation|guide|tutorial|example|usage)\\b/g,\r\n          /\\b(api|method|function|class|interface)\\b/g,\r\n          /\\b(best practice|convention|pattern|recommendation)\\b/g,\r\n          /\\b(integration|implementation|configuration)\\b/g\r\n        ],\r\n        codeSnippets: [\r\n          /\\b(pattern|concept|principle|approach)\\b/g,\r\n          /\\b(architecture|design|structure|organization)\\b/g,\r\n          /\\b(reusable|modular|scalable|maintainable)\\b/g,\r\n          /\\b(convention|standard|practice|guideline)\\b/g\r\n        ]\r\n      };\r\n\r\n      const patterns = relevancePatterns[type];\r\n      let relevanceScore = 0;\r\n      const totalPatterns = patterns.length;\r\n\r\n      for (const pattern of patterns) {\r\n        if (pattern.test(text)) {\r\n          relevanceScore += 100 / totalPatterns;\r\n        }\r\n      }\r\n\r\n      return Math.min(100, relevanceScore);\r\n    } catch (error) {\r\n      this.logger.warn('Relevance check failed', { error });\r\n      return 50; // Default moderate score\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Extract keywords from text\r\n   */\r\n  private extractKeywords(text: string): string[] {\r\n    return text\r\n      .toLowerCase()\r\n      .replace(/[^\\w\\s]/g, ' ')\r\n      .split(/\\s+/)\r\n      .filter(word => word.length > 3)\r\n      .filter(word => !this.isStopWord(word));\r\n  }\r\n\r\n  /**\r\n   * Check if word is a stop word\r\n   */\r\n  private isStopWord(word: string): boolean {\r\n    const stopWords = new Set([\r\n      'the', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for', 'of', 'with',\r\n      'by', 'from', 'up', 'about', 'into', 'through', 'during', 'before',\r\n      'after', 'above', 'below', 'between', 'among', 'this', 'that', 'these',\r\n      'those', 'is', 'are', 'was', 'were', 'be', 'been', 'being', 'have',\r\n      'has', 'had', 'do', 'does', 'did', 'will', 'would', 'could', 'should',\r\n      'may', 'might', 'must', 'can', 'shall', 'a', 'an', 'some', 'any', 'all'\r\n    ]);\r\n    return stopWords.has(word);\r\n  }\r\n\r\n  /**\r\n   * Identify missing key information\r\n   */\r\n  private identifyMissingKeyInfo(original: string[], summarized: string[]): string[] {\r\n    const originalKeywords = this.extractKeywords(original.join(' '));\r\n    const summarizedKeywords = this.extractKeywords(summarized.join(' '));\r\n    \r\n    return originalKeywords\r\n      .filter(keyword => !summarizedKeywords.some(sumKeyword => \r\n        sumKeyword.includes(keyword) || keyword.includes(sumKeyword)\r\n      ))\r\n      .slice(0, 5); // Limit to top 5 missing keywords\r\n  }\r\n\r\n  /**\r\n   * Identify technical errors\r\n   */\r\n  private identifyTechnicalErrors(summarized: string[]): string[] {\r\n    const errors: string[] = [];\r\n    const text = summarized.join(' ').toLowerCase();\r\n    \r\n    // Check for common technical mistakes\r\n    if (text.includes('jsx') && text.includes('typescript')) {\r\n      errors.push('Mixed JSX/TypeScript terminology');\r\n    }\r\n    if (text.includes('api') && text.includes('graphql') && text.includes('rest')) {\r\n      errors.push('Conflicting API protocol references');\r\n    }\r\n    if (text.includes('react') && text.includes('server-side')) {\r\n      errors.push('Frontend/backend concept confusion');\r\n    }\r\n    \r\n    return errors;\r\n  }\r\n\r\n  /**\r\n   * Identify redundancy issues\r\n   */\r\n  private identifyRedundancyIssues(summarized: string[]): string[] {\r\n    const issues: string[] = [];\r\n    const text = summarized.join(' ').toLowerCase();\r\n    \r\n    // Check for repeated phrases\r\n    const words = text.split(/\\s+/);\r\n    const wordCounts = new Map<string, number>();\r\n    \r\n    words.forEach(word => {\r\n      if (word.length > 4) {\r\n        wordCounts.set(word, (wordCounts.get(word) || 0) + 1);\r\n      }\r\n    });\r\n    \r\n    for (const [word, count] of wordCounts.entries()) {\r\n      if (count > 3) {\r\n        issues.push(`Excessive repetition of \"${word}\"`);\r\n      }\r\n    }\r\n    \r\n    return issues.slice(0, 3); // Limit to top 3 issues\r\n  }\r\n\r\n  /**\r\n   * Identify relevance issues\r\n   */\r\n  private identifyRelevanceIssues(summarized: string[], type: 'repoFacts' | 'context7Docs' | 'codeSnippets'): string[] {\r\n    const issues: string[] = [];\r\n    const text = summarized.join(' ').toLowerCase();\r\n    \r\n    // Type-specific relevance checks\r\n    if (type === 'repoFacts' && !text.includes('project') && !text.includes('application')) {\r\n      issues.push('Missing project context information');\r\n    }\r\n    if (type === 'context7Docs' && !text.includes('documentation') && !text.includes('guide')) {\r\n      issues.push('Missing documentation context');\r\n    }\r\n    if (type === 'codeSnippets' && !text.includes('pattern') && !text.includes('concept')) {\r\n      issues.push('Missing code pattern information');\r\n    }\r\n    \r\n    return issues;\r\n  }\r\n\r\n  /**\r\n   * Get default quality score for error cases\r\n   */\r\n  private getDefaultQualityScore(): QualityScore {\r\n    return {\r\n      overall: 50,\r\n      informationRetention: 50,\r\n      technicalAccuracy: 50,\r\n      conciseness: 50,\r\n      relevance: 50,\r\n      details: {\r\n        missingKeyInfo: [],\r\n        technicalErrors: [],\r\n        redundancyIssues: [],\r\n        relevanceIssues: []\r\n      }\r\n    };\r\n  }\r\n\r\n  /**\r\n   * Validate complete summarization response\r\n   */\r\n  async validateSummarizationResponse(\r\n    request: SummarizationRequest,\r\n    response: SummarizationResponse\r\n  ): Promise<SummarizationValidationResult> {\r\n    try {\r\n      const original = [\r\n        ...request.repoFacts,\r\n        ...request.context7Docs,\r\n        ...request.codeSnippets\r\n      ];\r\n      \r\n      const summarized = [\r\n        ...response.summarizedRepoFacts,\r\n        ...response.summarizedContext7Docs,\r\n        ...response.summarizedCodeSnippets\r\n      ];\r\n\r\n      const qualityScore = await this.validateSummarizationQuality(\r\n        original,\r\n        summarized,\r\n        'repoFacts' // Use repoFacts as default type for overall validation\r\n      );\r\n\r\n      const isValid = qualityScore.overall >= (this.validationThreshold * 100);\r\n      const issues = [\r\n        ...qualityScore.details.missingKeyInfo,\r\n        ...qualityScore.details.technicalErrors,\r\n        ...qualityScore.details.redundancyIssues,\r\n        ...qualityScore.details.relevanceIssues\r\n      ];\r\n\r\n      const recommendations = this.generateRecommendations(qualityScore);\r\n\r\n      return {\r\n        isValid,\r\n        qualityScore: qualityScore.overall,\r\n        issues,\r\n        recommendations\r\n      };\r\n    } catch (error) {\r\n      this.logger.error('Summarization response validation failed', { error });\r\n      return {\r\n        isValid: false,\r\n        qualityScore: 0,\r\n        issues: ['Validation failed due to internal error'],\r\n        recommendations: ['Retry summarization with different parameters']\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Generate improvement recommendations\r\n   */\r\n  private generateRecommendations(qualityScore: QualityScore): string[] {\r\n    const recommendations: string[] = [];\r\n\r\n    if (qualityScore.informationRetention < 70) {\r\n      recommendations.push('Include more key technical details in summarization');\r\n    }\r\n    if (qualityScore.technicalAccuracy < 70) {\r\n      recommendations.push('Improve technical terminology and accuracy');\r\n    }\r\n    if (qualityScore.conciseness < 70) {\r\n      recommendations.push('Reduce verbosity while maintaining information density');\r\n    }\r\n    if (qualityScore.relevance < 70) {\r\n      recommendations.push('Focus on context-specific and actionable information');\r\n    }\r\n\r\n    if (recommendations.length === 0) {\r\n      recommendations.push('Quality is acceptable, no specific improvements needed');\r\n    }\r\n\r\n    return recommendations;\r\n  }\r\n}\r",
        "File: src/services/analysis/project-analyzer.service.ts\nDescription: Class definition: ProjectAnalyzerService\nCode:\nexport class ProjectAnalyzerService {\r\n  private logger: Logger;\r\n  private projectRoot: string;\r\n\r\n  constructor(logger: Logger, projectRoot: string = process.cwd()) {\r\n    this.logger = logger;\r\n    this.projectRoot = projectRoot;\r\n  }\r\n\r\n  /**\r\n   * Analyze the project and return comprehensive facts and snippets\r\n   */\r\n  async analyzeProject(): Promise<RepoFact[]> {\r\n    try {\r\n      console.log('ðŸ” [ProjectAnalyzer] Starting comprehensive project analysis', { projectRoot: this.projectRoot });\r\n      this.logger.info('Starting comprehensive project analysis', { projectRoot: this.projectRoot });\r\n\r\n      const repoFacts: RepoFact[] = [];\r\n\r\n      // 1. Analyze package.json for dependencies and project info\r\n      console.log('ðŸ” [ProjectAnalyzer] Analyzing package.json...');\r\n      const packageFacts = await this.analyzePackageJson();\r\n      console.log('ðŸ” [ProjectAnalyzer] Package facts found:', packageFacts.length);\r\n      repoFacts.push(...packageFacts);\r\n\r\n      // 2. Analyze project structure\r\n      console.log('ðŸ” [ProjectAnalyzer] Analyzing project structure...');\r\n      const structureFacts = await this.analyzeProjectStructure();\r\n      console.log('ðŸ” [ProjectAnalyzer] Structure facts found:', structureFacts.length);\r\n      repoFacts.push(...structureFacts);\r\n\r\n      // 3. Analyze framework usage\r\n      console.log('ðŸ” [ProjectAnalyzer] Analyzing framework usage...');\r\n      const frameworkFacts = await this.analyzeFrameworkUsage();\r\n      console.log('ðŸ” [ProjectAnalyzer] Framework facts found:', frameworkFacts.length);\r\n      repoFacts.push(...frameworkFacts);\r\n\r\n      // 4. Analyze architecture patterns\r\n      console.log('ðŸ” [ProjectAnalyzer] Analyzing architecture patterns...');\r\n      const architectureFacts = await this.analyzeArchitecturePatterns();\r\n      console.log('ðŸ” [ProjectAnalyzer] Architecture facts found:', architectureFacts.length);\r\n      repoFacts.push(...architectureFacts);\r\n\r\n      console.log('âœ… [ProjectAnalyzer] Project analysis completed', { \r\n        factsCount: repoFacts.length,\r\n        factTypes: [...new Set(repoFacts.map(f => f.type))]\r\n      });\r\n\r\n      this.logger.info('Project analysis completed', { \r\n        factsCount: repoFacts.length,\r\n        factTypes: [...new Set(repoFacts.map(f => f.type))]\r\n      });\r\n\r\n      return repoFacts;\r\n\r\n    } catch (error) {\r\n      console.error('âŒ [ProjectAnalyzer] Project analysis failed', error);\r\n      this.logger.error('Project analysis failed', { \r\n        error: error instanceof Error ? error.message : 'Unknown error' \r\n      });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Find relevant code snippets based on prompt\r\n   */\r\n  async findRelevantCodeSnippets(prompt: string, targetFile?: string): Promise<CodeSnippet[]> {\r\n    try {\r\n      console.log('ðŸ” [ProjectAnalyzer] Finding relevant code snippets', { prompt: prompt.substring(0, 100) + '...', targetFile });\r\n      this.logger.info('Finding relevant code snippets', { prompt: prompt.substring(0, 100) + '...', targetFile });\r\n\r\n      const snippets: CodeSnippet[] = [];\r\n\r\n      // If target file is specified, analyze that file\r\n      if (targetFile) {\r\n        console.log('ðŸ” [ProjectAnalyzer] Analyzing target file:', targetFile);\r\n        const fileSnippets = await this.analyzeFileForSnippets(targetFile, prompt);\r\n        console.log('ðŸ” [ProjectAnalyzer] Target file snippets found:', fileSnippets.length);\r\n        snippets.push(...fileSnippets);\r\n      }\r\n\r\n      // Analyze common source directories\r\n      const sourceDirs = ['src', 'lib', 'app', 'components', 'pages', 'utils'];\r\n      console.log('ðŸ” [ProjectAnalyzer] Analyzing source directories:', sourceDirs);\r\n      for (const dir of sourceDirs) {\r\n        const dirPath = path.join(this.projectRoot, dir);\r\n        if (await this.directoryExists(dirPath)) {\r\n          console.log('ðŸ” [ProjectAnalyzer] Analyzing directory:', dirPath);\r\n          const dirSnippets = await this.analyzeDirectoryForSnippets(dirPath, prompt);\r\n          console.log('ðŸ” [ProjectAnalyzer] Directory snippets found:', dirSnippets.length);\r\n          snippets.push(...dirSnippets);\r\n        } else {\r\n          console.log('ðŸ” [ProjectAnalyzer] Directory does not exist:', dirPath);\r\n        }\r\n      }\r\n\r\n      // Sort by relevance and return top snippets\r\n      const sortedSnippets = snippets\r\n        .sort((a, b) => b.relevance - a.relevance)\r\n        .slice(0, 10); // Limit to top 10 snippets\r\n\r\n      console.log('âœ… [ProjectAnalyzer] Code snippet analysis completed', { \r\n        totalSnippets: snippets.length,\r\n        returnedSnippets: sortedSnippets.length\r\n      });\r\n\r\n      this.logger.info('Code snippet analysis completed', { \r\n        totalSnippets: snippets.length,\r\n        returnedSnippets: sortedSnippets.length\r\n      });\r\n\r\n      return sortedSnippets;\r\n\r\n    } catch (error) {\r\n      console.error('âŒ [ProjectAnalyzer] Code snippet analysis failed', error);\r\n      this.logger.error('Code snippet analysis failed', { \r\n        error: error instanceof Error ? error.message : 'Unknown error' \r\n      });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Analyze package.json for project facts\r\n   */\r\n  private async analyzePackageJson(): Promise<RepoFact[]> {\r\n    const facts: RepoFact[] = [];\r\n\r\n    try {\r\n      const packagePath = path.join(this.projectRoot, 'package.json');\r\n      const packageContent = await fs.readFile(packagePath, 'utf-8');\r\n      const packageJson = JSON.parse(packageContent);\r\n\r\n      // Project name and description\r\n      if (packageJson.name) {\r\n        facts.push({\r\n          type: 'structure',\r\n          fact: `Project name: ${packageJson.name}`,\r\n          confidence: 1.0,\r\n          source: 'package.json'\r\n        });\r\n      }\r\n\r\n      if (packageJson.description) {\r\n        facts.push({\r\n          type: 'structure',\r\n          fact: `Project description: ${packageJson.description}`,\r\n          confidence: 1.0,\r\n          source: 'package.json'\r\n        });\r\n      }\r\n\r\n      // Main dependencies\r\n      const dependencies = packageJson.dependencies || {};\r\n      const devDependencies = packageJson.devDependencies || {};\r\n      const allDeps = { ...dependencies, ...devDependencies };\r\n\r\n      // Framework detection\r\n      const frameworks = this.detectFrameworksFromDependencies(allDeps);\r\n      for (const framework of frameworks) {\r\n        facts.push({\r\n          type: 'framework',\r\n          fact: `Uses ${framework.name} framework (${framework.version})`,\r\n          confidence: framework.confidence,\r\n          source: 'package.json'\r\n        });\r\n      }\r\n\r\n      // Project type detection\r\n      const projectType = this.detectProjectType(packageJson);\r\n      if (projectType) {\r\n        facts.push({\r\n          type: 'architecture',\r\n          fact: `Project type: ${projectType}`,\r\n          confidence: 0.9,\r\n          source: 'package.json'\r\n        });\r\n      }\r\n\r\n      // Scripts analysis\r\n      if (packageJson.scripts) {\r\n        const scriptFacts = this.analyzeScripts(packageJson.scripts);\r\n        facts.push(...scriptFacts);\r\n      }\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Failed to analyze package.json', { error });\r\n    }\r\n\r\n    return facts;\r\n  }\r\n\r\n  /**\r\n   * Analyze project structure\r\n   */\r\n  private async analyzeProjectStructure(): Promise<RepoFact[]> {\r\n    const facts: RepoFact[] = [];\r\n\r\n    try {\r\n      const entries = await fs.readdir(this.projectRoot, { withFileTypes: true });\r\n\r\n      // Check for common project files\r\n      const commonFiles = ['README.md', 'LICENSE', 'Dockerfile', 'docker-compose.yml', '.gitignore'];\r\n      for (const file of commonFiles) {\r\n        if (entries.some(entry => entry.name === file)) {\r\n          facts.push({\r\n            type: 'structure',\r\n            fact: `Contains ${file}`,\r\n            confidence: 1.0,\r\n            source: 'file-system'\r\n          });\r\n        }\r\n      }\r\n\r\n      // Check for source directories\r\n      const sourceDirs = ['src', 'lib', 'app', 'components', 'pages', 'utils', 'services'];\r\n      const foundDirs = entries\r\n        .filter(entry => entry.isDirectory() && sourceDirs.includes(entry.name))\r\n        .map(entry => entry.name);\r\n\r\n      if (foundDirs.length > 0) {\r\n        facts.push({\r\n          type: 'structure',\r\n          fact: `Source directories: ${foundDirs.join(', ')}`,\r\n          confidence: 0.9,\r\n          source: 'file-system'\r\n        });\r\n      }\r\n\r\n      // Check for config files\r\n      const configFiles = ['tsconfig.json', 'jest.config.js', 'webpack.config.js', 'vite.config.js', 'next.config.js'];\r\n      const foundConfigs = entries\r\n        .filter(entry => entry.isFile() && configFiles.includes(entry.name))\r\n        .map(entry => entry.name);\r\n\r\n      if (foundConfigs.length > 0) {\r\n        facts.push({\r\n          type: 'structure',\r\n          fact: `Configuration files: ${foundConfigs.join(', ')}`,\r\n          confidence: 0.8,\r\n          source: 'file-system'\r\n        });\r\n      }\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Failed to analyze project structure', { error });\r\n    }\r\n\r\n    return facts;\r\n  }\r\n\r\n  /**\r\n   * Analyze framework usage patterns\r\n   */\r\n  private async analyzeFrameworkUsage(): Promise<RepoFact[]> {\r\n    const facts: RepoFact[] = [];\r\n\r\n    try {\r\n      // Check for TypeScript usage\r\n      const tsConfigPath = path.join(this.projectRoot, 'tsconfig.json');\r\n      if (await this.fileExists(tsConfigPath)) {\r\n        facts.push({\r\n          type: 'framework',\r\n          fact: 'Uses TypeScript for type safety',\r\n          confidence: 1.0,\r\n          source: 'tsconfig.json'\r\n        });\r\n      }\r\n\r\n      // Check for React usage\r\n      const reactFiles = await this.findFilesByPattern('**/*.{tsx,jsx}');\r\n      if (reactFiles.length > 0) {\r\n        facts.push({\r\n          type: 'framework',\r\n          fact: `Uses React with ${reactFiles.length} component files`,\r\n          confidence: 0.9,\r\n          source: 'file-analysis'\r\n        });\r\n      }\r\n\r\n      // Check for Node.js/Express usage\r\n      const serverFiles = await this.findFilesByPattern('**/server.{js,ts}');\r\n      const appFiles = await this.findFilesByPattern('**/app.{js,ts}');\r\n      if (serverFiles.length > 0 || appFiles.length > 0) {\r\n        facts.push({\r\n          type: 'framework',\r\n          fact: 'Uses Node.js/Express for backend',\r\n          confidence: 0.8,\r\n          source: 'file-analysis'\r\n        });\r\n      }\r\n\r\n      // Check for testing setup\r\n      const testFiles = await this.findFilesByPattern('**/*.{test,spec}.{js,ts,tsx}');\r\n      if (testFiles.length > 0) {\r\n        facts.push({\r\n          type: 'pattern',\r\n          fact: `Uses testing with ${testFiles.length} test files`,\r\n          confidence: 0.9,\r\n          source: 'file-analysis'\r\n        });\r\n      }\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Failed to analyze framework usage', { error });\r\n    }\r\n\r\n    return facts;\r\n  }\r\n\r\n  /**\r\n   * Analyze architecture patterns\r\n   */\r\n  private async analyzeArchitecturePatterns(): Promise<RepoFact[]> {\r\n    const facts: RepoFact[] = [];\r\n\r\n    try {\r\n      // Check for MCP (Model Context Protocol) usage\r\n      const mcpFiles = await this.findFilesByPattern('**/*mcp*');\r\n      if (mcpFiles.length > 0) {\r\n        facts.push({\r\n          type: 'architecture',\r\n          fact: 'Uses Model Context Protocol (MCP) for AI integration',\r\n          confidence: 0.9,\r\n          source: 'file-analysis'\r\n        });\r\n      }\r\n\r\n      // Check for service-oriented architecture\r\n      const serviceFiles = await this.findFilesByPattern('**/services/**/*.{js,ts}');\r\n      if (serviceFiles.length > 0) {\r\n        facts.push({\r\n          type: 'architecture',\r\n          fact: `Uses service-oriented architecture with ${serviceFiles.length} service files`,\r\n          confidence: 0.8,\r\n          source: 'file-analysis'\r\n        });\r\n      }\r\n\r\n      // Check for tool-based architecture\r\n      const toolFiles = await this.findFilesByPattern('**/tools/**/*.{js,ts}');\r\n      if (toolFiles.length > 0) {\r\n        facts.push({\r\n          type: 'architecture',\r\n          fact: `Uses tool-based architecture with ${toolFiles.length} tool files`,\r\n          confidence: 0.8,\r\n          source: 'file-analysis'\r\n        });\r\n      }\r\n\r\n      // Check for Docker usage\r\n      const dockerFiles = await this.findFilesByPattern('**/Dockerfile*');\r\n      if (dockerFiles.length > 0) {\r\n        facts.push({\r\n          type: 'architecture',\r\n          fact: 'Uses Docker for containerization',\r\n          confidence: 1.0,\r\n          source: 'file-analysis'\r\n        });\r\n      }\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Failed to analyze architecture patterns', { error });\r\n    }\r\n\r\n    return facts;\r\n  }\r\n\r\n  /**\r\n   * Analyze a specific file for code snippets\r\n   */\r\n  private async analyzeFileForSnippets(filePath: string, prompt: string): Promise<CodeSnippet[]> {\r\n    const snippets: CodeSnippet[] = [];\r\n\r\n    try {\r\n      const content = await fs.readFile(filePath, 'utf-8');\r\n      const language = this.detectLanguage(filePath);\r\n      \r\n      // Extract relevant code blocks\r\n      const codeBlocks = this.extractCodeBlocks(content, prompt);\r\n      \r\n      for (const block of codeBlocks) {\r\n        snippets.push({\r\n          file: path.relative(this.projectRoot, filePath),\r\n          content: block.content,\r\n          language,\r\n          relevance: block.relevance,\r\n          description: block.description\r\n        });\r\n      }\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Failed to analyze file for snippets', { filePath, error });\r\n    }\r\n\r\n    return snippets;\r\n  }\r\n\r\n  /**\r\n   * Analyze directory for code snippets\r\n   */\r\n  private async analyzeDirectoryForSnippets(dirPath: string, prompt: string): Promise<CodeSnippet[]> {\r\n    const snippets: CodeSnippet[] = [];\r\n\r\n    try {\r\n      const entries = await fs.readdir(dirPath, { withFileTypes: true });\r\n      \r\n      for (const entry of entries) {\r\n        const fullPath = path.join(dirPath, entry.name);\r\n        \r\n        if (entry.isDirectory()) {\r\n          // Recursively analyze subdirectories (limit depth)\r\n          const subSnippets = await this.analyzeDirectoryForSnippets(fullPath, prompt);\r\n          snippets.push(...subSnippets);\r\n        } else if (this.isCodeFile(entry.name)) {\r\n          const fileSnippets = await this.analyzeFileForSnippets(fullPath, prompt);\r\n          snippets.push(...fileSnippets);\r\n        }\r\n      }\r\n\r\n    } catch (error) {\r\n      this.logger.warn('Failed to analyze directory for snippets', { dirPath, error });\r\n    }\r\n\r\n    return snippets;\r\n  }\r\n\r\n  /**\r\n   * Extract code blocks from content based on prompt relevance\r\n   */\r\n  private extractCodeBlocks(content: string, prompt: string): Array<{ content: string; relevance: number; description: string }> {\r\n    const blocks: Array<{ content: string; relevance: number; description: string }> = [];\r\n    const lines = content.split('\\n');\r\n    \r\n    // Extract function definitions\r\n    const functionRegex = /(?:function|const|let|var)\\s+\\w+\\s*[=\\(]/g;\r\n    let match;\r\n    while ((match = functionRegex.exec(content)) !== null) {\r\n      const startLine = content.substring(0, match.index).split('\\n').length - 1;\r\n      const endLine = this.findFunctionEnd(lines, startLine);\r\n      \r\n      if (endLine > startLine) {\r\n        const functionContent = lines.slice(startLine, endLine + 1).join('\\n');\r\n        const relevance = this.calculateRelevance(functionContent, prompt);\r\n        \r\n        if (relevance > 0.1) { // Lowered threshold from 0.3 to 0.1\r\n          blocks.push({\r\n            content: functionContent,\r\n            relevance,\r\n            description: `Function definition: ${this.extractFunctionName(functionContent)}`\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    // Extract class definitions\r\n    const classRegex = /class\\s+\\w+/g;\r\n    while ((match = classRegex.exec(content)) !== null) {\r\n      const startLine = content.substring(0, match.index).split('\\n').length - 1;\r\n      const endLine = this.findClassEnd(lines, startLine);\r\n      \r\n      if (endLine > startLine) {\r\n        const classContent = lines.slice(startLine, endLine + 1).join('\\n');\r\n        const relevance = this.calculateRelevance(classContent, prompt);\r\n        \r\n        if (relevance > 0.1) { // Lowered threshold from 0.3 to 0.1\r\n          blocks.push({\r\n            content: classContent,\r\n            relevance,\r\n            description: `Class definition: ${this.extractClassName(classContent)}`\r\n          });\r\n        }\r\n      }\r\n    }\r\n\r\n    return blocks;\r\n  }\r",
        "File: src/services/context7/simple-context7-client.ts\nDescription: Class definition: SimpleContext7Client\nCode:\nexport class SimpleContext7Client {\r\n  private apiKey: string;\r\n  private logger: any;\r\n  private mcpServer: any; // Reference to MCP server for internal tool calls\r\n  private config?: any; // Configuration for URLs and settings\r\n  private openAIInterceptor?: Context7OpenAIInterceptor;\r\n\r\n  constructor(\r\n    config: Context7Config, \r\n    logger?: any, \r\n    mcpServer?: any,\r\n    openAIInterceptor?: Context7OpenAIInterceptor\r\n  ) {\r\n    this.apiKey = config.apiKey;\r\n    this.logger = logger || console;\r\n    this.mcpServer = mcpServer;\r\n    this.config = config;\r\n    this.openAIInterceptor = openAIInterceptor;\r\n    \r\n    console.log('ðŸ” [Context7-Client-Debug] SimpleContext7Client initialized', {\r\n      hasApiKey: !!this.apiKey,\r\n      apiKeyLength: this.apiKey.length,\r\n      hasLogger: !!this.logger,\r\n      hasMcpServer: !!this.mcpServer,\r\n      mcpServerType: typeof this.mcpServer\r\n    });\r\n    \r\n    this.logger.info('ðŸ” [Context7-Client-Debug] SimpleContext7Client initialized', {\r\n      hasApiKey: !!this.apiKey,\r\n      apiKeyLength: this.apiKey.length,\r\n      hasLogger: !!this.logger,\r\n      hasMcpServer: !!this.mcpServer,\r\n      mcpServerType: typeof this.mcpServer\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Resolve library name to Context7 library information\r\n   * Uses internal MCP tools instead of direct HTTP calls\r\n   */\r\n  async resolveLibraryId(libraryName: string): Promise<Context7LibraryInfo[]> {\r\n    const debugMode = process.env.CONTEXT7_DEBUG === 'true';\r\n    \r\n    // Always log the first call to see if the method is being called at all\r\n    this.logger.info('ðŸ” [Context7-Debug] resolveLibraryId called', {\r\n      libraryName,\r\n      debugMode,\r\n      context7DebugEnv: process.env.CONTEXT7_DEBUG,\r\n      timestamp: new Date().toISOString(),\r\n      hasMcpServer: !!this.mcpServer,\r\n      hasExecuteToolInternal: !!(this.mcpServer && this.mcpServer.executeToolInternal)\r\n    });\r\n    \r\n    if (debugMode) {\r\n      this.logger.info('ðŸ” [Context7-Debug] Starting library resolution', {\r\n        libraryName,\r\n        timestamp: new Date().toISOString(),\r\n        hasMcpServer: !!this.mcpServer,\r\n        hasExecuteToolInternal: !!(this.mcpServer && this.mcpServer.executeToolInternal)\r\n      });\r\n    }\r\n\r\n    try {\r\n      // Always call external Context7 API directly (like Cursor does)\r\n      if (false) { // Disabled internal tool calls - use direct API instead\r\n        if (debugMode) {\r\n          this.logger.info('ðŸ” [Context7-Debug] Using internal MCP tool', { libraryName });\r\n        }\r\n        \r\n        this.logger.info('ðŸ” [Context7-Debug] MCP server available, calling executeToolInternal', {\r\n          hasMcpServer: !!this.mcpServer,\r\n          hasExecuteToolInternal: !!this.mcpServer.executeToolInternal,\r\n          libraryName\r\n        });\r\n        \r\n        const result = await this.mcpServer.executeToolInternal('resolve-library-id', { libraryName });\r\n        \r\n        if (debugMode) {\r\n          this.logger.info('ðŸ” [Context7-Debug] Internal MCP tool result', {\r\n            libraryName,\r\n            success: result.success,\r\n            hasResult: !!result.result,\r\n            resultLength: result.result ? result.result.length : 0,\r\n            error: result.error,\r\n            resultType: typeof result.result,\r\n            isArray: Array.isArray(result.result)\r\n          });\r\n        }\r\n        \r\n        if (result.success) {\r\n          const libraries = result.result || [];\r\n          if (debugMode) {\r\n            this.logger.info('ðŸ” [Context7-Debug] Internal MCP tool success', {\r\n              libraryName,\r\n              librariesFound: libraries.length,\r\n            libraries: libraries.map((lib: any) => ({\r\n              libraryId: lib.libraryId,\r\n              name: lib.name,\r\n              codeSnippets: lib.codeSnippets,\r\n              trustScore: lib.trustScore\r\n            }))\r\n            });\r\n          }\r\n          return libraries;\r\n        } else {\r\n          this.logger.warn('Internal MCP tool failed, falling back to direct API call', { \r\n            error: result.error \r\n          });\r\n        }\r\n      }\r\n\r\n      // Fallback to direct API call if internal MCP tool not available\r\n      const mcpRequest = {\r\n        jsonrpc: '2.0',\r\n        id: Date.now(),\r\n        method: 'tools/call',\r\n        params: {\r\n          name: 'resolve-library-id',\r\n          arguments: { libraryName }\r\n        }\r\n      };\r\n\r\n      if (debugMode) {\r\n        const apiUrl = process.env.CONTEXT7_BASE_URL || this.config?.mcp?.serverUrl || this.config?.baseUrl || 'https://mcp.context7.com/mcp';\r\n        this.logger.info('ðŸ” [Context7-Debug] Making direct API call', {\r\n          libraryName,\r\n          requestId: mcpRequest.id,\r\n          apiUrl,\r\n          requestBody: JSON.stringify(mcpRequest, null, 2)\r\n        });\r\n      }\r\n\r\n      const apiUrl = process.env.CONTEXT7_BASE_URL || this.config?.mcp?.serverUrl || this.config?.baseUrl || 'https://mcp.context7.com/mcp';\r\n      const response = await fetch(apiUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Accept': 'application/json, text/event-stream',\r\n          'CONTEXT7_API_KEY': this.apiKey,\r\n          'User-Agent': 'PromptMCP-SimpleClient/1.0.0'\r\n        },\r\n        body: JSON.stringify(mcpRequest)\r\n      });\r\n\r\n      if (debugMode) {\r\n        this.logger.info('ðŸ” [Context7-Debug] API response received', {\r\n          libraryName,\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          ok: response.ok,\r\n          headers: Object.fromEntries(response.headers.entries())\r\n        });\r\n      }\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Context7 API error: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const responseText = await response.text();\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('ðŸ” [Context7-Debug] Raw response text', {\r\n          libraryName,\r\n          responseLength: responseText.length,\r\n          responsePreview: responseText.substring(0, 500),\r\n          isSSE: responseText.includes('event:'),\r\n          hasData: responseText.includes('data:')\r\n        });\r\n      }\r\n\r\n      const result = SSEParser.parseResponse(responseText);\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('ðŸ” [Context7-Debug] Parsed response', {\r\n          libraryName,\r\n          hasResult: !!result,\r\n          resultType: typeof result,\r\n          resultKeys: result ? Object.keys(result) : [],\r\n          hasResultArray: !!(result && result.result),\r\n          resultArrayLength: result && result.result ? result.result.length : 0,\r\n          hasContentArray: !!(result && result.result && result.result.content),\r\n          contentArrayLength: result && result.result && result.result.content ? result.result.content.length : 0\r\n        });\r\n      }\r\n      \r\n      // Context7 returns text-based response format:\r\n      // { result: { content: [{ type: \"text\", text: \"Available Libraries...\\n- Title: React\\n- Context7-compatible library ID: /websites/react_dev\\n...\" }] } }\r\n      let libraries = [];\r\n      \r\n      if (result && result.result) {\r\n        if (Array.isArray(result.result)) {\r\n          // Direct array format (expected but not used by Context7)\r\n          libraries = result.result;\r\n        } else if (result.result.content && Array.isArray(result.result.content)) {\r\n          // Text-based format (actual Context7 response)\r\n          const textContent = result.result.content[0]?.text || '';\r\n          libraries = this.parseLibraryTextResponse(textContent);\r\n          \r\n          if (debugMode) {\r\n            this.logger.info('ðŸ” [Context7-Debug] Parsed text response', {\r\n              libraryName,\r\n              textLength: textContent.length,\r\n              librariesFound: libraries.length,\r\n            libraries: libraries.map((lib: any) => ({\r\n              libraryId: lib.libraryId,\r\n              name: lib.name,\r\n              codeSnippets: lib.codeSnippets,\r\n              trustScore: lib.trustScore\r\n            }))\r\n            });\r\n          }\r\n        }\r\n      }\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('ðŸ” [Context7-Debug] Final library resolution result', {\r\n          libraryName,\r\n          librariesFound: libraries.length,\r\n          libraries: libraries.map((lib: any) => ({\r\n            libraryId: lib.libraryId,\r\n            name: lib.name,\r\n            description: lib.description ? lib.description.substring(0, 100) + '...' : 'No description',\r\n            codeSnippets: lib.codeSnippets,\r\n            trustScore: lib.trustScore\r\n          }))\r\n        });\r\n      }\r\n      \r\n      return libraries;\r\n    } catch (error) {\r\n      if (debugMode) {\r\n        this.logger.error('ðŸ” [Context7-Debug] Library resolution failed with error', {\r\n          libraryName,\r\n          error: error instanceof Error ? error.message : 'Unknown error',\r\n          stack: error instanceof Error ? error.stack : undefined,\r\n          errorType: typeof error\r\n        });\r\n      }\r\n      \r\n      this.logger.warn('Context7 library resolution failed', { \r\n        libraryName, \r\n        error: error instanceof Error ? error.message : 'Unknown error' \r\n      });\r\n      return [];\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Get library documentation from Context7\r\n   * Verified against actual Context7 API with optional AI enhancement\r\n   */\r\n  async getLibraryDocs(\r\n    libraryId: string, \r\n    topic?: string, \r\n    tokens?: number,\r\n    enhancementOptions?: Context7EnhancementOptions\r\n  ): Promise<Context7Documentation> {\r\n    const debugMode = process.env.CONTEXT7_DEBUG === 'true';\r\n    \r\n    if (debugMode) {\r\n      this.logger.info('ðŸ“š [Context7-Debug] Starting documentation retrieval', {\r\n        libraryId,\r\n        topic,\r\n        tokens: tokens || 4000,\r\n        timestamp: new Date().toISOString(),\r\n        hasMcpServer: !!this.mcpServer,\r\n        hasExecuteToolInternal: !!(this.mcpServer && this.mcpServer.executeToolInternal)\r\n      });\r\n    }\r\n\r\n    try {\r\n      // Always call external Context7 API directly (like Cursor does)\r\n      if (false) { // Disabled internal tool calls - use direct API instead\r\n        if (debugMode) {\r\n          this.logger.info('ðŸ“š [Context7-Debug] Using internal MCP tool for docs', {\r\n            libraryId,\r\n            topic,\r\n            tokens: tokens || 4000\r\n          });\r\n        }\r\n        \r\n        const result = await this.mcpServer.executeToolInternal('get-library-docs', {\r\n          context7CompatibleLibraryID: libraryId,\r\n          topic,\r\n          tokens: tokens || 4000\r\n        });\r\n        \r\n        if (debugMode) {\r\n          this.logger.info('ðŸ“š [Context7-Debug] Internal MCP tool result for docs', {\r\n            libraryId,\r\n            success: result.success,\r\n            hasResult: !!result.result,\r\n            hasContent: !!(result.result && result.result.content),\r\n            contentLength: result.result && result.result.content ? result.result.content.length : 0,\r\n            error: result.error\r\n          });\r\n        }\r\n        \r\n        if (result.success) {\r\n          const docs = {\r\n            content: result.result?.content || '',\r\n            metadata: {\r\n              libraryId,\r\n              topic,\r\n              tokens: tokens || 4000,\r\n              retrievedAt: new Date(),\r\n              source: 'internal-mcp'\r\n            }\r\n          };\r\n          \r\n          if (debugMode) {\r\n            this.logger.info('ðŸ“š [Context7-Debug] Internal MCP tool success for docs', {\r\n              libraryId,\r\n              contentLength: docs.content.length,\r\n              hasContent: docs.content.length > 0,\r\n              contentPreview: docs.content.substring(0, 200) + (docs.content.length > 200 ? '...' : ''),\r\n              metadata: docs.metadata\r\n            });\r\n          }\r\n          \r\n          return docs;\r\n        } else {\r\n          this.logger.warn('Internal MCP tool failed, falling back to direct API call', { \r\n            error: result.error \r\n          });\r\n        }\r\n      }\r\n\r\n      // Fallback to direct API call if internal MCP tool not available\r\n      const mcpRequest = {\r\n        jsonrpc: '2.0',\r\n        id: Date.now(),\r\n        method: 'tools/call',\r\n        params: {\r\n          name: 'get-library-docs',\r\n          arguments: {\r\n            context7CompatibleLibraryID: libraryId,\r\n            topic,\r\n            tokens: tokens || 4000\r\n          }\r\n        }\r\n      };\r\n\r\n      if (debugMode) {\r\n        const apiUrl = process.env.CONTEXT7_BASE_URL || this.config?.mcp?.serverUrl || this.config?.baseUrl || 'https://mcp.context7.com/mcp';\r\n        this.logger.info('ðŸ“š [Context7-Debug] Making direct API call for docs', {\r\n          libraryId,\r\n          topic,\r\n          tokens: tokens || 4000,\r\n          requestId: mcpRequest.id,\r\n          apiUrl,\r\n          requestBody: JSON.stringify(mcpRequest, null, 2)\r\n        });\r\n      }\r\n\r\n      const apiUrl = process.env.CONTEXT7_BASE_URL || this.config?.mcp?.serverUrl || this.config?.baseUrl || 'https://mcp.context7.com/mcp';\r\n      const response = await fetch(apiUrl, {\r\n        method: 'POST',\r\n        headers: {\r\n          'Content-Type': 'application/json',\r\n          'Accept': 'application/json, text/event-stream',\r\n          'CONTEXT7_API_KEY': this.apiKey,\r\n          'User-Agent': 'PromptMCP-SimpleClient/1.0.0'\r\n        },\r\n        body: JSON.stringify(mcpRequest)\r\n      });\r\n\r\n      if (debugMode) {\r\n        this.logger.info('ðŸ“š [Context7-Debug] API response received for docs', {\r\n          libraryId,\r\n          status: response.status,\r\n          statusText: response.statusText,\r\n          ok: response.ok,\r\n          headers: Object.fromEntries(response.headers.entries())\r\n        });\r\n      }\r\n\r\n      if (!response.ok) {\r\n        throw new Error(`Context7 API error: ${response.status} ${response.statusText}`);\r\n      }\r\n\r\n      const responseText = await response.text();\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('ðŸ“š [Context7-Debug] Raw response text for docs', {\r\n          libraryId,\r\n          responseLength: responseText.length,\r\n          responsePreview: responseText.substring(0, 500),\r\n          isSSE: responseText.includes('event:'),\r\n          hasData: responseText.includes('data:')\r\n        });\r\n      }\r\n\r\n      const result = SSEParser.parseResponse(responseText);\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('ðŸ“š [Context7-Debug] Parsed response for docs', {\r\n          libraryId,\r\n          hasResult: !!result,\r\n          resultType: typeof result,\r\n          resultKeys: result ? Object.keys(result) : [],\r\n          hasResultContent: !!(result && result.result && result.result.content),\r\n          contentLength: result && result.result && result.result.content ? result.result.content.length : 0\r\n        });\r\n      }\r\n      \r\n      // Context7 returns documentation with text-based format:\r\n      // { result: { content: [{ type: \"text\", text: \"================\\nCODE SNIPPETS\\n================\\nTITLE: ...\" }] } }\r\n      let content = '';\r\n      \r\n      if (result && result.result) {\r\n        if (typeof result.result.content === 'string') {\r\n          // Direct string content\r\n          content = result.result.content;\r\n        } else if (Array.isArray(result.result.content) && result.result.content[0] && result.result.content[0].text) {\r\n          // Text-based format (actual Context7 response)\r\n          content = result.result.content[0].text;\r\n        }\r\n      }\r\n      \r\n      let finalContent = content;\r\n      let enhancementResult: Context7EnhancementResult | undefined;\r\n\r\n      // Apply AI enhancement if enabled\r\n      if (this.openAIInterceptor && enhancementOptions?.useAIEnhancement && content) {\r\n        try {\r\n          const framework = this.extractFrameworkFromLibraryId(libraryId);\r\n          enhancementResult = await this.openAIInterceptor.enhanceContext7Result(\r\n            content,\r\n            framework,\r\n            enhancementOptions\r\n          );\r\n          \r\n          finalContent = enhancementResult.enhancedDocs;\r\n          \r\n          if (debugMode) {\r\n            this.logger.info('ðŸ“š [Context7-Debug] Applied AI enhancement', {\r\n              libraryId,\r\n              originalLength: content.length,\r\n              enhancedLength: finalContent.length,\r\n              tokensUsed: enhancementResult.enhancementMetadata.tokensUsed,\r\n              cost: enhancementResult.enhancementMetadata.cost\r\n            });\r\n          }\r\n        } catch (enhancementError) {\r\n          this.logger.warn('AI enhancement failed, using original content', {\r\n            libraryId,\r\n            error: enhancementError instanceof Error ? enhancementError.message : 'Unknown error'\r\n          });\r\n        }\r\n      }\r\n\r\n      const docs = {\r\n        content: finalContent,\r\n        metadata: {\r\n          libraryId,\r\n          topic,\r\n          tokens: tokens || 4000,\r\n          retrievedAt: new Date(),\r\n          source: 'Context7 MCP'\r\n        },\r\n        enhancementResult\r\n      };\r\n      \r\n      if (debugMode) {\r\n        this.logger.info('ðŸ“š [Context7-Debug] Final documentation result', {\r\n          libraryId,\r\n          contentLength: docs.content.length,\r\n          hasContent: docs.content.length > 0,\r\n          contentPreview: docs.content.substring(0, 200) + (docs.content.length > 200 ? '...' : ''),\r\n          metadata: docs.metadata,\r\n          hasEnhancement: !!enhancementResult\r\n        });\r\n      }\r\n      \r\n      return docs;\r\n    } catch (error) {\r\n      if (debugMode) {\r\n        this.logger.error('ðŸ“š [Context7-Debug] Documentation retrieval failed with error', {\r\n          libraryId,\r\n          topic,\r\n          error: error instanceof Error ? error.message : 'Unknown error',\r\n          stack: error instanceof Error ? error.stack : undefined,\r\n          errorType: typeof error\r\n        });\r\n      }\r\n      \r\n      this.logger.warn('Context7 documentation retrieval failed', { \r\n        libraryId, \r\n        topic, \r\n        error: error instanceof Error ? error.message : 'Unknown error' \r\n      });\r\n      return {\r\n        content: '',\r\n        metadata: {\r\n          libraryId,\r\n          topic,\r\n          tokens: tokens || 4000,\r\n          retrievedAt: new Date(),\r\n          source: 'Context7 MCP (error)'\r\n        }\r\n      };\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Parse Context7 text-based response format into library objects\r\n   * Context7 returns text like:\r\n   * \"Available Libraries (top matches):\\n\\n- Title: React\\n- Context7-compatible library ID: /websites/react_dev\\n- Description: ...\\n- Code Snippets: 1752\\n- Trust Score: 8\\n----------\\n...\"\r\n   */\r\n  private parseLibraryTextResponse(textContent: string): Context7LibraryInfo[] {\r\n    const libraries: Context7LibraryInfo[] = [];\r\n    \r\n    try {\r\n      // Split by library separator (----------)\r\n      const librarySections = textContent.split('----------').filter(section => section.trim());\r\n      \r\n      for (const section of librarySections) {\r\n        const lines = section.split('\\n').map(line => line.trim()).filter(line => line);\r\n        \r\n        let library: Partial<Context7LibraryInfo> = {};\r\n        \r\n        for (const line of lines) {\r\n          if (line.startsWith('- Title:')) {\r\n            library.name = line.replace('- Title:', '').trim();\r\n          } else if (line.startsWith('- Context7-compatible library ID:')) {\r\n            library.libraryId = line.replace('- Context7-compatible library ID:', '').trim();\r\n          } else if (line.startsWith('- Description:')) {\r\n            library.description = line.replace('- Description:', '').trim();\r\n          } else if (line.startsWith('- Code Snippets:')) {\r\n            const snippets = line.replace('- Code Snippets:', '').trim();\r\n            library.codeSnippets = parseInt(snippets) || 0;\r\n          } else if (line.startsWith('- Trust Score:')) {\r\n            const score = line.replace('- Trust Score:', '').trim();\r\n            library.trustScore = parseFloat(score) || 0;\r\n          } else if (line.startsWith('- Versions:')) {\r\n            const versions = line.replace('- Versions:', '').trim();\r\n            (library as any).versions = versions.split(',').map(v => v.trim());\r\n          }\r\n        }\r\n        \r\n        // Only add if we have the required fields\r\n        if (library.libraryId && library.name) {\r\n          libraries.push({\r\n            libraryId: library.libraryId,\r\n            name: library.name,\r\n            description: library.description || '',\r\n            codeSnippets: library.codeSnippets || 0,\r\n            trustScore: library.trustScore || 0,\r\n            ...((library as any).versions && { versions: (library as any).versions })\r\n          });\r\n        }\r\n      }\r\n    } catch (error) {\r\n      this.logger.warn('Failed to parse Context7 text response', { \r\n        error: error instanceof Error ? error.message : 'Unknown error',\r\n        textLength: textContent.length\r\n      });\r\n    }\r\n    \r\n    return libraries;\r\n  }\r\n\r\n  /**\r\n   * Get documentation for multiple frameworks in parallel\r\n   * This is the main method used by the enhance tool\r\n   */\r\n  async getDocumentation(\r\n    prompt: string,\r\n    detectedFrameworks: string[]\r\n  ): Promise<{ docs: string; libraries: string[] }> {\r\n    try {\r\n      if (!detectedFrameworks || detectedFrameworks.length === 0) {\r\n        return { docs: '', libraries: [] };\r\n      }\r\n\r\n      // Parallel library resolution\r\n      const libraryPromises = detectedFrameworks.map(fw =>\r\n        this.resolveLibraryId(fw)\r\n      );\r\n      const libraryResults = await Promise.all(libraryPromises);\r\n      \r\n      // Flatten and get unique library IDs\r\n      const allLibraries = libraryResults.flat();\r\n      const uniqueLibraries = [...new Set(allLibraries.map(lib => lib.libraryId))];\r\n      \r\n      if (uniqueLibraries.length === 0) {\r\n        return { docs: '', libraries: [] };\r\n      }\r\n\r\n      // Extract topic from prompt (simple keyword extraction)\r\n      const topic = this.extractTopicFromPrompt(prompt);\r\n      \r\n      // Parallel documentation fetching\r\n      const docPromises = uniqueLibraries.map(libraryId =>\r\n        this.getLibraryDocs(libraryId, topic, Math.floor(4000 / uniqueLibraries.length))\r\n      );\r\n      \r\n      const docResults = await Promise.all(docPromises);\r\n      \r\n      // Combine results\r\n      const allDocs = docResults\r\n        .filter(doc => doc && doc.content)\r\n        .map((doc, index) => `## ${uniqueLibraries[index]} Documentation:\\n${doc.content}`);\r\n      \r\n      return {\r\n        docs: allDocs.join('\\n\\n'),\r\n        libraries: uniqueLibraries\r\n      };\r\n    } catch (error) {\r\n      this.logger.warn('Context7 documentation retrieval failed', { \r\n        prompt: prompt.substring(0, 100) + '...', \r\n        detectedFrameworks,\r\n        error: error instanceof Error ? error.message : 'Unknown error' \r\n      });\r\n      return { docs: '', libraries: [] };\r\n    }\r\n  }\r"
      ],
      "context7_docs": [
        "### Caveats/Notes\n- The React tree you pass to `hydrateRoot` **must produce the same output** as it did on the server. Mismatches can lead to hydration errors, breaking the user experience and potentially causing issues like incorrect event handler attachments.\n- Common causes of hydration errors include extra whitespace, conditional rendering based on browser-only APIs (`typeof window`), or rendering different data on the server and client.\n- React recovers from some hydration errors, but they should be fixed like other bugs to prevent slowdowns or unexpected behavior.\n- To silence unavoidable hydration mismatch warnings for a single element's attribute or text content (e.g., a timestamp that varies), add `suppressHydrationWarning={true}` to the element. This only works one level deep and is intended as an escape hatch, not a general solution.\n```\n\n--------------------------------\n\nTITLE: Complete React application with createElement\nDESCRIPTION: This comprehensive JavaScript example combines the definition of a 'Greeting' component and its rendering within an 'App' component, all exclusively using the 'createElement' API. It provides a full illustration of building a basic React application without JSX.\n\nSOURCE: https://react.dev/reference/react/createElement\n\nLANGUAGE: javascript\nCODE:\n```\nimport { createElement } from 'react';\n\nfunction Greeting({ name }) {\n  return createElement(\n    'h1',\n    { className: 'greeting' },\n    'Hello ',\n    createElement('i', null, name),\n    '. Welcome!'\n  );\n}\n\nexport default function App() {\n  return createElement(\n    Greeting,\n    { name: 'Taylor' }\n  );\n}\n```\n\n--------------------------------\n\nTITLE: Tainting API password with `experimental_taintUniqueValue` (React)\nDESCRIPTION: This code snippet shows how to use `experimental_taintUniqueValue` to explicitly mark a sensitive environment variable, `API_PASSWORD`, as tainted. If this tainted value is ever inadvertently passed to a Client Component or a Server Function intended for the client, React will throw an error, providing an additional layer of security against leaks.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nimport \"server-only\";\nimport {experimental_taintUniqueValue} from 'react';\n\nexperimental_taintUniqueValue(\n  'Do not pass the API token password to the client. ' +\n    'Instead do all fetches on the server.',\n  process,\n  process.env.API_PASSWORD\n);\n```\n\n--------------------------------\n\nTITLE: preinitModule Function\nDESCRIPTION: This API function from `react-dom` allows you to eagerly fetch and evaluate an ESM module, providing a hint to the browser to start downloading and executing the module to save time. Modules preinitialized with this function are executed when they finish downloading.\n\nSOURCE: https://react.dev/reference/react-dom/preinitModule\n\nLANGUAGE: APIDOC\nCODE:\n```\n\n### Caveats\n- Multiple calls to `preinitModule` with the same `href` have the same effect as a single call.\n- In the browser, you can call `preinitModule` in any situation: while rendering a component, in an Effect, in an event handler, and so on.\n- In server-side rendering or when rendering Server Components, `preinitModule` only has an effect if you call it while rendering a component or in an async context originating from rendering a component. Any other calls will be ignored.\n```\n\n--------------------------------\n\nTITLE: Basic `preinitModule` Call in React\nDESCRIPTION: Demonstrates a direct call to `preinitModule` with a URL and required `as` option to eagerly fetch and evaluate an ESM module. This is the simplest form of using the API to initiate module loading.\n\nSOURCE: https://react.dev/reference/react-dom/preinitModule\n\nLANGUAGE: javascript\nCODE:\n```\npreinitModule(\"https://example.com/module.js\", {as: \"script\"});\n```\n\n--------------------------------\n\nTITLE: Create Node.js API Endpoint to Serve File Content\nDESCRIPTION: This Node.js/Express snippet provides a backend API route (`/api/content/:page`) responsible for reading markdown file content from the filesystem. It serves as the data source for the client-side `fetch` operation shown in the `Page` component, enabling dynamic content delivery.\n\nSOURCE: https://react.dev/reference/rsc/server-components\n\nLANGUAGE: javascript\nCODE:\n```\n// api.js  \n\napp.get(`/api/content/:page`, async (req, res) => {  \n  const page = req.params.page;  \n  const content = await file.readFile(`${page}.md`);  \n  res.send({content});  \n});\n```\n\n--------------------------------\n\nTITLE: React flushSync Integration with Browser `onbeforeprint` API\nDESCRIPTION: This code showcases a practical application of `flushSync` for integrating with a browser's `onbeforeprint` API. It ensures that the `isPrinting` state is immediately updated and rendered to the DOM before the print dialog opens, allowing for custom print styles or content changes to be visible to the user at the correct time.\n\nSOURCE: https://react.dev/reference/react-dom/flushSync\n\nLANGUAGE: javascript\nCODE:\n```\nimport { useState, useEffect } from 'react';\nimport { flushSync } from 'react-dom';\n\nexport default function PrintApp() {\n  const [isPrinting, setIsPrinting] = useState(false);\n\n  useEffect(() => {\n    function handleBeforePrint() {\n      flushSync(() => {\n        setIsPrinting(true);\n      })\n    }\n\n    function handleAfterPrint() {\n      setIsPrinting(false);\n    }\n\n    window.addEventListener('beforeprint', handleBeforePrint);\n    window.addEventListener('afterprint', handleAfterPrint);\n    return () => {\n      window.removeEventListener('beforeprint', handleBeforePrint);\n      window.removeEventListener('afterprint', handleAfterPrint);\n    }\n  }, []);\n\n  return (\n    <>\n      <h1>isPrinting: {isPrinting ? 'yes' : 'no'}</h1>\n      <button onClick={() => window.print()}>\n        Print\n      </button>\n    </>\n  );\n}\n```\n\n--------------------------------\n\nTITLE: Use React 19 APIs for Resource Preloading in Components\nDESCRIPTION: This JavaScript snippet demonstrates how to use the new `react-dom` preloading APIs (`preinit`, `preload`, `prefetchDNS`, `preconnect`) within a React component. These APIs help optimize page load performance by instructing the browser to fetch critical resources early, such as scripts, fonts, stylesheets, or DNS information, before they are explicitly needed. Inputs are resource URLs and type hints; the output is faster resource availability and improved user experience.\n\nSOURCE: https://react.dev/blog/2024/04/25/react-19\n\nLANGUAGE: javascript\nCODE:\n```\nimport { prefetchDNS, preconnect, preload, preinit } from 'react-dom'\n\nfunction MyComponent() {\n\n  preinit('https://.../path/to/some/script.js', {as: 'script' }) // loads and executes this script eagerly\n\n  preload('https://.../path/to/font.woff', { as: 'font' }) // preloads this font\n\n  preload('https://.../path/to/stylesheet.css', { as: 'style' }) // preloads this stylesheet\n\n  prefetchDNS('https://...') // when you may not actually request anything from this host\n\n  preconnect('https://...') // when you will request something but aren't sure what\n\n}\n```\n\n--------------------------------\n\nTITLE: Basic Syntax for `experimental_taintObjectReference` in React\nDESCRIPTION: This snippet shows the basic function signature for `experimental_taintObjectReference`. It takes a message string and the object to be tainted as arguments, returning `undefined`.\n\nSOURCE: https://react.dev/reference/react/experimental_taintObjectReference\n\nLANGUAGE: javascript\nCODE:\n```\nexperimental_taintObjectReference(message, object);\n```\n\n--------------------------------\n\nTITLE: JavaScript: Safely memoizing a function call from a library API\nDESCRIPTION: This React component illustrates a general principle for designing library APIs: ensure that functions returned by the API can be safely memoized using `useMemo`. The example shows how `someFunction` is memoized, emphasizing that this pattern should not break memoization.\n\nSOURCE: https://react.dev/reference/eslint-plugin-react-hooks/lints/incompatible-library\n\nLANGUAGE: javascript\nCODE:\n```\nfunction Component() {  \n  const { someFunction } = useLibrary();  \n  // it should always be safe to memoize functions like this  \n  const result = useMemo(() => someFunction(), [someFunction]);  \n}\n```\n\n--------------------------------\n\nTITLE: Conditional Context Reading with React `use`\nDESCRIPTION: This example showcases the unique flexibility of the React `use` API by calling it within an `if` statement. It allows conditionally reading a context value based on a prop, enabling more dynamic component logic than traditional Hooks.\n\nSOURCE: https://react.dev/reference/react/use\n\nLANGUAGE: JavaScript\nCODE:\n```\nfunction HorizontalRule({ show }) {\n  if (show) {\n    const theme = use(ThemeContext);\n    return <hr className={theme} />;\n  }\n  return false;\n}\n```\n\n## /websites/react_dev Documentation:\n================\nCODE SNIPPETS\n================\nTITLE: Secure API calls with `server-only` to prevent client exposure (React)\nDESCRIPTION: This example demonstrates a secure pattern for handling sensitive API credentials using the `server-only` package. It ensures that the `fetchAPI` helper, which accesses `process.env.API_PASSWORD`, can only be imported and executed on the server, preventing accidental exposure to client components.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nimport \"server-only\";\n\nexport function fetchAPI(url) {\n  const headers = { Authorization: process.env.API_PASSWORD };\n  return fetch(url, { headers });\n}\n```\n\n--------------------------------\n\nTITLE: Basic React `use` API Call\nDESCRIPTION: This snippet demonstrates the fundamental syntax for using the React `use` API to read a resource's value. It shows a simple assignment of the resource's value to a variable, highlighting the core interaction with the API.\n\nSOURCE: https://react.dev/reference/react/use\n\nLANGUAGE: JavaScript\nCODE:\n```\nconst value = use(resource);\n```\n\n--------------------------------\n\nTITLE: Read Resource Values with React's `use` API\nDESCRIPTION: This code snippet demonstrates how to use the `use` API in React to read values from resources such as Promises or Context. The `use` Hook allows a component to access data without making it part of its state, simplifying data consumption from various sources.\n\nSOURCE: https://react.dev/reference/react/apis\n\nLANGUAGE: javascript\nCODE:\n```\nfunction MessageComponent({ messagePromise }) {\n  const message = use(messagePromise);\n  const theme = use(ThemeContext);\n  // ...\n}\n```\n\n--------------------------------\n\nTITLE: Importing React Children API\nDESCRIPTION: This code snippet demonstrates the correct way to import the `Children` API (with a capital 'C') from the 'react' library. This API provides utility functions for working with the `children` prop in React components, distinguishing it from the `children` prop itself (lowercase 'c').\n\nSOURCE: https://react.dev/reference/react/Children\n\nLANGUAGE: javascript\nCODE:\n```\nimport { Children } from 'react';\n```\n\n--------------------------------\n\nTITLE: Anti-pattern: Leaking API password to Client Component (React)\nDESCRIPTION: This code demonstrates an anti-pattern where a server-side `API_PASSWORD` is directly passed as a prop to a Client Component, `Overview`. This method exposes sensitive information to the client, leading to potential security vulnerabilities and data breaches. This should be avoided.\n\nSOURCE: https://react.dev/reference/react/experimental_taintUniqueValue\n\nLANGUAGE: javascript\nCODE:\n```\nexport async function Dashboard(props) {\n  // DO NOT DO THIS\n  return <Overview password={process.env.API_PASSWORD} />;\n}\n```\n\nLANGUAGE: javascript\nCODE:\n```\n\"use client\";\n\nimport {useEffect} from '...'\n\nexport async function Overview({ password }) {\n  useEffect(() => {\n    const headers = { Authorization: password };\n    fetch(url, { headers }).then(...);\n  }, [password]);\n  ...\n}\n```\n\n--------------------------------\n\nTITLE: Read external store with React use API\nDESCRIPTION: This JavaScript snippet demonstrates the new `use` API introduced in React 19 for reading values from external stores. This API is designed to support concurrent rendering more efficiently than `useSyncExternalStore`, integrating seamlessly with React's concurrent features and avoiding bail-outs or Suspense fallbacks.\n\nSOURCE: https://react.dev/blog/2025/04/23/react-labs-view-transitions-activity-and-more\n\nLANGUAGE: javascript\nCODE:\n```\nconst value = use(store);\n```\n\n--------------------------------\n\nTITLE: JavaScript Function: hydrateRoot()\nDESCRIPTION: `hydrateRoot` is used to hydrate server-rendered HTML on the client side. It attaches React components' logic to the initial generated HTML, transforming a static server snapshot into an interactive application.\n\nSOURCE: https://react.dev/reference/react-dom/client/hydrateRoot\n\nLANGUAGE: APIDOC\nCODE:\n```\n\n### Request Example\n```json\n{\n  \"example\": \"import { preinitModule } from 'react-dom';\\n\\nfunction AppRoot() {\\n  preinitModule(\\\"https://example.com/module.js\\\", {as: \\\"script\\\"});\\n  // ...\\n}\\n\\n// In an event handler\\nfunction CallToAction() {\\n  const onClick = () => {\\n    preinitModule(\\\"https://example.com/module.js\\\", {as: \\\"script\\\"});\\n    startWizard();\\n  }\\n  return (\\n    <button onClick={onClick}>Start Wizard</button>\\n  );\\n}\"\n}\n```\n\n### Response\n#### Returns (void)\n`preinitModule` returns nothing.\n\n#### Response Example\n```json\n{\n  \"example\": \"Function returns nothing\"\n}\n```"
      ]
    },
    "success": true,
    "todos": [],
    "frameworks_detected": [],
    "ai_enhancement": {
      "enabled": false,
      "strategy": "none",
      "quality_score": 0,
      "confidence_score": 0,
      "improvements": [],
      "recommendations": [],
      "processing_time": 0,
      "cost": 0
    }
  },
  "performance": {
    "originalTokens": 26,
    "enhancedTokens": 1730,
    "tokenRatio": 66.53846153846153,
    "responseTime": 2110,
    "context7Used": false,
    "context7LibrariesResolved": 0
  },
  "quality": {
    "overall": 20,
    "details": {
      "frameworkAccuracy": "0%",
      "context7Accuracy": "0%",
      "errorExplanation": "Present",
      "educational": "Present",
      "typeGuards": "Present",
      "solution": "Present",
      "contentQuality": "20/25"
    },
    "breakdown": {
      "performance": 6,
      "accuracy": 9,
      "content": 5
    }
  },
  "context": {
    "repoFacts": 16,
    "codeSnippets": 10,
    "frameworkDocs": 0,
    "projectDocs": 0,
    "context7Docs": 1
  },
  "libraries": [],
  "timestamp": "2025-09-25T23:13:29.834Z"
}